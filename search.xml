<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>golang 垃圾回收机制</title>
    <url>/posts/88f7796/</url>
    <content><![CDATA[<h1 id="Golang-垃圾回收"><a href="#Golang-垃圾回收" class="headerlink" title="Golang 垃圾回收"></a>Golang 垃圾回收</h1><blockquote>
<p><strong>垃圾回收 (Garbage Collection, 简称 GC)是编程语言中自动的内存管理机制，清除不再使用的对象，释放对应内存</strong>。</p>
</blockquote>
<h2 id="Golang-GC-各版本变化"><a href="#Golang-GC-各版本变化" class="headerlink" title="Golang GC 各版本变化"></a>Golang GC 各版本变化</h2><table>
<thead>
<tr>
<th>版本</th>
<th>GC 算法</th>
</tr>
</thead>
<tbody><tr>
<td>v1.1</td>
<td>STW(stop the world)</td>
</tr>
<tr>
<td>v1.3</td>
<td>Mark STW,Sweep（标记清除）</td>
</tr>
<tr>
<td>v1.5</td>
<td>三色标记</td>
</tr>
<tr>
<td>v1.8</td>
<td>Hybrid wire barrier (三色标记基础加入写屏障)</td>
</tr>
</tbody></table>
<h3 id="标记清除算法（mark-and-sweep-v1-3"><a href="#标记清除算法（mark-and-sweep-v1-3" class="headerlink" title="标记清除算法（mark and sweep, v1.3)"></a>标记清除算法（mark and sweep, v1.3)</h3><ul>
<li><ol>
<li>找出不可达对象，mark</li>
</ol>
</li>
<li><ol start="2">
<li>回收标记好的对象</li>
</ol>
</li>
</ul>
<p>mark and sweep 算法在执行的时候，需要程序暂停，即 stop the world</p>
<p>标记清除算法存在的问题</p>
<ul>
<li>stop the world 程序会暂停，即程序会出现卡顿</li>
<li>标记需要扫描整个堆（heap）</li>
<li>清除数据会产生 heap 碎片</li>
</ul>
<h2 id="三色并发标记法-v-1-5"><a href="#三色并发标记法-v-1-5" class="headerlink" title="三色并发标记法(v 1.5)"></a>三色并发标记法(v 1.5)</h2><p>该算法是在 v1.5 版本开始使用，这里的三色，对应垃圾回收过程中对象的三种状态：</p>
<ul>
<li><strong>灰色：对象还在标记队列中等待</strong></li>
<li><strong>黑色：对象已被标记，该对象不会在本次 GC 中被清理</strong></li>
<li><strong>白色：对象未被标记，该对象将会在本次 GC 中被清理</strong></li>
</ul>
<h2 id="三色标记法的过程-v1-5"><a href="#三色标记法的过程-v1-5" class="headerlink" title="三色标记法的过程(v1.5)"></a>三色标记法的过程(v1.5)</h2><ol>
<li><p>初始阶段，<strong>所有对象都是白色：</strong></p>
<img src="/images/go/GC_1.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>GC 开始扫描，<strong>从根节点开始遍历</strong>，A 和 F 是根节点，将其标记为灰色对象, <strong>即根节点先置灰。</strong></p>
<img src="/images/go/GC_2.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>GC 继续扫描灰色对象，<strong>将根节点的子节点标记为灰色对象</strong>。A 的子节点 B C D 被标记为灰色对象，A 被标记为黑色对象。F 没有子节点，也被标记为黑色对象，<strong>即根节点置黑，子节点置灰</strong></p>
<img src="/images/go/GC_3.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>GC 会<strong>循环遍历灰色对象，直到灰色对象之中没有节点结束</strong>。B、C、D没有子节点，会变为黑色对象，<strong>即循环遍历所有节点，将所有父节点置黑。</strong></p>
<img src="/images/go/GC_4.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>未被标记的 E、G、H 为白色对象，GC 便会回收这些白色对象，<strong>即回收未被标记的白色对象</strong>。</p>
<img src="/images/go/GC_5.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>这一轮垃圾回收结束后，<strong>GC 会进行进一步操作，将黑色对象重新变为白色对象，供下一次垃圾回收使用</strong>。</p>
<img src="/images/go/GC_6.png" width = "500" height = "350" alt="" align=center /></li>
</ol>
<h2 id="垃圾回收优化-写屏障"><a href="#垃圾回收优化-写屏障" class="headerlink" title="垃圾回收优化-写屏障"></a>垃圾回收优化-写屏障</h2><p>STW (stop the world) 的目的是防止 GC 扫描时内存变化而停掉 goroutine, 而<strong>写屏障就是让 goroutine 与 GC 同时运行的手段</strong>。<br>虽然写屏障不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障类似一种开关，在 GC 的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定。<br>GC 过程中新分配的内存会被立即标记，用的并不是写屏障技术，也即 GC 过程中分配的内存不会在本轮 GC 中回收。</p>
<h2 id="垃圾回收优化-Mutator-Assist"><a href="#垃圾回收优化-Mutator-Assist" class="headerlink" title="垃圾回收优化-Mutator-Assist"></a>垃圾回收优化-Mutator-Assist</h2><p>为防止内存分配过快、在 GC 执行过程中，如果 goroutine 需要分配内存，那么这个 goroutine 会参与一部分 GC 的工作，这个机制叫做 Mutator Assist。</p>
<h2 id="垃圾回收触发机制"><a href="#垃圾回收触发机制" class="headerlink" title="垃圾回收触发机制"></a>垃圾回收触发机制</h2><ol>
<li><p>每次内存分配时都会检查当前内存分配量是否 已经到达阈值，如果达到就立即启动 GC。内存增长率由环境变量<code>GOGC</code> 控制，默认是 100，即每当内存扩大一倍时启动 GC。<br>之后堆内存达到上一次垃圾手机的 2 倍才会触发 GC.</p>
</li>
<li><p>默认情况下，最长 2 分钟触发一次 GC。</p>
</li>
<li><p>程序代码中也可以使用 runtime.GC() 来手动触发 GC。这主要用于 GC 性能测试和统计。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 常用数据类型结构剖析</title>
    <url>/posts/28bd12e6/</url>
    <content><![CDATA[<h1 id="Redis-常用的数据类型剖析"><a href="#Redis-常用的数据类型剖析" class="headerlink" title="Redis 常用的数据类型剖析"></a>Redis 常用的数据类型剖析</h1><h2 id="Redis-数据库介绍"><a href="#Redis-数据库介绍" class="headerlink" title="Redis 数据库介绍"></a>Redis 数据库介绍</h2><blockquote>
<p>Redis 是一种键值（Key-Value）、基于内存的非关型数据库、读写性能非常好。</p>
<p>Redis 中，键的数据类型是字符串，常用的值的数据类型有：字符串、列表、列表、集合、有序集合</p>
</blockquote>
<h2 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h2><p>列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法：</p>
<ul>
<li><strong>压缩列表（ziplist）</strong></li>
<li><strong>双向循环链表（circle chain）</strong></li>
</ul>
<p>当列表中存储的数据量比较小的时候，列表可以采用<strong>压缩列表</strong>的方式实现：</p>
<ul>
<li>列表中保存的单个数据（有可能是字符串类型）<strong>小于 64 字节</strong>；</li>
<li>列表中的数据<strong>少于 512 个</strong>；</li>
</ul>
<p>如何理解这种压缩列表？</p>
<p>压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据结构的存储。而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。</p>
<img src="https://static001.geekbang.org/resource/image/49/b5/49fd8d46eb94f463ace98717f11c2cb5.jpg?wh=1142*381" alt="img" style="zoom:67%;" />

<p>源码：<a href="https://github.com/redis/redis/blob/3b462ce566e577ffcb35822a0a2372f691326cd4/src/adlist.h">https://github.com/redis/redis/blob/3b462ce566e577ffcb35822a0a2372f691326cd4/src/adlist.h</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是C语言代码，因为Redis是用C语言实现的。</span></span><br><span class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>



<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典类型用来存储一组数据对。可以理解为 key-value-field</p>
<p>字典类型也有两种实现方法：</p>
<ul>
<li><strong>压缩列表（ziplist）</strong></li>
<li><strong>散列表</strong></li>
</ul>
<p>当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型：</p>
<ul>
<li><strong>字典中保存的键和值的大小都要小于 64 字节；</strong></li>
<li><strong>字典中的键值对的个数都要小于 512 个；</strong></li>
</ul>
<p>当存储的数据不满足以上条件时，Redis 就使用散列表来实现字典类型：<strong>Redis 使用 <a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C">MurmmurHash2</a> 这种运行速度快、随机性好的哈希算法作为哈希函数</strong>。对于哈希冲突问题，Redis 使用 链表法来解决。此外 Redis 还支持散列表的动态扩容、缩容：</p>
<ul>
<li>当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右。</li>
<li>当数据动态减少时，为了节约内存，当装载因子小于 1.0 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小。</li>
</ul>
<p>为了避免缩容与扩容的大量的数据搬移和哈希值的重新计算的耗时，Redis 使用的是渐进式缩容扩容策略，将数据的搬移分批进行，避免大量数据一次性搬移导致的服务停顿。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合这种数据类型用来存储一组不重复的数据。**这种数据类型也有两种实现方法: **</p>
<ul>
<li>一种是基于<strong>有序数组</strong></li>
<li>另一种是基于<strong>散列表</strong></li>
</ul>
<p>有序数组使用的限制：</p>
<ul>
<li>存储的数据都是<strong>整数</strong></li>
<li>存储的数据元素个数<strong>不超过 512 个</strong></li>
</ul>
<p>当不同同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。</p>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>它用来存储一组数据，并且每个数据会附带一个得分。</p>
<p>和 Redis 的其他类型的数据一样，有序集合也并不仅仅只有<strong>跳表</strong>这一种实现方式，<strong>当数据量比较小的时候，Redis 会使用压缩列表来实现有序集合：</strong></p>
<ul>
<li><strong>所有的数据大小</strong>都要<strong>小于 64 字节</strong>；</li>
<li>元素个数都要小于 <strong>128</strong> 个；</li>
</ul>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis 虽然是内存数据库，但是也支持数据落盘，其中有两种是持久化方式：<strong>aof &amp;&amp; rdb</strong>；</p>
<p>如何将数据结构持久化到硬盘，主要有两种思路：</p>
<ul>
<li><p><strong>第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思想。</strong></p>
</li>
<li><p>第二种方式就是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。例如散列表：可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。</p>
</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>redis 的数据类型可以由多种数据结构实现，主要是出于时间和空间的考虑。</p>
<ul>
<li><p>当数据量较小时，采用连续空间的数据结构，例如压缩数组和有序数组，可以提升访问效率</p>
</li>
<li><p>当数据量较大时，采用采用链表结构，节省内存，同时当需要保证速度的时候，就可以使用散列表来实现。</p>
</li>
</ul>
<p>参考：<a href="https://www.modb.pro/db/71948">https://www.modb.pro/db/71948</a></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache &amp;&amp; DB 数据一致性</title>
    <url>/posts/c4a988da/</url>
    <content><![CDATA[<h1 id="Redis、MySQL-如何保证数据一致性？"><a href="#Redis、MySQL-如何保证数据一致性？" class="headerlink" title="Redis、MySQL 如何保证数据一致性？"></a>Redis、MySQL 如何保证数据一致性？</h1><blockquote>
<p>一般情况下，Redis 是用来实现应用和数据库之间的一个读操作的缓存层。主要目的是去减少数据库的 IO ,还可以提升数据库的 IO 性能。</p>
</blockquote>
<p>整体架构：<br><img src="/images/Redis-MySQL架构.png" width = "500" height = "300" alt="" align=center /></p>
<p>当应用程序需要去读取某个数据的时候，首先会尝试 Redis 里面去加载，如果命中了就直接去加载，直接返回数据，如果没有命中，就查询数据库，然后再将查询到的数据写入到 redis 缓存中。</p>
<p>在这个架构里面呢，会出现<code>数据一致性的问题</code>。</p>
<p>一份数据同时被保存在 redis 和 mysql 里面，当某个数据需要被更新的时候，由于更新数据是具有前后顺序的，它并不像 mysql 中的多表事务操作，可以满足 ACID 的特性。</p>
<p>常规解决办法只有两种：</p>
<ol>
<li><p>先更新数据库，再更新缓存。</p>
<p>该种方案，若出现缓存失败的话，会出现数据不一致的问题。</p>
</li>
<li><p>先删除缓存，再更新数据库。</p>
<p>该种方案，是借助再次访问该数据的时候，发现 redis 里的数据为空，然后查询数据库再次加载。但是这两个操作并不是原子操作，所以在这个过程中，如果出现其他线程来访问，还是会存在数据不一致的问题。</p>
</li>
</ol>
<p>那么，需要在极端情况下仍要保证 redis 和 mysql 数据一致性，就需要采用 <code>最终一致性</code>的方案。</p>
<p>例如 <code>基于 MQ 的可靠性消息通信</code>来实现数据最终的一致性。</p>
<p>或者，直接通过 Canel 组件，监控 mysql 中的 bingo 的日志，将更新后的数据同步到 Redis 里面。</p>
<p>接下来，就聊一下各种缓存方案…</p>
<h2 id="一致性-consistency"><a href="#一致性-consistency" class="headerlink" title="一致性(consistency)"></a>一致性(consistency)</h2><blockquote>
<p>一致性就是缓存和数据库存储数据的两份数据保持一致性</p>
</blockquote>
<ul>
<li>强一致性要求：<blockquote>
<p>所谓强一致性，就是对于 app 来说，缓存和数据库存储的数据读写是符合原子性的，要求读写的一致性，实现起来时对系统的影响大。</p>
</blockquote>
</li>
<li>弱一致性：<blockquote>
<p>这部分对于缓存层和数据库层数据一致性要求较低，不要求在更新数据时，缓存和数据库立即同步更新的情况，也不会要求缓存和数据库多久达到一致性，但是会尽可能保证<br>到某个时间级别后，数据能够达到一致性状态。</p>
</blockquote>
</li>
<li>最终一致性：<blockquote>
<p>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。</p>
</blockquote>
</li>
</ul>
<h1 id="三种经典的缓存模式"><a href="#三种经典的缓存模式" class="headerlink" title="三种经典的缓存模式"></a>三种经典的缓存模式</h1><ul>
<li>Cache-Aside Pattern</li>
<li>Read-Through/Write through</li>
<li> Write behind</li>
</ul>
<h2 id="Cache-Aside-读流程"><a href="#Cache-Aside-读流程" class="headerlink" title="Cache-Aside 读流程"></a>Cache-Aside 读流程</h2><blockquote>
<p>旁路缓存模式，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题</p>
</blockquote>
<p>Cache-Aside 读流程</p>
<img src="/images/Cache-Aside.png" width = "300" height = "400" alt="" align=center />


<ol>
<li>读取数据的时候，先读缓存，缓存命中时，直接返回数据。</li>
<li>缓存未命中时，读取数据库，取数据的时候同时更新数据到缓存中，返回响应</li>
</ol>
<h2 id="Cache-Aside-写流程"><a href="#Cache-Aside-写流程" class="headerlink" title="Cache-Aside 写流程"></a>Cache-Aside 写流程</h2><blockquote>
<p>更新的时候，先更新数据库，然后再删除缓存</p>
</blockquote>
<img src="/images/Cache-Aside-write.png" width = "200" height = "300" alt="" align=center />

<h2 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read-Through"></a>Read-Through</h2><blockquote>
<p>Read/Write Through 模式中，服务端把<code>缓存</code>作为<code>主要数据存储</code>。应用程序跟数据库缓存交互，都是通过<code>抽象缓存层</code>完成的</p>
</blockquote>
<img src="/images/Cache-Aside-whole-process.png" width = "600" height = "400" alt="" align=center />

<p>Read-Through 的思想是采用的将缓存作为主要的存储结构，是从性能的角度出发。</p>
<h2 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write-Through"></a>Write-Through</h2><blockquote>
<p>这种模式下，当发生请求时，是由缓存抽象层完成数据源和缓存数据的更新<br><img src="/images/Cache-Aside-write-process.png" width = "600" height = "400" alt="" align=center /></p>
</blockquote>
<h2 id="Write-behind-（异步缓存写入）"><a href="#Write-behind-（异步缓存写入）" class="headerlink" title="Write behind （异步缓存写入）"></a>Write behind （异步缓存写入）</h2><blockquote>
<p>Write behind 和 Read-Through/Write-Through 相似，都是由 <code>Cache Provider</code>来负责缓存和数据库看的读写。<br>但是 前者是同步更新缓存和数据的，Write Behind 则只是更新缓存，不直接更新数据库，通过<code>批量异步</code>的方式来更新数据库。<br><img src="/images/Cache-Aside-write-behind-process.png" width = "600" height = "400" alt="" align=center /></p>
</blockquote>
<h2 id="三种模式的比较"><a href="#三种模式的比较" class="headerlink" title="三种模式的比较"></a>三种模式的比较</h2><p>Cache Aside 更新模式实现起来比较简单，但是需要维护两个数据存储:</p>
<ul>
<li>缓存（Cache）</li>
<li>一个是数据库（Repository）</li>
</ul>
<p>Read/Write Through 的写模式需要维护一个数据存储（Cache Provider），实现起来较为复杂一些。</p>
<p>Write Behind Caching 更新模式和 Read/Write Through 更新模式类似，区别是 Write Behind Caching 更新模式的数据持久化操作是<code>异步</code>的，但是`Read/Write Through 更新模式的数据持久化操作是<strong>同步的</strong></p>
<p>Write Behind Caching 的优点是直接<code>操作内存速度快</code>,多次操作可以合并持久化到数据库。缺点是数据可能会丢失，例如系统断电等等。</p>
<h2 id="Cache-Aside-问题"><a href="#Cache-Aside-问题" class="headerlink" title="Cache-Aside 问题"></a>Cache-Aside 问题</h2><p><strong>我们在更新数据的时候，Cache-Aside 是删除缓存呢，还是应该更新缓存？</strong></p>
<img src="/images/Cache-Aside-write.png" width = "200" height = "300" alt="" align=center />

<p>我们在操作缓存的时候，到底是应该删除缓存还是说更新缓存呢？我们先来看个例子：<br>多线程情况：<br><img src="/images/多线程-Cache-DB.png" width = "600" height = "400" alt="" align=center /></p>
<p>以上情况就可以看出来问题：</p>
<blockquote>
<p>线程 A 先发起一个写操作，先更新数据库。<br>线程 B 再发起写操作，更新数据库。</p>
</blockquote>
<p>现在由于网络原因，线程 B 的更新缓存的操作却在 A 之后发生。<br>此时缓存中的数据就是与数据库中不一致了。</p>
<p><strong>更新缓存相对于删除缓存还有两点劣势</strong>：</p>
<blockquote>
<ol>
<li>若写入缓存的值，是经过复杂计算才得到，更新频率较高的情况下，十分浪费性能。</li>
<li>在写多读少的情况下，也会十分浪费性能。</li>
</ol>
</blockquote>
<h2 id="双写的情况下，先操作数据库还是先操作缓存？"><a href="#双写的情况下，先操作数据库还是先操作缓存？" class="headerlink" title="双写的情况下，先操作数据库还是先操作缓存？"></a>双写的情况下，先操作数据库还是先操作缓存？</h2><p>如果遇到多线程情况，也会有类似情况，出现缓存中存储的是脏数据。因此 Cache-Aside 缓存模式，选择了先操作数据库而不是先操作缓存</p>
<h1 id="两种方案保证数据库与缓存的一致性"><a href="#两种方案保证数据库与缓存的一致性" class="headerlink" title="两种方案保证数据库与缓存的一致性"></a>两种方案保证数据库与缓存的一致性</h1><ul>
<li>删除缓存重试机制</li>
<li>读取 binlog 异步删除缓存</li>
</ul>
<h2 id="删除缓存重试机制"><a href="#删除缓存重试机制" class="headerlink" title="删除缓存重试机制"></a>删除缓存重试机制</h2><p>多次删除确保 cache 中存储的是正确的数据<br><img src="/images/del_cache_retry.png" width = "600" height = "400" alt="" align=center /></p>
<p>删除缓存重试机制的大致步骤：</p>
<ul>
<li>写请求更新数据库</li>
<li>缓存因为某些原因，删除失败</li>
<li>把删除失败的 key 放到消息队列</li>
<li>消费消息队列的消息，获取要删除的 key</li>
<li>重试删除缓存操作</li>
</ul>
<h2 id="同步-binlog-异步删除缓存"><a href="#同步-binlog-异步删除缓存" class="headerlink" title="同步 binlog 异步删除缓存"></a>同步 binlog 异步删除缓存</h2><p>重试删除缓存机制还可以，就是会造成好多业务代码入侵。<br>其实，还可以通过数据库的 binlog 来异步淘汰 key</p>
<img src="/images/binlog.png" width = "600" height = "400" alt="" align=center />

<p>以 mysql 为例，可以使用阿里的 canal 将 binlog 日志采集发送到 MQ 队列里面，然后编写一个简单的缓存删除<br>消息者订阅 binlog 日志，根据更新 log 删除缓存，并且通过 ACK 机制确认处理这条更新 log,保证数据缓存一致性。</p>
<p>总结：<br>综上所述，在分布式系统中，缓存和数据库同时存在时，如果有写操作的时候，「 先操作数据库，再操作缓存 」</p>
<p>参考：「 <a href="https://www.cnblogs.com/crazymakercircle/p/14853622.html">https://www.cnblogs.com/crazymakercircle/p/14853622.html</a> 」</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 高可用方案——主从复制</title>
    <url>/posts/fef928ba/</url>
    <content><![CDATA[<h1 id="Redis-高可用方案之主从复制"><a href="#Redis-高可用方案之主从复制" class="headerlink" title="Redis 高可用方案之主从复制"></a>Redis 高可用方案之主从复制</h1><p>今天来学习一下 Redis 的高可用方案中的主从复制。主从复制是指当我们部署了拥有多台 Redis 结点的集群时，为了保证数据的一致性，将主节点的数据复制到从节点上的过程。</p>
<p>主从复制主要的目的是：</p>
<ul>
<li><strong>数据冗余</strong>：主从复制实现了数据的热备份。</li>
<li><strong>故障恢复</strong>：当主节点出现问题时，可以根据哨兵选举出另外的主节点提供服务。</li>
<li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，在写少读多的场景下，通过多个从节点负担读负载，提升 Redis 服务器的并发量。</li>
<li><strong>高可用基石</strong>：除了上述作用之外，主从复制还是哨兵和集群能够实施的基础。</li>
</ul>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ul>
<li>全量复制：例如第一次同步数据时</li>
<li>增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库</li>
</ul>
<p>在 Redis 复制的基础上，使用和配置主从复制非常简单，能使得从 Redis 服务器 能精确地复制主服务器的数据。 主要依靠三个机制：</p>
<ul>
<li><strong>当一个 master 实例和一个 slave 实例连接正常时</strong>，master 会发送一连串的命令流来保持对 slave 的更新，以便对 slave 的更新，以便将自身的数据集的改变复制给 slave: 包括客户端的写入、key 的过期或被逐出等待。</li>
<li><strong>当 master 和 slave 之间的连接断开之后</strong>，因为网络问题、或者时主从意识连接超时，slave 重新连接上 master 并会尝试 进行部分重同步：这意味着它会<strong>尝试只获取在断在连接期间内丢失的命令流</strong>。</li>
<li><strong>当无法进行部分重同步时</strong>，slave 会请求进行全量同步。这会涉及一个更为复杂的过程，例如 master 需要创建所有数据的快照，将之发送 给 slave，之后在数据集更改时持续发送命令流到 slave</li>
</ul>
<p>Redis 使用的默认是<strong>异步复制</strong>，其特点是低延迟和高性能，是绝大多数 Redis 用例的自然复制模式。但是， 从 Redis 服务器会异步地确认其从主 Redis 服务器周期接收到的数据量。</p>
<h3 id="redis-复制过程"><a href="#redis-复制过程" class="headerlink" title="redis 复制过程"></a>redis 复制过程</h3><ol>
<li>从节点执行 slaveof [masterIP] [masterPort] , 保存主节点信息</li>
<li>从节点中的定时任务发现主节点信息，建立与主节点的 socket 连接</li>
<li>从节点发送 Ping 信号，主节点返回 Pong, 互相通信</li>
<li>连接建立后，主节点将所有数据发送给从节点（数据同步）</li>
<li>主节点把当前的数据同步给从节点后，便完成了辅助的建立过程。接下来，主节点就会持续的把写命令发送给从节点， 保证主从数据一致性</li>
</ol>
<h2 id="为什么主从全量复制使用-RDB-而不使用-AOF"><a href="#为什么主从全量复制使用-RDB-而不使用-AOF" class="headerlink" title="为什么主从全量复制使用 RDB 而不使用 AOF ?"></a>为什么主从全量复制使用 RDB 而不使用 AOF ?</h2><p>RDB 文件内容是经过压缩的<strong>二进制数据</strong>（不同数据类型数据做了针对性优化），<strong>文件很小</strong>。而 AOF 文件记录的是每一次写操作的命令，写操作越多文件会越大，其中还包括对同一个 key 的多次冗余操作。<strong>在主从全量数据同步时，传输 RDB 文件可以尽量降低对主库机器网络带宽的消耗。</strong>对于二进制数据，从库直接按照 RDB 协议还原数据即可，速度会非常快，而 AOF 需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比 RDB 会慢很多。所以使用 RDB 进行主从全量复制的成本最低。</p>
<h2 id="读写分离及其中的问题"><a href="#读写分离及其中的问题" class="headerlink" title="读写分离及其中的问题"></a>读写分离及其中的问题</h2><p>在主从复制基础上实现的读写分离，可以实现 Redis 的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务；在读负载较大的应用场景下，可以大大提高 Redis 服务器的并发量。但是由于服务时异步的，也会存在相关问题：</p>
<ul>
<li><p>延迟与不一致问题</p>
<p>由于主从复制的命令传播是异步的，延迟与数据一致性不可避免。若应用对数据不一致的接受程度较低，可能的优化措施包括：<strong>优化主从节点之间的网络环境</strong>（如同机房部署）；监控主从节点延迟（通过 offset ）判断，若从节点延迟较大，通知应用不再通过该从节点读取数据；<strong>使用集群同时扩展写负载和读负载等。</strong></p>
</li>
</ul>
<p>在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点连接时等。<strong>从节点的 slave-serve-stale-data 参数便与此有关：</strong>它控制这种情况下从节点的表现；如果为 yes (默认值)，则从节点仍然能够响应客户端的命令，如果为 no，则从节点只能响应 info\slaveof 等少数命令。<strong>若对数据一致性要求很高，则应设置为 no</strong></p>
<ul>
<li><p>数据过期问题</p>
<p>在单机版 Redis 中，存在两种删除策略：</p>
<ul>
<li>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，若过期则删除。</li>
<li>定期删除：服务器指定定时任务删除过期数据，但是考虑到内存和 CPU （删除会释放内存，但是频繁删除操作对 CPU 不太友好），该删除的频率和执行时间都受到了限制。</li>
</ul>
<p>对于定期删除而言，Redis 每秒 10 次：</p>
<ul>
<li>测试随机的 20 个 keys 进行相关过期检测</li>
<li>删除所有已经过期的 keys</li>
<li>如果有多于 25% 的 keys 过期，重复步骤 1.</li>
</ul>
<p>当不断进行重复时，知道过期的 keys 的百分比低于25%，在任何给定的时刻，最多会清除 1/4 的过期 keys。</p>
</li>
</ul>
<p>参考：</p>
<p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html</a></p>
<p><a href="http://www.redis.cn/topics/replication.html">http://www.redis.cn/topics/replication.html</a></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 高可用方案</title>
    <url>/posts/7c68620a/</url>
    <content><![CDATA[<h1 id="Redis-高可用方案"><a href="#Redis-高可用方案" class="headerlink" title="Redis 高可用方案"></a>Redis 高可用方案</h1><p>Redis 高可用方式主要有以下四种：</p>
<ul>
<li><strong>数据持久化</strong></li>
<li><strong>主从数据同步（主从复制）</strong></li>
<li><strong>Redis 哨兵模式 (Sentinel)</strong></li>
<li><strong>Redis 集群（Cluster）</strong></li>
</ul>
<p>数据持久化保证系统在发生宕机或者重启之后数据不会丢失，增加了系统的可靠性和减少了系统不可用的时间（省去了手动恢复数据的过程）；<br>主从数据同步可以将数据存储至多台服务器，这样当遇到一台服务器宕机之后，可以很快地切换到另一台服务器以继续提供服务；<br>哨兵模式发生故障之后自动切换主服务器；<br>Redis 集群提供多主多从的 Redis 分布式集群环境，用于提供性能更好的 Redis 服务，并且它自身拥有故障自动切换的能力。</p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis 4.0 之前数据持久化方式有两种：<strong>AOF 方式和 RDB 方式。</strong></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB (Redis Database, 快照方式) 按照<code>一定的时间周期</code> 策略把内存的数据以<code>快照(snapshot)</code>的方式保存到硬盘的二进制文件中。<br>即：snapshot 快照存储，对应产生数据文件为 <code>dump.db</code>，通过配置文件中的 <code>save</code> 参数来定义快照的周期。<br>核心函数：<code>rdbSave</code>(生成 RDB 文件) 和 <code>rdbLoad</code>（从文件加载内存）两个函数。</p>
<p><strong>优点：是以二进制存储的，占用空间更小、数据存储更紧凑，并且与 AOF 相比，RDB 具备更快的重启恢复能力。</strong></p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF 是 (append only file) 的缩写。Redis 会将每一个收到的写命令都通过 <code>Write</code> 函数追加到文件最后，类似于 MySQL 的 binlog.<br>当 Redis 重启时，就会从 <code>appendlonly.aof</code> 中加载命令来重建整个 Redis 数据库。<br>每当执行服务器函数或函数时，<code>flushAppendOnlyFile</code> 函数都会被调用，这个函数执行两个工作：</p>
<ul>
<li>WRITE<br>根据条件，将 <code>aof_buf</code> 中的缓存写入 AOF 文件中；</li>
<li>SAVE<br>根据条件，调用 <code>fsync</code> 或 <code>fdatasync</code> 函数，将 AOF 文件保存到磁盘中</li>
</ul>
<p>总结：</p>
<ul>
<li>RDB 占用空间更小、占用空间小，具备更快的重启恢复能力。</li>
<li>AOF 存储频率更高，数据丢失的风险越低，招用空间大，重启速度较慢。</li>
<li>也可以使用混合持久化功能，通过<code>config get aof-use-rdb-preamble</code> 的命令来查询 Redis 混合持久化的功能是否开启。</li>
</ul>
<h2 id="Redis-主从同步"><a href="#Redis-主从同步" class="headerlink" title="Redis 主从同步"></a>Redis 主从同步</h2><p>在 Redis 集群环境中，对于主机器和从机器数据一致的操作，就需要主从同步，也叫 application，来同步主节点的数据。</p>
<p>Redis 主从同步分为：<strong>主从模式</strong> 和 <strong>从从模式</strong></p>
<h3 id="主从复制的三种机制"><a href="#主从复制的三种机制" class="headerlink" title="主从复制的三种机制"></a>主从复制的三种机制</h3><ul>
<li><ol>
<li>主从节点连接正常时，主设备会发送一连串的数据流来保持对 <code>slave</code> 的更新：包括客户端的写入，key 的过期或被逐出等待。</li>
</ol>
</li>
<li><ol start="2">
<li>当 master 和 slave 之间的连接断开之后（网络原因、连接超时等），slave 重新连接 master 会尝试进行部分重同步：<strong>尝试获取在断开连接期间丢失的命令流</strong></li>
</ol>
</li>
<li><ol start="3">
<li>当第二步中无法进行部分重同步，<strong>slave 会进行全量同步</strong></li>
</ol>
</li>
</ul>
<p>Redis 使用的默认是<strong>异步复制</strong>，其特点是<code>低延迟</code>和<code>高性能</code>。</p>
<h2 id="Redis-哨兵模式"><a href="#Redis-哨兵模式" class="headerlink" title="Redis 哨兵模式"></a>Redis 哨兵模式</h2><p>Redis 哨兵模式是用来监视 Redis 主从服务器的，当 Redis 的主从服务器发生故障之后，Redis 哨兵提供了自动容灾修复的功能。<br>Redis 哨兵模块存储在 Redis 的 src/redis-sentinel 目录。我们可以使用命令<code>./src/redis-sentinel sentinel.conf</code> 来启动哨兵功能。</p>
<p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：<strong>Redis Sentinel 集群</strong>和 <strong>Redis 数据集群</strong>。</p>
<p>其中 Redis Sentinel 集群是由若干个 Sentinel 节点组成的分布式集群，可以实现</p>
<ul>
<li><strong>故障发现</strong></li>
<li><strong>故障自动转移</strong></li>
<li><strong>配置中心</strong></li>
<li><strong>客户端通知</strong></li>
</ul>
<p>Redis Sentinel 的节点数量要满足 <code>2n+1</code> 的奇数个。<br>哨兵的工作主要是：</p>
<ul>
<li>监控</li>
<li>故障检测</li>
<li>故障转移</li>
<li>sentinel leader</li>
<li>master 重选</li>
</ul>
<h3 id="哨兵（Sentinel）工作方式"><a href="#哨兵（Sentinel）工作方式" class="headerlink" title="哨兵（Sentinel）工作方式"></a>哨兵（Sentinel）工作方式</h3><ul>
<li><ol>
<li>每个 Sentinel 以每秒钟一次的频率向它管理的 master, slave 以及其他 Sentinel 实例发送一个 PING 命令。</li>
</ol>
</li>
<li><ol start="2">
<li>如果一个节点距离最后一次有效回复 PING 命令的时间超过 <code>own-after-milliseconds</code> 选项所指定的值，则这个实例会被<code>Sentinel</code>标记为主观下线。</li>
</ol>
</li>
<li><ol start="3">
<li>若一个 master 节点被标记为主观下线，则正在监视这个 master 的所有 Sentinel 要以每秒一次的频率确认 master 是否进入了主观下线的状态</li>
</ol>
</li>
<li><ol start="4">
<li>当有足够数量的 Sentinel (大于等于配置文件指定的值) 在指定的时间范围内确认 master 的确进入了主观下线状态，则 master 会被标记为客观下线。</li>
</ol>
</li>
<li><ol start="5">
<li>在一般情况下，每个 Sentinel 会以 10 s 一次的频率向它已知的所有 master, slave 发送 INFO 命令。</li>
</ol>
</li>
<li><ol start="6">
<li>当 master 被 Sentinel 标记为客观下线时，sentinel 向下线的 master 的所有 slave 发送 INFO 命令的频率会从 10s/次改为 1s/次</li>
</ol>
</li>
</ul>
<h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><ul>
<li>主观下线(Subjective Down, SDOWN): 是指一个哨兵通过检测发现某个主节点发生故障的一种状态。</li>
<li>客观下线(Objective Down, ODOWN): 是指哨兵检测到某个主节点发生故障，通过命令 SENTINEL <code>is-master-down-by-addr</code> 与其他哨兵节点协商，并且在指定时间内接收到指定数量的其他哨兵的确认反馈时的一种状态。</li>
</ul>
<p><strong>主观下线表示哨兵通过检测发现节点宕机，客观下线表示哨兵不但自己认为该节点宕机，而且该哨兵与其他节点沟通后，达到一定数量的哨兵都认为节点宕机了。</strong></p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>Sentinel 判定主节点客观宕机（ODOWN）后，将进入故障转移过程。</p>
<p>进入故障转移的前提是：<strong>主节点为客观宕机状态</strong>，当前<strong>没有故障转移在执行、上次故障转移已经超时</strong>。Sentinel 确认可以执行故障转移后，会进行以下几项准备工作：</p>
<ul>
<li>故障转移等待开始；<br>设置 failover_state: SENTINEL_FAILOVER_STATE_WAIT_START </li>
<li>主节点处于故障转移过程中<br>设置当前主节点标识位：SRI_FAILOVER_IN_PROGRESS （主节点处于故障转移过程中）</li>
<li>记录故障转移开始时间以及 failover_state 状态修改时间；</li>
</ul>
<h4 id="Sentinel-故障转移-Leader-选举"><a href="#Sentinel-故障转移-Leader-选举" class="headerlink" title="Sentinel 故障转移 Leader 选举"></a>Sentinel 故障转移 Leader 选举</h4><p><strong>当一个主节点被判断为客观下线时，监控这个主节点的所有 Sentinel 会进行协商，选举一个 Leader 对下线的主节点执行故障转移操作。</strong><br>Sentinel 需要在集群内进行”拉票”，”拉票” 的依据就是配置 quorum 以及 “拉票”的时间。</p>
<ul>
<li><strong>配置 quorum 越大，优先级越高；</strong></li>
<li><strong>“拉票” 请求时间越早，优先级越高；</strong></li>
</ul>
<p>“投票”完成后就到了”唱票”环节，该过程是在 <code>SENTINEL_FAILOVER_STATE_WAIT_START</code> 状态下执行的。</p>
<p>Redis 使用了 Raft 算法实现领导者选举，大体思路：</p>
<ul>
<li>每个在线的 Sentinel 节点都有资格成为 Leader, 每个 Sentinel 节点发现当它确认主节点客观下线检查的时候，会向其他 Sentinel 节点发送<br><code>sentinel is-master-down-by-addr</code> 命令，要求将自己设置为<code>leader</code></li>
<li>每个节点在每个选举轮次中只有一次投票权，接收到命令的 Sentinel 节点，如果没有同意过其他 Sentinel 节点的 <code>sentinel is-master-down-by-addr</code> 命令，<br>将同意该请求，否则拒绝</li>
<li>如果该 Sentinel 节点发现自己的票数已经大于等于 max (quorum, num(sentinels)/ 2 + 1),那么它将成为领导者。其他的投票就会终止，即使后续还有其他的哨兵节点到达配置，也没有作用</li>
<li>如果此过程中没有产生领导者，暂停一段时间，再进行下一轮选举，current_epoch 加 1<br>合理部署 Sentinel 的节点的个数，以及配置 sentinel 选举的法定人数<ol>
<li>sentinel 节点个数最好 &gt;= 3.</li>
<li>sentinel 节点个数最好是奇数.</li>
<li>sentinel 的选举法定人数设置为 （n/2 + 1）</li>
</ol>
</li>
</ul>
<p>配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sentinel.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>quorum</code> 是<strong>法定人数</strong>。作用：多个 sentinel 进行相互选举，有超过<strong>法定人数</strong>的 sentinel 选举某个 sentinel 为 leader,那么他就成为 leader,<br>leader 负责故障转移。这个法定人数，一般配置为 （n/2 + 1）较为合理</p>
<h4 id="新主节点的选举"><a href="#新主节点的选举" class="headerlink" title="新主节点的选举"></a>新主节点的选举</h4><p><strong>当主节点客观下线时，Sentinel Leader 会从该主节点存活的从节点中选出一个新的主节点。</strong><br>首先，过滤掉相关从节点：</p>
<ul>
<li>主观下线的或者处于断线状态的从节点；</li>
<li>最近 5s 内未回复过 Sentinel Leader INFO 命令的从节点；</li>
<li>从节点的优先级为 0 的从节点，由配置项 replica-priority 决定；</li>
<li>与主节点断开连接超过 10 倍 <code>down-after-milliseconds</code> 的从节点；</li>
</ul>
<p>当 Sentinel 集群选举出 Sentinel Leader 后，由 Sentinel Leader 从 redis 从节点中选择一个 redis 节点作为主节点：</p>
<ul>
<li><ol>
<li>过滤故障的节点</li>
</ol>
</li>
<li><ol start="2">
<li>选择优先级 <code>slave-priority</code> 最大的从节点作为主节点，如不存在则继续</li>
</ol>
</li>
<li><ol start="3">
<li>选择复制偏移量最大的从节点作为主节点，如不存在则继续</li>
</ol>
</li>
<li><ol start="4">
<li>选择 runid（redis 每次启动的时候生成随机的 runid 作为 redis 的标识）最小的从节点作为主节点</li>
</ol>
</li>
</ul>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p>Redis 集群是 Redis 3.0 版本推出的 Redis 集群方案，将数据分布在不同的主服务器上，以此来降低系统对单主节点的依赖，并且可以大大提高 Redis 服务的读写性能。</p>
<p>Redis 集群除了拥有主从模式 + 哨兵模式的所有功能之外，还提供了多个主从节点的集群功能，实现了真正意义上的分布式集群服务。<br>Redis 集群可以实现数据分片服务，也就是说在 Redis 集群中有 16384 个槽位来存储所有的数据，当我们有 N 个主节点时，可以把 16384 个槽位平均分配到 N 台主服务器上。<br>当有 key-value 存储时，Redis 会使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384进行取模来得到具体槽位，再把此值存储在对应的服务器上，读取操作也是同样的道理，这样我们就实现了数据分片的功能。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie &amp;&amp; Session &amp;&amp; JWT 使用总结</title>
    <url>/posts/ea9b1fcc/</url>
    <content><![CDATA[<h1 id="认证-授权-凭证"><a href="#认证-授权-凭证" class="headerlink" title="认证-授权-凭证"></a>认证-授权-凭证</h1><h2 id="什么是认证"><a href="#什么是认证" class="headerlink" title="什么是认证"></a>什么是认证</h2><p><strong>认证就是验证当前用户的身份</strong>：<br>互联网中的认证：</p>
<ul>
<li>用户名密码登陆</li>
<li>邮箱发送登陆连接验证</li>
<li>手机号接收验证码</li>
</ul>
<h2 id="什么是授权"><a href="#什么是授权" class="headerlink" title="什么是授权"></a>什么是授权</h2><p>用户授权第三方应用访问该用户某些资源的权限</p>
<ul>
<li>你在安装手机应用的时候，APP 会询问是否允许授予权限（地址获取，存储权限获取）</li>
<li>微信访问小程序时，登陆时，小程序会询问是否允许授予权限</li>
<li>实现授权的方式：cookie、session、token、OAuth</li>
</ul>
<h2 id="什么是凭证-Credentials"><a href="#什么是凭证-Credentials" class="headerlink" title="什么是凭证(Credentials)"></a>什么是凭证(Credentials)</h2><p>实现认证和授权的前提是需要一种<strong>媒介（证书）</strong>来标记访问者身份</p>
<p>在互联网应用中一般网站（如掘金）会有两种模式，游客模式和登陆模式。游客模式中，可以正常浏览网站上面的文章，但是一旦想要点赞/收藏/分享文章，就需要登陆或者注册账号。<br>当用户登陆成功后，服务器会给该用户使用的浏览器颁发一个令牌（token）,这个林牌用来表明你的身份，每次浏览器发送请求时就会带上这个令牌，就可以使用游客模式下无法使用的功能。</p>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><ul>
<li><p><strong>HTTP 是无状态的协议</strong>（对于网络请求没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是独立的，服务端无法确认当前访问者的身份信息。<br>所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后端前后两个请求是否来自同一浏览器。而这个状态通过 cookie 或者 session 去实现。</p>
</li>
<li><p><strong>cookie 存储在客户端</strong>：cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p>
</li>
<li><p><strong>cookie 是不可跨域的</strong>：每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</p>
</li>
</ul>
<p>cookie 常用的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name=value</td>
<td>key-value,设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong><br />- 如果值为 Unicode 字符，需要为字符编码<br />- 如果值为二进制数据，则需要使用 BASE64 编码</td>
</tr>
<tr>
<td>domain</td>
<td>指定 cookie 所属域名，默认是当前域名</td>
</tr>
<tr>
<td>path</td>
<td><strong>指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘</strong><br />如果设置为 <code>/abc</code>，则只有 <code>/abc</code>下的路由可以访问到该 cookie，如：<code>abc/read</code></td>
</tr>
<tr>
<td>maxAge</td>
<td>cookie 失效时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie。如果为 0 ,表示删除该 cookie。默认为 -1。</td>
</tr>
<tr>
<td>expires</td>
<td>过期时间，在设置的某个时间点后该 cookie 就会失效。<br />一般浏览器的 cookie 都是默认存储的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除。</td>
</tr>
<tr>
<td>secure</td>
<td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 False</td>
</tr>
<tr>
<td>httpOnly</td>
<td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie,所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td>
</tr>
</tbody></table>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><ul>
<li>session 是另一种记录服务器和客户端<strong>会话状态</strong>的机制</li>
<li>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储在客户端的 cookie 中</li>
</ul>
<p><img src="/images/session.png" alt="direct"></p>
<h2 id="session-认证流程"><a href="#session-认证流程" class="headerlink" title="session 认证流程"></a>session 认证流程</h2><ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息发送给客户端，服务端会从 Cookie 中获取 SessionID, 再根据 SessionID 查找对应的 Session 信息，如果没有找到说民用户没有登陆或者登陆失败，如果找到 Session 证明用户已经登陆可执行后面操作。</li>
</ul>
<p><strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登陆状态</p>
<h1 id="Cookie-和-Session-区别"><a href="#Cookie-和-Session-区别" class="headerlink" title="Cookie 和 Session 区别"></a>Cookie 和 Session 区别</h1><ul>
<li><strong>安全性</strong>：Session 比 Cookie 安全，Session 是<strong>存储在服务器端</strong>的，Cookie 是<strong>存储在客户端</strong>的。</li>
<li><strong>存取值的类型不同</strong>：Cookie 只支持存<strong>字符串</strong>数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型</li>
<li><strong>有效性不同</strong>：Cookie 可设置长时间保持，比如我们经常使用默认登陆功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效</li>
<li><strong>存储大小不同</strong>：单个 Cookie 保存的<strong>数据不能超过 4K</strong>，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li>
</ul>
<h1 id="Token-（令牌）"><a href="#Token-（令牌）" class="headerlink" title="Token （令牌）"></a>Token （令牌）</h1><h2 id="Acess-Token"><a href="#Acess-Token" class="headerlink" title="Acess Token"></a>Acess Token</h2><ul>
<li>访问资源接口（API）时所需要的资源凭证</li>
<li>简单 token 的组成：<code>uid(用户唯一的身份标识)</code>、<code>time(当前时间的时间戳)</code>、<code>sign</code>(签名，token 的前几位以哈希算法压缩成一定长度的十六进制字符串)</li>
<li>特点：<ul>
<li><strong>服务端无状态化、可扩展性好</strong></li>
<li><strong>支持移动端设备</strong></li>
<li>安全</li>
<li>支持跨程序调用</li>
</ul>
</li>
</ul>
<h3 id="tocken-的身份验证流程："><a href="#tocken-的身份验证流程：" class="headerlink" title="tocken 的身份验证流程："></a>tocken 的身份验证流程：</h3><p><img src="/images/token_verify.png" alt="direct"></p>
<ul>
<li><ol>
<li>客户端使用用户名跟密码请求登陆</li>
</ol>
</li>
<li><ol start="2">
<li>服务端收到请求，去验证用户端与密码</li>
</ol>
</li>
<li><ol start="3">
<li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li>
</ol>
</li>
<li><ol start="4">
<li>客户端收到 token 后，会把它存储起来，比如放在 <code>cookie</code> 或者 <code>localStorage</code> 里</li>
</ol>
</li>
<li><ol start="5">
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li>
</ol>
</li>
<li><ol start="6">
<li>服务端收到请求，然后去验证客户端请求里面带着的 token，如果验证成功，就向客户端返回请求的数据</li>
</ol>
</li>
</ul>
<p>特点：</p>
<ul>
<li><strong>每一次请求都需要携带 token,需要把 token 放在 HTTP 的 Header 里</strong></li>
<li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不同存放 token 数据。用解析 token 的计算方式换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li>
<li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li>
</ul>
<h2 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h2><p><img src="/images/refresh_token.png" alt="direct"></p>
<ul>
<li>refresh token 是专门用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登陆用户名和密码，比较麻烦。有了 refresh token，就可以减少这个麻烦，<br>客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</li>
</ul>
<h2 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h2><ul>
<li>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。</strong></li>
<li>Token 是<strong>令牌</strong>，**访问资源接口（API）时所需要的资源凭证。Token <strong>使服务端无状态化，不会存储会话信息</strong></li>
<li>作为身份验证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。</li>
<li>所谓的 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂时认为是安全的。而 Token，如果指的是 OAuth Token 或类似机制的话，提供的是认证和授权，认证是针对用户，授权是指的 App。其目的是让某 App 有权利访问某用户的信息。<br>这里的 <strong>Token 是唯一的</strong>（每个项目的 secret 还是相关信息不同）。不可以转移到其他 App 上，也不可以转到其他用户上。</li>
<li>Session 只是提供一种简单的认证，即只要有此 SessionID,即认为有此 User 的全部权限。是需要严格保密的，这个数据只是保存在服务器上，不应该共享给其他往后在哪或者第三方 App。<br>所以简单来说：<ul>
<li><strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token。若永远只是自己的 website 则可以用 Seesion</strong>。</li>
</ul>
</li>
</ul>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><ul>
<li>Json Web Token 是目前前后端分离的<strong>跨域认证</strong>解决方案</li>
<li>是一种<strong>认证授权</strong>机制</li>
<li>基于 JSON 的开放标准（RFC 7519）</li>
<li>使用 HMAC 算法或者是 RSA 的公/私密钥对 JWT 进行签名。<br><img src="/images/JWT.png" alt="direct"></li>
</ul>
<p>这里参考：<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p>
<p>用户认证流程：</p>
<ul>
<li>客户端使用用户名和密码来请求服务器进行登陆</li>
<li>服务器进行用户名和密码的验证</li>
<li>通过验证，服务器生成一个 token 并返回给浏览器</li>
<li>客户端存储 token,存储位置为 header/localstorge/url?token=xxxxx 的方式</li>
<li>服务端验证 token 值，并返回相应的响应</li>
</ul>
<h2 id="JWT-token-数据组成格式"><a href="#JWT-token-数据组成格式" class="headerlink" title="JWT token 数据组成格式"></a>JWT token 数据组成格式</h2><p>JWT token 是一个字符串，由三部分组成，用 . 隔开</p>
<ul>
<li>头部（header）</li>
<li>载荷（payload）</li>
<li>签名（signature）</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Generate JWT token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateJwtToken</span><span class="params">(username, password <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	nowTime := time.Now()</span><br><span class="line">	expireTime := nowTime.Add(<span class="number">2</span> * time.Hour)</span><br><span class="line"></span><br><span class="line">	claims := Claims&#123;</span><br><span class="line">	    <span class="comment">// header</span></span><br><span class="line">		username,</span><br><span class="line">		password,</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// payload</span></span><br><span class="line">		jwt.StandardClaims&#123;</span><br><span class="line">			ExpiresAt: expireTime.Unix(),</span><br><span class="line">			Issuer:    PROJECTISSUE,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signature</span></span><br><span class="line">	tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">	</span><br><span class="line">	token, err := tokenClaims.SignedString(projectSecret)</span><br><span class="line">	<span class="keyword">return</span> token, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基于-Gin-的-JWT-实现"><a href="#基于-Gin-的-JWT-实现" class="headerlink" title="基于 Gin 的 JWT 实现"></a>基于 Gin 的 JWT 实现</h2><p>代码地址：<a href="https://github.com/tyronemaxi/Jwt-practice">https://github.com/tyronemaxi/Jwt-practice</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 与容器技术畅谈</title>
    <url>/posts/bc91ee72/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>2018 年可以说是 <strong>docker 容器技术</strong> 最火热的一年，各大厂商，互联网公司都开始构建自己的容器化平台，CI/CD 工具<br>那么为什么 <strong>docker 会这么火</strong>，以及 **docker 技术内涵是什么?**，这篇文章，我将以一个学习者的身份详细解析 docker 容器化技术</p>
</blockquote>
<h1 id="为什么选择-docker"><a href="#为什么选择-docker" class="headerlink" title="为什么选择 docker"></a>为什么选择 docker</h1><p>在容器化时代到来之前，<code>AWS</code> 以及 <code>OpenStack</code> 可谓盛极一时，与此同时还有以 <code>Cloud Foundry</code> 为代表的开源 <code>PaaS</code> 项目。</p>
<p>PaaS 开源项目火热的主要原因主要是它提供了一种<strong>应用托管</strong> 的能力。各个国内外技术厂商都在进行<strong>上云</strong>体验。<br>具体的操作就是：<code>Cloud Foundry</code> 为每种主流编程语言都定义了一种打包格式，类似 <code>cf push app</code> 的操作就是将 app 的可执行文件和启动命令<br>打包进一个压缩包中，上传到 Cloud Foundry 的存储中。然后 Cloud Foundry 会通过调度器选择一个可以运行这个应用的<code>虚拟机</code>，然后通过这个机器上的 agent 将应用压缩包下载下来启动。</p>
<p>对于一个虚拟机来说，需要在其上启动很多个来自不同用户的应用，Cloud Foundry 会调用操作系统 <code>Cgroups</code> 和 <code>Namespace</code> 机制为每个应用单独创建一个<br>称作<code>沙盒</code>的隔离环境，然后在<code>沙盒</code>环境中启动这些应用，这样就形成了一个个隔离的环境运行多个应用。</p>
<p>以上就是 <strong>PaaS 项目的核心的功能，也就是容器化技术</strong>。</p>
<p>也正是和 docker 项目相同的技术核心，通过 <code>Cgroups</code> 和 <code>Namespace</code>来构建一个资源和边界，实现沙盒环境。</p>
<p>那么为什么 docker 技术为何在短短几个月就风靡全世界了？</p>
<ul>
<li><strong>实则正是 <code>docker image</code></strong></li>
</ul>
<p>对于 Paas 项目而言，将项目运行的文件打包是一件极其麻烦的事情，对于每种语言，每种框架，每个版本都需要维护一个打好的包。</p>
<p><strong>docker image 可以基于你所需要的系统文件，构建一个可以基于云端环境运行的压缩包。</strong></p>
<h2 id="容器化技术的发展"><a href="#容器化技术的发展" class="headerlink" title="容器化技术的发展"></a>容器化技术的发展</h2><p>在以上的文章中，介绍了 docker 技术为何火热的原因。<br>对于一个大型的业务应用来说，从前端，后端，到数据库系统，文件系统等，往往是需要多个容器的，那么就存在着，如何能够优雅的在云端环境有序地运行。<br>于是，docker 公司便开发出了一个<code>容器编排化的工具</code>, <strong>docker Swarm</strong> 项目</p>
<p>与此同时，Mesos 社区也开发出了一个类似的工具<code>Marathon</code>, 它虽然不能像 Swarm 那样提供原生的 Docker API, 但是其却拥有一个独特的核心竞争力：</p>
<ul>
<li><strong>超大规模集群的管理经验</strong></li>
</ul>
<p>也就在这个时候，google 公司根据公司多年的发展经验和借助成熟的内部项目<code>Borg</code>系统，宣布了 <code>Kubernetes</code> 项目的诞生。<br>而也是仅仅在两年之前，各个国内外的互联网厂商开始将自己的项目接入 k8s，宣布了 k8s 时代的到来。</p>
<p>本文仅仅讨论 <code>docker 容器化技术</code>，对于<code>容器化编排</code>不做过多的介绍。</p>
<h1 id="容器到底是怎么一回事？"><a href="#容器到底是怎么一回事？" class="headerlink" title="容器到底是怎么一回事？"></a>容器到底是怎么一回事？</h1><p>在上述的文章中，已经简单介绍了几个概念:</p>
<ul>
<li><code>虚拟器</code></li>
<li><code>容器</code></li>
<li><code>容器化技术</code></li>
<li><code>镜像</code></li>
</ul>
<p>我们可以总结一下：<strong>容器其实就是一种沙盒技术，使用 <code>Cgroups</code>和<code>Namespace</code> 技术，将你的应用通过限制和隔离的技术在指定的环境中，良好的运行起来</strong></p>
<p>先说结论，容器其实就是一种<code>特殊的进程</code>而已</p>
<h2 id="隔离技术-Namespace"><a href="#隔离技术-Namespace" class="headerlink" title="隔离技术 - Namespace"></a>隔离技术 - Namespace</h2><blockquote>
<p>那么隔离技术是如何实现的？</p>
</blockquote>
<p>首先创建一个容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name=ubuntu-test ubuntu:18.04 /bin/sh</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 sh</span><br><span class="line">    7 pts/0    00:00:00 ps</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到这个容器中，一共有两个进程，通过 ps 可以看到 sh ,就是这个容器内部的第 1 号进程（PID=1）。</p>
<p>这是为什么呢？</p>
<p>本来，当我们在宿主机上运行了一个 /bin/sh 程序的时候，我们的操作系统都会给其分配一个进程编号，例如 PID=100。但是通过 <code>docker run</code> 命令时，docker<br>就会在当前的进程时，调整其 namespace 相关参数，将其变为在这个 docker 中的 1 号进程。</p>
<p>这种技术就是<strong>Linux 里面的 Namespace 机制</strong>。</p>
<p>我们知道，在 Linux 系统中创建进程的系统调用是 clone():</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">int pid = clone(main_function, stack_size, SIGCHID, NUll);</span><br></pre></td></tr></table></figure>

<p>通过指定 <code>CLONE_NEWPID</code> 参数，而每个 <code>Namespace</code>里的应用进程，都会认为自己是当前容器里的第一号进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL)</span><br></pre></td></tr></table></figure>

<p>在 Linux 操作系统中，还提供了 <code>Mount</code>、<code>UTS</code>、<code>IPC</code>、<code>Network</code>、<code>User</code> 这些 Namespace，用来对<code>各种不同的进程</code>上下文进行”障眼法”操作。</p>
<h2 id="限制技术-Cgroups"><a href="#限制技术-Cgroups" class="headerlink" title="限制技术 - Cgroups"></a>限制技术 - Cgroups</h2><blockquote>
<p>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等<br>在 Linux 中，Cgroups 给用户暴露出来的操作接口是<strong>文件系统</strong>，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># mount -t cgroup</span></span></span><br><span class="line">cpuset on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cpu on /sys/fs/cgroup/cpu type cgroup (ro,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">cpuacct on /sys/fs/cgroup/cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpuacct)</span><br><span class="line">blkio on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">memory on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">devices on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">freezer on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">net_cls on /sys/fs/cgroup/net_cls type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls)</span><br><span class="line">perf_event on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">net_prio on /sys/fs/cgroup/net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_prio)</span><br><span class="line">hugetlb on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">pids on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">rdma on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma)</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,name=systemd)</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>其中，例如 <code>cpuset</code>、<code>cpu</code>、<code>memory</code> 这样的子目录，也叫子系统。这些都是可以被 <code>Cgroups</code> 进行限制的资源种类。</p>
<p>现在我们看一下子系统中关于 CPU 的相关配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls /sys/fs/cgroup/cpu</span></span><br><span class="line">cgroup.clone_children  cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release</span><br><span class="line">cgroup.procs	       cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat	 tasks</span><br></pre></td></tr></table></figure>
<p>这些输出配置中，可以看到 <code>cpu.cfs_period_us</code> 和 <code>cpu.cfs_quota_us</code>，这两个参数需要组合使用，可以用来限制进程在长度<code>cfs_period</code>的一段时间内，<br>只能被分配到总量为 <code>cfs_quota</code> 的 CPU 时间。</p>
<p>另开一个终端，输入:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while : ; do : ; done &amp;</span><br><span class="line"></span><br><span class="line">23223</span><br></pre></td></tr></table></figure>
<p>键入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu0 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span></span><br></pre></td></tr></table></figure>
<p>可以看到 CPU 的使用率已经 100% 了， quota 还没有任何限制（-1）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span> </span><br><span class="line">-1</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us</span> </span><br><span class="line">100000</span><br></pre></td></tr></table></figure>
<p>在现在的默认配置中，在 100 ms 中的 cpu 时间中，使用 100ms 的 CPU 时间，也就是 100 %。<br>现在调整为 20%:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 20000 &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span></span><br></pre></td></tr></table></figure>
<p>然后将限制的进程 PID 写入 container 组里的 tasks 文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 23223 &gt; /sys/fs/cgroup/cpu/container/tasks</span> </span><br></pre></td></tr></table></figure>
<p>然后使用 <code>top</code> 指令查看:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">Cpu0 : 20.3 us, 0.0 sy, 0.0 ni, 79.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span></span><br></pre></td></tr></table></figure>
<p>现在可以看到已经为 <code>20%</code> 左右了<br>其他关于 <code>blkio</code>，<code>cpuset</code>，<code>memory</code> 可以自行尝试</p>
<h3 id="docker-运行时的限制参数"><a href="#docker-运行时的限制参数" class="headerlink" title="docker 运行时的限制参数"></a>docker 运行时的限制参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu:18.04 /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>这个配置就会将对应的值写入到 docker-container 的配置文件中，这个 Docker 容器，只能使用到 20% 的 CPU 带宽。</p>
<h3 id="虚拟机和容器对比"><a href="#虚拟机和容器对比" class="headerlink" title="虚拟机和容器对比"></a>虚拟机和容器对比</h3><img src="/images/虚拟机和容器对比图.png" width = "500" height = "300" alt="" align=center />

<p>虚拟机的工作原理，通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，例如 CPU、内存、I/O 设备等等。<br>docker 项目帮助用户启动的，还是原来的应用进程，但是 Docker 会为它们加上了各种各样的 Namespace 参数。</p>
<p>所以，”敏捷” 和 “高性能” 是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细粒度的资源管理平台上大行其道的重要原因。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 docker 镜像</title>
    <url>/posts/c5abce98/</url>
    <content><![CDATA[<h1 id="docker-image-是什么？"><a href="#docker-image-是什么？" class="headerlink" title="docker image 是什么？"></a>docker image 是什么？</h1><blockquote>
<p>镜像（Image）就是一堆只读层（read-only layer）的统一视角。</p>
</blockquote>
<h2 id="容器和镜像的关系"><a href="#容器和镜像的关系" class="headerlink" title="容器和镜像的关系"></a>容器和镜像的关系</h2><p>一张图可以带你理解:<br><img src="/images/image_and_container.png" width = "350" height = "200" alt="" align=center /></p>
<p>container = image + 读写层</p>
<h2 id="Docker-项目的核心原理"><a href="#Docker-项目的核心原理" class="headerlink" title="Docker 项目的核心原理"></a>Docker 项目的核心原理</h2><blockquote>
<p>对于 Dcoker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p>
</blockquote>
<ul>
<li><ol>
<li>启动 Linux Namespace 配置</li>
</ol>
</li>
<li><ol start="2">
<li>设置指定的 Cgroups 参数</li>
</ol>
</li>
<li><ol start="3">
<li>切换进程的根目录（Change Root）</li>
</ol>
</li>
</ul>
<p>对于该进程的根目录而言，对应的技术就是<code>rootfs</code></p>
<p><strong>rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动才会加载指定版本的内核镜像</strong></p>
<p>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：这些操作和依赖的对象，都是宿主机操作系统的内核。</p>
<h2 id="image-一致性"><a href="#image-一致性" class="headerlink" title="image 一致性"></a>image 一致性</h2><p>所谓 镜像的一致性指的就是 <strong>rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，服务所需要的所有依赖，都被封装在了一起</strong>。</p>
<h2 id="image-设计"><a href="#image-设计" class="headerlink" title="image 设计"></a>image 设计</h2><blockquote>
<p>Docker 在镜像的设计中，引入了层（layer）的概念。用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p>
</blockquote>
<p>这个设计的技术主要是用到了一种叫做<code>联合文件系统(Union File System)</code> 的能力<br>主要的功能就是将多个不同位置的目录联合挂载（union mount）到同一目录下。</p>
<h2 id="docker-image-中的-layer"><a href="#docker-image-中的-layer" class="headerlink" title="docker image 中的 layer"></a>docker image 中的 layer</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image inspect ubuntu:latest</span></span><br><span class="line">...</span><br><span class="line">     &quot;RootFS&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">      &quot;Layers&quot;: [</span><br><span class="line">        &quot;sha256:f49017d4d5ce9c0f544c...&quot;,</span><br><span class="line">        &quot;sha256:8f2b771487e9d6354080...&quot;,</span><br><span class="line">        &quot;sha256:ccd4d61916aaa2159429...&quot;,</span><br><span class="line">        &quot;sha256:c01d74f99de40e097c73...&quot;,</span><br><span class="line">        &quot;sha256:268a067217b5fe78e000...&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<img src="/images/image_layer.png" width = "600" height = "400" alt="" align=center />

<ul>
<li><p>只读层<br>它是容器的 rootfs 最下面的五层，对应正是 image 镜像的 5 层。他们的挂载方式只能是只读的（ro+wh, 即 readonly+whiteout）</p>
</li>
<li><p>Init 层<br>它是一个以”-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息</p>
</li>
</ul>
<p>这部分主要是 docker run 命令启动时，用户自定义的一些参数</p>
<ul>
<li>可读写层<br>这一层是容器的 rootfs 最上面的一层，它的挂载方式为：rw, 在没有写入文件之前，这个目录是空的。而一旦在容器中进行了写操作，你修改产生的内容就会以增量的方式出现在这个层中。</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful API 最佳实践</title>
    <url>/posts/ea12054a/</url>
    <content><![CDATA[<h1 id="RESTful-API-最佳实践"><a href="#RESTful-API-最佳实践" class="headerlink" title="RESTful API 最佳实践"></a>RESTful API 最佳实践</h1><img src="https://betimdrenica.files.wordpress.com/2015/03/api2.png?w=300&h=176" alt="api2" style="zoom:100%;" />

<h2 id="API-的关键要求"><a href="#API-的关键要求" class="headerlink" title="API 的关键要求"></a>API 的关键要求</h2><ul>
<li>网络标准的使用</li>
<li>对开发人员友好，并能通过浏览器地址栏进行探索</li>
<li>简单、直观和一致，使用简单且愉快</li>
<li>足够的灵活性</li>
<li>高效的使用</li>
</ul>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><h3 id="Media-Type"><a href="#Media-Type" class="headerlink" title="Media Type"></a>Media Type</h3><p><strong>默认媒体类型为 JSON</strong></p>
<blockquote>
<p>由于 HTTP 的最新势头和遵循标准，JSON 是最受欢迎的，因此应该明确成为默认的媒体类型</p>
<p>XML 的有点是复杂的场景和历史（SOAP），XML 不是 API  的最佳选择。它冗长，难以解析，难以阅读，其数据模型与大多数编程语言的数据模型不兼容。</p>
</blockquote>
<h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><p>RESTful 关键原则是将一系列 API 资源通过 <strong>域名+资源名称 + HTTP methods</strong></p>
<p>逻辑资源应该<strong>从 API 消费者的角度</strong>来进行考虑：<strong>使用有意义的名词s, 而不是动词</strong>，需要明确的是：名词是事物，动词是你对它所做的。</p>
<p>定义资源后，对于每种的资源的不同操作映射为对应的 HTTP 请求方法：</p>
<ul>
<li>GET —— 获取资源信息(SELECT)</li>
<li>POST —— 创建新的资源(CREATE)</li>
<li>PUT —— 更新资源(UPDATE)</li>
<li>PATCH —— 更新部分资源(UPDATE)</li>
<li>DELETE —— 删除部分资源(DELETE)</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /tickets - 检索票证列表</span><br><span class="line">GET /tickets/12 - 检索特定票证</span><br><span class="line">POST /tickets - 创建一个新票</span><br><span class="line">PUT /tickets/12 - 更新票 #12</span><br><span class="line">PATCH /tickets/12 - 部分更新票 #12</span><br><span class="line">DELETE /tickets/12 - 删除票 #12</span><br></pre></td></tr></table></figure>

<p>不适合 CRUD 操作的世界应该怎么办？</p>
<ul>
<li><strong>组合操作使其看起来像资源的字段。</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /template/apply # 应用一个模版</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>将其视为符合 RESTful 原则的子资源。</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /zoos/id/animals # 获取某一个 动物园的 动物</span><br></pre></td></tr></table></figure>

<ul>
<li>无法确定正确的 RESTful 结构的，区别记录即可，无需强制使用。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /search?text=&quot;搜索&quot;</span><br></pre></td></tr></table></figure>

<h2 id="无处不在的-SSL"><a href="#无处不在的-SSL" class="headerlink" title="无处不在的 SSL"></a>无处不在的 SSL</h2><blockquote>
<p>SSL 证书是一个数字证书，用于认证网站的身份并启用加密连接。SSL 代表安全套接字层，这是一个安全协议，可在 Web 服务器和 Web 浏览器之间创建加密链接。</p>
</blockquote>
<p><strong>始终使用 SSL —— 出于安全考虑。</strong></p>
<p>始终使用 SSL 的另外一个优势是有保证的加密通信简化了身份验证工作——您可以使用简单的访问令牌，而不必签署每个 API 请求。</p>
<h2 id="API-接口文档"><a href="#API-接口文档" class="headerlink" title="API 接口文档"></a>API 接口文档</h2><p><strong>API 的好坏取决于它的文档</strong>。这些文档应该很容易找到并且可以公开访问。大多数开发人员在尝试任何集成工作之前都会查看文档。</p>
<p><strong>文档应显示完整请求/响应周期的示例。</strong></p>
<p>一旦你发布了一个公共 API，就应该发布通知信息，告知关注者变更消息。</p>
<p>例如 Apifox、yapi 等接口文档软件</p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p><strong>始终对您的 API 进行版本控制。</strong>版本控制可帮助您更快地迭代并防止无效请求到达更新的端点。它还有助于平滑任何主要的 API 版本转换。</p>
<p>关于 API 版本应包含在 URL 中还是 header 中？有广泛的争论。</p>
<p>本人比较喜欢将版本控制置于 URL 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /api/v1/zoos</span><br></pre></td></tr></table></figure>



<h2 id="结果过滤、排序和搜索"><a href="#结果过滤、排序和搜索" class="headerlink" title="结果过滤、排序和搜索"></a>结果过滤、排序和搜索</h2><p><strong>最好使基本资源 URL 尽可能精简。</strong></p>
<p><strong>复杂的结果过滤器、排序要求和高级搜索（当仅限于单一类型的资源时）都可以作为基本 URL</strong>  </p>
<p><strong>之上的查询参数轻松实现。</strong></p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /tickets?state=open</span><br><span class="line">GET /tickets?order_by=create_time:desc,apply_time:desc</span><br></pre></td></tr></table></figure>

<h2 id="JSON-采用-request-body-输入"><a href="#JSON-采用-request-body-输入" class="headerlink" title="JSON  采用 request body 输入"></a>JSON  采用 request body 输入</h2><ul>
<li>POST</li>
<li>PUT</li>
<li>PATCH</li>
</ul>
<p>上述方法采用 request body 传输数据</p>
<h3 id="字段名称的-snake-case-与-camelCase"><a href="#字段名称的-snake-case-与-camelCase" class="headerlink" title="字段名称的 snake_case 与 camelCase"></a>字段名称的 snake_case 与 camelCase</h3><p>根据 2010 年对 camelCase 和 snake_case （PDF）的眼动追踪研究，**snake_case 比 camelCase 更容易阅读 20%**这种对可读性的影响会影响 API 的可探索性和文档中的示例。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>json 返回数据中，会包含一些分页数据；</p>
<blockquote>
<p>The right way to include pagination details today is using the <a href="https://tools.ietf.org/html/rfc8288">Link header introduced by RFC 8288</a>.</p>
</blockquote>
<p>以下是正确使用 Link 标头的示例，来自 GitHub:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Link: &lt;https://api.github.com/user/repos?page=3&amp;per_page=100&gt;; rel=&quot;next&quot;, &lt;https://api.github.com/user/repos?page=50&amp;per_page=100&gt;; rel=&quot;last&quot;</span><br></pre></td></tr></table></figure>

<p>许多 API 确实需要额外的分页信息，例如可用结果总数的计数。需要发送计数的 API 可以使用自定义 HTTP 标头，如 <code>X-Total-Count</code>。</p>
<h2 id="更新和限制资源应该返回资源表示"><a href="#更新和限制资源应该返回资源表示" class="headerlink" title="更新和限制资源应该返回资源表示"></a>更新和限制资源应该返回资源表示</h2><p>PUT、POST 或 PATCH 调用可能会修改不属于所提供参数的基础资源字段（例如：created_at 或 updated_at 时间戳）。为防止 API 使用者必须再次点击 API 以获得更新的表示，让 API 返回更新（或创建）的表示作为响应的一部分。</p>
<p>如果 POST 导致创建，请使用 HTTP 201 状态码并包含指向新资源 URL 的 Location 标头。</p>
<p>除了将新创建的资源表示作为响应主体之外，还应该包含这两个内容。</p>
<h2 id="默认情况下，不使用-envelope-特殊情况下使用"><a href="#默认情况下，不使用-envelope-特殊情况下使用" class="headerlink" title="默认情况下，不使用 envelope, 特殊情况下使用"></a>默认情况下，不使用 envelope, 特殊情况下使用</h2><p>许多情况下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>：&#123;</span><br><span class="line">  	<span class="attr">&quot;id&quot;</span>: <span class="number">123</span>,</span><br><span class="line">  	<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>包含额外的元数据或分页信息，一些 REST 客户端不允许轻松访问 HTTP 标头，而 JSONP 请求无法访问 HTTP 标头。然而，随着 CORS 和 RFC 5988 等 Link 标头等标准被迅速采用，封装开始变得不必要了。</li>
</ul>
<h2 id="速率限制"><a href="#速率限制" class="headerlink" title="速率限制"></a>速率限制</h2><p>为防止滥用，标准做法是向 API 添加某种速率限制。</p>
<blockquote>
<p>To prevent abuse, it is standard practice to add some sort of rate limiting to an API. <a href="http://tools.ietf.org/html/rfc6585">RFC 6585</a> introduced a HTTP status code <a href="http://tools.ietf.org/html/rfc6585#section-4">429 Too Many Requests</a> to accommodate this.</p>
<p>However, it can be very useful to notify the consumer of their limits before they actually hit it. This is an area that currently lacks standards but has a number of <a href="http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers">popular conventions using HTTP response headers</a>.</p>
<p>At a minimum, include the following headers:</p>
<ul>
<li>X-Rate-Limit-Limit - The number of allowed requests in the current period</li>
<li>X-Rate-Limit-Remaining - The number of remaining requests in the current period</li>
<li>X-Rate-Limit-Reset - The number of seconds left in the current period</li>
</ul>
</blockquote>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>RESTful API 应该是无状态的。</p>
<p>基于 SSL 身份验证凭据可以简化为随机生成的访问令牌，该令牌在 HTTP 基本身份验证的用户名字段中传送。</p>
<ul>
<li>session</li>
<li>jwt</li>
<li>access_token</li>
<li>OAuth 2</li>
</ul>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>HTTP 内置缓存框架</p>
<ul>
<li>ETag</li>
<li>Last-Modified</li>
</ul>
<h2 id="Error-Handler"><a href="#Error-Handler" class="headerlink" title="Error Handler"></a>Error Handler</h2><p>类似 HTML 错误页面向访问者显示有用的错误信息一样，API 应该以已知的可使用格式提供有用的错误信息。错误的表示应该与任何资源的表示没有区别，只是具有自己的一组字段。</p>
<ul>
<li>API 应返回合理的 HTTP 状态代码。</li>
</ul>
<p>API 错误通常分为两种类型：</p>
<ul>
<li>客户端问题的 400 系列状态代码</li>
<li>服务器问题的 500 系列状态代码</li>
</ul>
<p>对于具体的 400 系列和 500 系列状态代码，应带有可使用的 JSON 错误表示。</p>
<p>JSON 错误正文应具有：</p>
<ul>
<li>错误信息</li>
<li>唯一的错误代码</li>
<li>以及可能的详细描述</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;code&quot;</span> : <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span> : <span class="string">&quot;Something bad happened :(&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span> : <span class="string">&quot;More details about the error here&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HTTP-status-codes"><a href="#HTTP-status-codes" class="headerlink" title="HTTP status codes"></a>HTTP status codes</h2><blockquote>
<ul>
<li>200 OK - Response to a successful GET, PUT, PATCH or DELETE. Can also be used for a POST that doesn’t result in a creation.</li>
<li>201 Created - Response to a POST that results in a creation. Should be combined with a <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30">Location header</a> pointing to the location of the new resource</li>
<li>204 No Content - Response to a successful request that won’t be returning a body (like a DELETE request)</li>
<li>304 Not Modified - Used when HTTP caching headers are in play</li>
<li>400 Bad Request - The request is malformed, such as if the body does not parse</li>
<li>401 Unauthorized - When no or invalid authentication details are provided. Also useful to trigger an auth popup if the API is used from a browser</li>
<li>403 Forbidden - When authentication succeeded but authenticated user doesn’t have access to the resource</li>
<li>404 Not Found - When a non-existent resource is requested</li>
<li>405 Method Not Allowed - When an HTTP method is being requested that isn’t allowed for the authenticated user</li>
<li>410 Gone - Indicates that the resource at this end point is no longer available. Useful as a blanket response for old API versions</li>
<li>415 Unsupported Media Type - If incorrect content type was provided as part of the request</li>
<li>422 Unprocessable Entity - Used for validation errors</li>
<li>429 Too Many Requests - When a request is rejected due to rate limiting</li>
</ul>
</blockquote>
<ul>
<li>200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 的响应。也可用于不会导致创建的 POST。</li>
<li>201 已创建- 对导致创建的 POST 的响应。应与指向新资源位置的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30">Location 标头结合</a></li>
<li>204 No Content - 对不会返回正文的成功请求的响应（如 DELETE 请求）</li>
<li>304 Not Modified - 在使用 HTTP 缓存标头时使用</li>
<li>400 Bad Request - 请求格式错误，比如请求体没有解析</li>
<li>401 Unauthorized - 当没有提供或提供无效的身份验证详细信息时。如果从浏览器使用 API，也可用于触发身份验证弹出窗口</li>
<li>403 Forbidden - 当身份验证成功但经过身份验证的用户无权访问资源时</li>
<li>404 Not Found - 当请求不存在的资源时</li>
<li>405 Method Not Allowed - 当请求的 HTTP 方法不允许经过身份验证的用户使用时</li>
<li>410 Gone - 表示此端点的资源不再可用。作为对旧 API 版本的全面响应很有用</li>
<li>415 Unsupported Media Type - 如果作为请求的一部分提供了不正确的内容类型</li>
<li>422 Unprocessable Entity - 用于验证错误</li>
<li>429 Too Many Requests - 当请求由于速率限制而被拒绝时</li>
</ul>
<h2 id="In-Summary"><a href="#In-Summary" class="headerlink" title="In Summary"></a>In Summary</h2><p>API 是开发人员的用户界面。努力确保它不仅功能齐全而且使用起来愉快。</p>
<p>由于开发语言有异，只有最适合的 API 规范，没有最好的 API 规范</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Best Practices for Designing a Pragmatic RESTful API:<a href="https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api</a></p>
<p>Idel restful api : <a href="https://betimdrenica.wordpress.com/2015/03/09/ideal-rest-api-design/">https://betimdrenica.wordpress.com/2015/03/09/ideal-rest-api-design/</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html">https://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 linux 命令</title>
    <url>/posts/92072779/</url>
    <content><![CDATA[<h1 id="linx-面试题"><a href="#linx-面试题" class="headerlink" title="linx 面试题"></a>linx 面试题</h1><p>参考：<a href="https://segmentfault.com/a/1190000040007585">https://segmentfault.com/a/1190000040007585</a><br><a href="https://www.edureka.co/blog/interview-questions/linux-interview-questions-for-beginners/">https://www.edureka.co/blog/interview-questions/linux-interview-questions-for-beginners/</a></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vat vi vim ls mkdir touch cp mv</span><br></pre></td></tr></table></figure>
<p>查找是否存在文件名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure>
<h2 id="日志操作"><a href="#日志操作" class="headerlink" title="日志操作"></a>日志操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f /var/www/data.log.out</span><br></pre></td></tr></table></figure>
<p>抓取关键字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat  data.log.out | grep &quot;error&quot;</span><br><span class="line">grep -i &quot;返回 resp &quot; data.log</span><br></pre></td></tr></table></figure>

<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf filename.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg</span><br></pre></td></tr></table></figure>

<h2 id="查找进程"><a href="#查找进程" class="headerlink" title="查找进程"></a>查找进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep java</span><br></pre></td></tr></table></figure>

<h2 id="系统、内存、磁盘、网络相关"><a href="#系统、内存、磁盘、网络相关" class="headerlink" title="系统、内存、磁盘、网络相关"></a>系统、内存、磁盘、网络相关</h2><p>top 查看内存、cpu 情况<br>du、df 查看磁盘、文件大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -s -h /data</span><br></pre></td></tr></table></figure>
<p>ping、curl 查看网络是否正常</p>
<h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><p>chmod: 修改文件或者目录的权限<br>chown: 即 change owner, 修改文件和目录的所有者权限<br>chattr: chmod 的底层操作，锁定文件<br>例如，你想设置权限，使用户可以读取、写入和执行它，并且你的组的成员可以读取和执行它，而其他人只能读取它<br>chmod u=rwx,g=rx,o=r a  ilename<br>chmod 751 filename<br>绝对模式</p>
<table>
<thead>
<tr>
<th><strong>0</strong></th>
<th>没有权限</th>
<th>– – –</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>执行权限</td>
<td>- - X</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>写权限</td>
<td>– w –</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>执行和写入权限：1（执行）+2（写入）=3</td>
<td>– wx</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>读取权限</td>
<td>r – –</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>读取和执行权限：4（读取）+1（执行）=5</td>
<td>r - x</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>读写权限：4（读）+2（写）=6</td>
<td>rw—— _</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>所有权限：4（读取）+ 2（写入）+ 1（执行）= 7</td>
<td>rwx</td>
</tr>
<tr>
<td><img src="img.png" alt="img.png"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="内存命令"><a href="#内存命令" class="headerlink" title="内存命令"></a>内存命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top </span><br><span class="line">free -h</span><br><span class="line">vmstat</span><br><span class="line">htop</span><br><span class="line">free -h -s 3 3 秒一次的间隔秒数</span><br></pre></td></tr></table></figure>

<h2 id="buff-cache"><a href="#buff-cache" class="headerlink" title="buff/cache"></a>buff/cache</h2><p>缓冲/缓存是两种类型的内存。<br>先总结一下：<br><strong>缓冲</strong>主要目的是进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的<br>小数量较大规模的 I/O ，以<strong>减少响应次数</strong>。（比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写，不然硬盘都要被你玩坏了）<br><strong>缓存</strong> 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong><br>的作用。</p>
<h2 id="CPU-负载很高怎么办"><a href="#CPU-负载很高怎么办" class="headerlink" title="CPU 负载很高怎么办"></a>CPU 负载很高怎么办</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -axjf 查看 STAT 这一列是否存在 D 状态进程</span><br></pre></td></tr></table></figure>
<blockquote>
<p>D 状态是指不可中断的睡眠状态。该状态的进程无法被 kill, 也无法自行退出<br>只能通过恢复其依赖的资源或者重启系统来解决。</p>
</blockquote>
<h2 id="如何查看-CPU-和-CPU-核心？"><a href="#如何查看-CPU-和-CPU-核心？" class="headerlink" title="如何查看 CPU 和 CPU 核心？"></a>如何查看 CPU 和 CPU 核心？</h2><p>查看 cpu 和 cpu 核心？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;model name&quot;</span><br></pre></td></tr></table></figure>
<p>查看 cpu 核心</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot;</span><br></pre></td></tr></table></figure>

<h2 id="查看硬盘的使用情况"><a href="#查看硬盘的使用情况" class="headerlink" title="查看硬盘的使用情况"></a>查看硬盘的使用情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -hl</span><br><span class="line">du -s -h /root</span><br></pre></td></tr></table></figure>
<h2 id="怎么杀死进程？"><a href="#怎么杀死进程？" class="headerlink" title="怎么杀死进程？"></a>怎么杀死进程？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看进程</span><br><span class="line">ps -aux | grep  python</span><br><span class="line">找到需要杀死的进程</span><br><span class="line">kill -9 3827</span><br></pre></td></tr></table></figure>
<h2 id="linux-vm-内核参数优化设置"><a href="#linux-vm-内核参数优化设置" class="headerlink" title="linux vm 内核参数优化设置"></a>linux vm 内核参数优化设置</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>使用 uptime 查看 CPU 使用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uptime</span><br></pre></td></tr></table></figure>
<p>vmstat 查看 CPU 使用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmstat 2 10</span><br></pre></td></tr></table></figure>

<h2 id="如何合理的查找（find）"><a href="#如何合理的查找（find）" class="headerlink" title="如何合理的查找（find）"></a>如何合理的查找（find）</h2><h3 id="在-software-目录下找出大小超过-10-MB的文件"><a href="#在-software-目录下找出大小超过-10-MB的文件" class="headerlink" title="在 /software 目录下找出大小超过 10 MB的文件"></a>在 /software 目录下找出大小超过 10 MB的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /software -type f -size +10240k</span><br></pre></td></tr></table></figure>

<h3 id="在-目录下找出-365-天未被访问过的文件"><a href="#在-目录下找出-365-天未被访问过的文件" class="headerlink" title="在 目录下找出 365 天未被访问过的文件"></a>在 目录下找出 365 天未被访问过的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /software \! -atime -365</span><br></pre></td></tr></table></figure>

<h3 id="目录下找出-365-天之前被修改过的文件"><a href="#目录下找出-365-天之前被修改过的文件" class="headerlink" title="目录下找出 365 天之前被修改过的文件"></a>目录下找出 365 天之前被修改过的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home -mtime +365</span><br></pre></td></tr></table></figure>

<h2 id="什么是-inode-和-process-id"><a href="#什么是-inode-和-process-id" class="headerlink" title="什么是 inode 和 process id ?"></a>什么是 inode 和 process id ?</h2><p>inode 是操作系统赋予每个文件的唯一名称。同样，进程 ID 是赋予每个进程的唯一 ID</p>
<h2 id="什么是守护进程（daemon）"><a href="#什么是守护进程（daemon）" class="headerlink" title="什么是守护进程（daemon）"></a>什么是守护进程（daemon）</h2><p>守护进程是作为后台进程运行以提供基本操作系统中可能不可用的功能的计算机程序。守护进程通常用于在后台运行服务，<br>而不直接控制交互式用户。守护进程的目的是处理周期性请求，然后将请求转发给适当程序执行。</p>
<h2 id="Linux-中的进程状态有哪些？"><a href="#Linux-中的进程状态有哪些？" class="headerlink" title="Linux 中的进程状态有哪些？"></a>Linux 中的进程状态有哪些？</h2><ul>
<li>Ready: 进程已创建并准备运行</li>
<li>Running: 进程正在执行</li>
<li>Blocked or wait: 进程正在等待用户输入</li>
<li>Terminated or Completed: 进程已完成或者被操作系统终止</li>
<li>Zombie:进程终止，但进程表仍然存在信息</li>
</ul>
<h2 id="解释-Linux-中的进程管理系统调用"><a href="#解释-Linux-中的进程管理系统调用" class="headerlink" title="解释 Linux 中的进程管理系统调用"></a>解释 Linux 中的进程管理系统调用</h2><p>管理进程的系统调用：</p>
<ul>
<li>fork(): 用户创建新进程</li>
<li>exec(): 执行一个新进程</li>
<li>wait(): 等待进程完成执行</li>
<li>exit(): 退出进程</li>
</ul>
<h2 id="为什么要使用-tar-命令？"><a href="#为什么要使用-tar-命令？" class="headerlink" title="为什么要使用 tar 命令？"></a>为什么要使用 tar 命令？</h2><blockquote>
<p>tar 命令用于提取或创建归档文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvzf sample.tar.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvzf filename.tar.gz</span><br></pre></td></tr></table></figure>
<p>其中 c: 创建存档；x: 提取；v: 详细；f: 文件</p>
<h2 id="如何查看-Linux-上挂载的设备列表？"><a href="#如何查看-Linux-上挂载的设备列表？" class="headerlink" title="如何查看 Linux 上挂载的设备列表？"></a>如何查看 Linux 上挂载的设备列表？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -l</span><br></pre></td></tr></table></figure>

<h2 id="如何查找两个配置文件的不同之处"><a href="#如何查找两个配置文件的不同之处" class="headerlink" title="如何查找两个配置文件的不同之处"></a>如何查找两个配置文件的不同之处</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">diff abc.conf xyz.conf</span><br></pre></td></tr></table></figure>
<p><img src="img_1.png" alt="img_1.png"></p>
<h2 id="你会如何在-linux-中安排任务？"><a href="#你会如何在-linux-中安排任务？" class="headerlink" title="你会如何在 linux 中安排任务？"></a>你会如何在 linux 中安排任务？</h2><p>linux 中有两个用于调度任务的命令：cron 和 at。<br>cron 命令用于在特定时间重复调度任务。任务存储在 cron 文件中，然后使用 cron 命令执行。<br>cron 命令从该文件中<code>读取字符串</code>并安排任务。<br>cron 文件语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;minute&gt; &lt;hour&gt; &lt;day&gt; &lt;month&gt; &lt;weekday&gt; &lt;command&gt;</span><br></pre></td></tr></table></figure>
<p>假设您想在每周日下午 4 点运行一个命令，那么字符串将是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 16 * * 0 &lt;command&gt;</span><br></pre></td></tr></table></figure>
<p>假设您想在今天下午 6 点关闭系统，那么执行操作的命令将是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;shutdown now&quot; | at -m 18:00</span><br></pre></td></tr></table></figure>
<h2 id="如何识别你使用的是哪个-shell"><a href="#如何识别你使用的是哪个-shell" class="headerlink" title="如何识别你使用的是哪个 shell?"></a>如何识别你使用的是哪个 shell?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<h2 id="如何从您的系统登陆到您网络中的另一个系统？"><a href="#如何从您的系统登陆到您网络中的另一个系统？" class="headerlink" title="如何从您的系统登陆到您网络中的另一个系统？"></a>如何从您的系统登陆到您网络中的另一个系统？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh &lt;username&gt;@&lt;ip address&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何使用-vim-编辑器以只读模式打开文件？"><a href="#如何使用-vim-编辑器以只读模式打开文件？" class="headerlink" title="如何使用 vim 编辑器以只读模式打开文件？"></a>如何使用 vim 编辑器以<code>只读</code>模式打开文件？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim -R &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何使用-vim-编辑器在文件中搜索特定的员工-ID"><a href="#如何使用-vim-编辑器在文件中搜索特定的员工-ID" class="headerlink" title="如何使用 vim 编辑器在文件中搜索特定的员工 ID ?"></a>如何使用 vim 编辑器在文件中搜索特定的员工 ID ?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim +/&lt;employee id to be searched&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何使用-vim-编辑器跳转到文件中的特定行？"><a href="#如何使用-vim-编辑器跳转到文件中的特定行？" class="headerlink" title="如何使用 vim 编辑器跳转到文件中的特定行？"></a>如何使用 vim 编辑器跳转到文件中的特定行？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim +/&lt;line number&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何按照升序对文本文件中的条目进行排序"><a href="#如何按照升序对文本文件中的条目进行排序" class="headerlink" title="如何按照升序对文本文件中的条目进行排序?"></a>如何按照升序对文本文件中的条目进行排序?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort sample.txt</span><br></pre></td></tr></table></figure>

<h2 id="如何检查特定服务是否在运行？"><a href="#如何检查特定服务是否在运行？" class="headerlink" title="如何检查特定服务是否在运行？"></a>如何检查特定服务是否在运行？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service &lt;service-name&gt; status</span><br></pre></td></tr></table></figure>

<h2 id="如何查看所有服务的状态"><a href="#如何查看所有服务的状态" class="headerlink" title="如何查看所有服务的状态?"></a>如何查看所有服务的状态?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service --status-all</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux shell 脚本</title>
    <url>/posts/77fe4966/</url>
    <content><![CDATA[<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>什么是 shell ?</p>
<p>在计算机科学中，shell 就是一个<strong>命令解释器</strong></p>
<p>功能定位</p>
<p><strong>shell 担任了操作系统和应用程序之间的中间人</strong>，它负责将应用程序的输入命令信息解释给操作系统，操作系统将指令集结果反馈给应用程序。</p>
<p>Category</p>
<p>linux: sh/csh/ksh/bash/…</p>
<h3 id="Basic-Operation"><a href="#Basic-Operation" class="headerlink" title="Basic Operation"></a>Basic Operation</h3><ol>
<li>查看当前系统的 shell</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看当前系统环境支持的 shell</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更改默认的 shell</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh 用户名 -s newshell</span><br></pre></td></tr></table></figure>

<h3 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h3><p>shell脚本的执行通常可以采用以下几种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash /path/to/script-name 或 /bin/bash /path/to/script-name (强烈推荐使用)</span><br><span class="line">/path/to/script-name 或 ./script-name (当前路径下执行脚本)</span><br><span class="line">source script-name 或 . script-name (注意“</span><br></pre></td></tr></table></figure>

<h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>本地变量</td>
<td>变量仅仅在当前Shell终端有效</td>
</tr>
<tr>
<td>环境变量</td>
<td>也叫全局变量，变量在当前Shell终端其派生出来的任意子进程Shell终端中有效</td>
</tr>
<tr>
<td>内置变量</td>
<td>Shell解析器内部的一些功能参数变量</td>
</tr>
</tbody></table>
<h4 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h4><p>def: 变量仅仅在当前 Shell 终端有效</p>
<p><strong>表现样式</strong>：</p>
<p>① 普通变量的定义方式有如下三种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>样式</th>
<th>特点</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>无引号</td>
<td>变量名=变量值</td>
<td>变量值必须是一个整体，中间没有特殊字符</td>
<td>“=” 前后不能有空格</td>
</tr>
<tr>
<td>单引号</td>
<td>变量名=’变量值’</td>
<td>原字符输出</td>
<td></td>
</tr>
<tr>
<td>双引号</td>
<td>变量名=”变量值”</td>
<td>变量值先解析，后整合</td>
<td>无</td>
</tr>
</tbody></table>
<p>② 命令变量的定义方式有如下两种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>样式</th>
<th>特点</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>反引号</td>
<td>变量名=‘ 命令’</td>
<td>反引号</td>
<td>不要用中文</td>
</tr>
<tr>
<td>小括号</td>
<td>变量名=$(命令)</td>
<td>$()</td>
<td>无</td>
</tr>
</tbody></table>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>def：也叫全局变量，变量在当前Shell终端其派生出来的任意子进程Shell终端中有效</p>
<p>表现形式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export 变量=值</span><br></pre></td></tr></table></figure>

<h4 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h4><p>查看：$变量名、“$变量名”、${变量名}、”${变量名}”</p>
<p>取消：unset 变量名</p>
<h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><p><strong>属性含义</strong>：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>获取当前脚本文件名</td>
</tr>
<tr>
<td>$n</td>
<td>获取脚本的第n个参数值，样式：$1，${1}</td>
</tr>
<tr>
<td>$#</td>
<td>获取脚本参数的总个数</td>
</tr>
<tr>
<td>$?</td>
<td>获取上一个指令的状态返回值(0为成功，非0为失败)</td>
</tr>
</tbody></table>
<h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><p>① 方式A：test 条件表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：=号两边必须有空格</span></span><br><span class="line"><span class="built_in">test</span> 1 = 1</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"><span class="built_in">test</span> 1 = 2</span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>② 方式B：[ 条件表达式 ]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注：=号两边必须有空格，并且方括号[、]与条件表达式之间也要至少有一个空格</span></span><br><span class="line">[ 1 = 1 ]</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">[ 1 = 2 ]</span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>条件成立，状态返回值是0；条件不成立，状态返回值是1。</p>
<h3 id="表达样式"><a href="#表达样式" class="headerlink" title="表达样式"></a>表达样式</h3><p><strong>① 重点表达式</strong>：</p>
<table>
<thead>
<tr>
<th>逻辑</th>
<th>样式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>命令1 &amp;&amp; 命令2</td>
<td>只有1成功，2才执行</td>
</tr>
<tr>
<td>||</td>
<td>命令1 || 命令2</td>
<td>1和2只能执行一个</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>文件</th>
<th>样式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>-f|d|s</td>
<td>-f file_name</td>
<td>判断文件格式</td>
</tr>
<tr>
<td>-r|w|x</td>
<td>-x file_name</td>
<td>判断文件权限</td>
</tr>
</tbody></table>
<p><strong>② 一般表达式</strong>：</p>
<table>
<thead>
<tr>
<th>数字</th>
<th>样式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>eq</td>
<td>数字1 eq 数字2</td>
<td>相等eq，不等ne</td>
</tr>
<tr>
<td>gt</td>
<td>数字1 gt 数字2</td>
<td>gt大于，小于lt</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字符串</th>
<th>样式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>== | !=</td>
<td>str1 == str2</td>
<td>字符串内容是否一致</td>
</tr>
<tr>
<td>-z|n</td>
<td>-z str1</td>
<td>z空，n不空</td>
</tr>
</tbody></table>
<p><strong>③ 计算表达式</strong>：</p>
<p>样式一：$[计算表达式]、a=$[变量名a+1]</p>
<p>样式二：$((计算表达式)) 或 a=$((变量名a+1))</p>
<p>样式三：let 变量名a=变量名a+1</p>
<blockquote>
<p>注意：样式三的表达式必须是一个整体，中间不能出现空格等特殊字符</p>
</blockquote>
<h3 id="常见符号"><a href="#常见符号" class="headerlink" title="常见符号"></a>常见符号</h3><p><strong>① 信息传递</strong></p>
<table>
<thead>
<tr>
<th>重定向符号</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;|&lt;</td>
<td>表示将符号左侧|右侧的内容，以覆盖的方式输入到右侧|左侧文件</td>
</tr>
<tr>
<td>&gt;&gt;|&lt;&lt;</td>
<td>表示将符号左侧|右侧的内容，以追加的方式输入到右侧|左侧文件的末尾行中</td>
</tr>
</tbody></table>
<p><strong>② 其他符号</strong></p>
<table>
<thead>
<tr>
<th>后台展示符号</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>就是将一个命令从前台转到后台执行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>信息获取符号</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>表示正确输出的信息</td>
</tr>
<tr>
<td>2</td>
<td>表示错误输出的信息</td>
</tr>
<tr>
<td>2&gt;&amp;1</td>
<td>代表所有输出的信息,也可以简写为 “&amp;&gt;”</td>
</tr>
</tbody></table>
<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>global search regular expression and print out the line </p>
<p>文本搜索命令</p>
<p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [参数] [关键字] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参数详解</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>只输出匹配行的计数</td>
</tr>
<tr>
<td>-n</td>
<td>显示匹配行及行号</td>
</tr>
<tr>
<td>-v</td>
<td>显示不包含匹配文本的所有行</td>
</tr>
<tr>
<td>-E</td>
<td>使用扩展正则匹配</td>
</tr>
</tbody></table>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>行文件编辑工具</p>
<p><strong>命令格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [参数] <span class="string">&#x27;&lt;匹配条件&gt; [动作]&#x27;</span> [文件名]</span><br></pre></td></tr></table></figure>

<p><strong>参数详解</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>参数为空</td>
<td>表示sed的操作效果，实际上不对文件进行编辑</td>
</tr>
<tr>
<td>-n</td>
<td>默认只输出修改的内容，一般在动作中结合”p”使用</td>
</tr>
<tr>
<td>-i</td>
<td>表示对文件进行编辑</td>
</tr>
</tbody></table>
<blockquote>
<p>注：mac版本的bash中使用 -i参数，必须在后面单独加个东西: -i ‘’</p>
</blockquote>
<p><strong>① 替换操作</strong></p>
<p><strong>命令格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;行号s#原内容#替换后内容#列号&#x27;</span> [文件名]</span><br><span class="line">或</span><br><span class="line">sed -i <span class="string">&#x27;/匹配关键字/s#原内容#替换后内容#列号&#x27;</span> [文件名]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：行号不写表示所有行，列号不写表示第1列，列号写成g，表示当前所有匹配的内容</p>
</blockquote>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk是一个功能非常强大的文档编辑工具，它不仅能以行为单位还能以列为单位处理文件。</p>
<p><strong>命令格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [参数] <span class="string">&#x27;BEGIN&#123;...&#125;&#123;动作&#125;END&#123;...&#125;&#x27;</span> [文件名]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">常见参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-F</td>
<td align="left">指定列的分隔符</td>
</tr>
<tr>
<td align="left"><strong>常见动作</strong></td>
<td align="left"><strong>说明</strong></td>
</tr>
<tr>
<td align="left">print</td>
<td align="left">显示内容</td>
</tr>
<tr>
<td align="left">$0</td>
<td align="left">显示当前行所有内容</td>
</tr>
<tr>
<td align="left">$n</td>
<td align="left">显示当前行的第n列内容，如果存在多个$n，它们之间使用逗号(,)隔开</td>
</tr>
<tr>
<td align="left"><strong>常见内置变量</strong></td>
<td align="left"><strong>说明</strong></td>
</tr>
<tr>
<td align="left">FILENAME</td>
<td align="left">当前输入文件的文件名，该变量是只读的</td>
</tr>
<tr>
<td align="left">NF</td>
<td align="left">输出最后一列的内容</td>
</tr>
<tr>
<td align="left">OFS</td>
<td align="left">输出格式的列分隔符，缺省是空格</td>
</tr>
<tr>
<td align="left">FS</td>
<td align="left">输入文件的列分融符，缺省是连续的空格和Tab</td>
</tr>
</tbody></table>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><strong>① 单分支if</strong></p>
<p>特点：单条件，单结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    指令</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 单if语句的使用场景 </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;man&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：男&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><strong>② 双分支if</strong></p>
<p>特点：单条件，两结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    指令1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    指令2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 双分支if语句的使用场景 </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;man&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：男&quot;</span> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：女&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><strong>③ 多分支if</strong></p>
<p>特点：n条件，n+1结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    指令1</span><br><span class="line"><span class="keyword">elif</span> [ 条件2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    指令2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    指令3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 多分支if语句的使用场景 </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;man&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：男&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;woman&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：女&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别，我不知道&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-脚本案例"><a href="#1-2-脚本案例" class="headerlink" title="1.2 脚本案例"></a>1.2 脚本案例</h4><p><strong>① 需求说明</strong></p>
<p>要求脚本执行需要有参数，通过传入参数来实现不同的功能。</p>
<p>参数和功能详情如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>执行效果</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>服务启动中…</td>
</tr>
<tr>
<td>stop</td>
<td>服务关闭中…</td>
</tr>
<tr>
<td>restart</td>
<td>服务重启中…</td>
</tr>
<tr>
<td>*</td>
<td>脚本x.sh使用方式为： x.sh [ start|stop|restart ]</td>
</tr>
</tbody></table>
<p><strong>② 脚本内容</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 多if语句的使用场景</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;start&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;服务启动中...&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;stop&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;服务关闭中...&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;restart&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;服务重启中...&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span> 脚本的使用方式: <span class="variable">$0</span> [ start | stop | restart ]&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="2-case语句"><a href="#2-case语句" class="headerlink" title="2. case语句"></a>2. case语句</h3><p>我们发现多if语句使用的时候，代码量很多，而且整体看起来确实有那么一丁点乱，有没有办法更好的实现这种效 果呢？就是case语句。</p>
<h4 id="2-1-语法格式"><a href="#2-1-语法格式" class="headerlink" title="2.1 语法格式"></a>2.1 语法格式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 变量名 <span class="keyword">in</span></span><br><span class="line">    值 1)</span><br><span class="line">        指令1</span><br><span class="line">        ;;</span><br><span class="line">    ...</span><br><span class="line">    值 n)</span><br><span class="line">        指令n</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<br>① 首行关键字是case，末行关键字esac<br>② 选择项后面都有 )<br>③ 每个选择的执行语句结尾都有两个分号</p>
</blockquote>
<h4 id="2-2-语法示例"><a href="#2-2-语法示例" class="headerlink" title="2.2 语法示例"></a>2.2 语法示例</h4><p>场景：在多if语句的基础上对脚本进行升级</p>
<p>需求：要求脚本执行需要有参数，通过传入参数来实现不同的功能</p>
<p>参数和功能详情如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>执行效果</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>服务启动中…</td>
</tr>
<tr>
<td>stop</td>
<td>服务关闭中…</td>
</tr>
<tr>
<td>restart</td>
<td>服务重启中…</td>
</tr>
<tr>
<td>*</td>
<td>脚本x.sh使用方式为： x.sh [ start|stop|restart ]</td>
</tr>
</tbody></table>
<p>脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi case.sh </span></span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="comment"># case语句使用场景</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line">    <span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;服务启动中...&quot;</span></span><br><span class="line">        ;; </span><br><span class="line">    <span class="string">&quot;stop&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;服务关闭中...&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">  <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;服务重启中...&quot;</span></span><br><span class="line">        ;; </span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span> 脚本的使用方式: <span class="variable">$0</span> [ start | stop | restart ]&quot;</span></span><br><span class="line">        ;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h3 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h3><h4 id="3-1-语法格式"><a href="#3-1-语法格式" class="headerlink" title="3.1 语法格式"></a>3.1 语法格式</h4><p><strong>for循环语句</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 条件</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：for语句，循环的数量有列表中元素个数来决定</p>
</blockquote>
<p>简单实践：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># for语句的使用示例 </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(ls /root) </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;i&#125;</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>while条件</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：while语句，只要条件满足，就一直循环下去</p>
</blockquote>
<p>简单实践：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># while 的示例</span></span><br><span class="line">a=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>&quot;</span> -lt 5 ] </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>&quot;</span></span><br><span class="line">    a=$((a+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>util条件</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">until 条件</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：until语句，只要条件不满足，就一直循环下去</p>
</blockquote>
<p>简单实践：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># until的示例</span></span><br><span class="line">a=1</span><br><span class="line">until [ <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>&quot;</span> -eq 5 ] </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>&quot;</span></span><br><span class="line">    a=$((a+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><p>定义：函数就是将某些命令组合起来实现某一特殊功能的方式，是脚本编写中非常重要的一部分。</p>
<h4 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h4><p><strong>简单函数格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名()&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用函数：函数名</p>
</blockquote>
<p><strong>传参函数格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名()&#123;</span><br><span class="line">    函数体 <span class="variable">$n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用函数：函数名 参数</p>
<p>注：function 关键字可以省略</p>
</blockquote>
<h4 id="1-2-简单实践"><a href="#1-2-简单实践" class="headerlink" title="1.2 简单实践"></a>1.2 简单实践</h4><p><strong>简单函数定义和调用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 函数使用场景一：执行频繁的命令</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;my name is smart&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">func</span><br></pre></td></tr></table></figure>

<p><strong>函数传参和函数体内调用参数示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 函数的使用场景二</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;my name is <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">func <span class="string">&quot;smart&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-函数进阶"><a href="#2-函数进阶" class="headerlink" title="2. 函数进阶"></a>2. 函数进阶</h3><h4 id="2-1-进阶样式"><a href="#2-1-进阶样式" class="headerlink" title="2.1 进阶样式"></a>2.1 进阶样式</h4><p><strong>脚本传参和函数调用</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 脚本传参数</span></span><br><span class="line">/bin/bash 脚本名 参数</span><br></pre></td></tr></table></figure>

<p>函数定义和调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">函数名()&#123;</span><br><span class="line">    函数体 <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line">函数名 <span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<p>函数定义和调用(生成用)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">本地变量名=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">函数名()&#123;</span><br><span class="line">    函数体 <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line">函数名 <span class="string">&quot;<span class="variable">$&#123;本地变量名&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-进阶实践"><a href="#2-2-进阶实践" class="headerlink" title="2.2 进阶实践"></a>2.2 进阶实践</h4><p>脚本传参+函数调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 函数传参演示</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;my name is <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 函数传参</span></span><br><span class="line">func <span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<p>脚本传参+函数调用(生产用)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数的使用场景二</span></span><br><span class="line">name=&quot;$1&quot; </span><br><span class="line">func()&#123;</span><br><span class="line">    echo &quot;my name is $1&quot;</span><br><span class="line">&#125;</span><br><span class="line">func &quot;$&#123;name&#125;&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gunicorn 原理</title>
    <url>/posts/68d6c4d9/</url>
    <content><![CDATA[<h1 id="gunicorn"><a href="#gunicorn" class="headerlink" title="gunicorn"></a>gunicorn</h1><p>Gunicorn – unix 上被广泛使用的高性能 Python WSGI UNIX HTTP Server，常用于生产环境中运行的 Python Web 应用程序。</p>
<p>它所在的位置通常是在反向代理（Nginx）或者 负载均衡 和一个 web 应用之间。它是一个移植自 Ruby 的 Unicorn 项目的 pre-woker 模型，即支持 eventlet 也支持 greenlet</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Gunicorn 基于 pre-fork worker 模型。这意味着有一个中央主进程管理一组工作进程。</p>
<p>主进程是一个简单的循环，它监听各种进程信号并做出相应的反应。它通过监听 TTIN、TTOUT 和 CHLD 等信号来管理正在运行的工作人员列表。TTIN 和 TTOUT 告诉 master 增加或减少正在运行的 worker 的数量。CHLD 表示一个子进程已经终止，在这种情况下主进程会自动重启失败的工作进程。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>WSGI 兼容性：Gnicorn 符合 WSGI 规范，定义了 Web 服务器和 Python 应用程序之间通信的标准接口。这使得 Gunicorn 与许多 Python Web 框架（如 Django\Flask等）兼容。</li>
<li>高性能：gunicorn 使用异步的、事件驱动的编程模型，具备大量的并发连接。采用 pre-fork 的方式，每个进程可以处理多个请求，并在请求到达时快速响应。</li>
<li>丰富的配置：gunicorn 提供了丰富的配置选项、可以通过配置文件或者命令行参数进行调整。你可以指定工作进的数量、绑定的主机和端口、日志级别等。</li>
<li>进程管理：gunicorn 具有内置的进程管理功能，可以管理工作进程的生命周期。它可以自动重启崩溃的进程，并在需要时平滑地进行热部署，而不会中断正在处理的请求。</li>
<li>安全性：Gunicorn 提供了一些安全机制，包括 Unix 权限控制、访问日志记录和访问限制。它还可以与反向代理（Nginx）结合使用，以增强安全性和性能</li>
<li>插件生态系统：Gunicorn 支持多插件，可以扩展其功能。例如，有插件用于加载静态文件、实现 SSL 加密、处理 WebSocket 连接等。</li>
</ul>
<h2 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h2><h3 id="常规参数一览"><a href="#常规参数一览" class="headerlink" title="常规参数一览"></a>常规参数一览</h3><p><a href="https://docs.gunicorn.org/en/stable/run.html#commonly-used-arguments">https://docs.gunicorn.org/en/stable/run.html#commonly-used-arguments</a></p>
<ol>
<li>绑定地址和端口相关配置<ul>
<li><code>ip:port</code></li>
<li><strong><code>backlog</code>: 定义等待连接队列的最大长度，在 TCP/IP 网络编程中，当一个服务器正在处理并发连接请求时，如果有更多的连接到达，当服务器当前无法及时处理时，这些请求将会被放置在一个等待连接队列中，等待服务器处理。</strong></li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定端口 注意0.0.0.0的配置在docker网络中是关键配置</span></span><br><span class="line">bind = <span class="string">f&quot;0.0.0.0:<span class="subst">&#123;PORT&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>工作进程和并发性能配置<ul>
<li><strong><code>workers</code>: 定义工作进程的数量，可以是整数值或者是 CPU 核心数的倍数</strong></li>
<li><strong><code>worker_class</code>: 定义 worker 类型，例如：sync\gevent\eventlet 等</strong></li>
<li><strong><code>worker_connections</code>: 每个工作进程允许的最大并发连接数</strong></li>
<li><code>threads</code>: 每个工作进程中的线程数<strong>（仅适用于支持线程的工作进程）</strong></li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 工作进程数 常规使用Docker横向扩容，故按项目实际情况配置</span></span><br><span class="line">workers = <span class="number">3</span></span><br><span class="line"><span class="comment"># 工作单位 除特殊情况外,工程无脑使用gevent 算法可考虑使用gthread</span></span><br><span class="line"><span class="comment"># 详见文档: https://docs.gunicorn.org/en/stable/design.html#choosing-a-worker-type</span></span><br><span class="line"><span class="comment"># 不使用sync的最大问题在于sync虽然在短连接中网络模式最为简单干净,但不支持长连接,在高并发任务中的TCP效率会非常低</span></span><br><span class="line">worker_class = <span class="string">&quot;gevent&quot;</span></span><br><span class="line"><span class="comment"># 客户端最大同时连接数 在极高并发根据服务器和实例数根据情况修改</span></span><br><span class="line"><span class="comment"># 仅适用于eventlet/gevent</span></span><br><span class="line">worker_connections = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进程管理和重启配置<ul>
<li><strong><code>max_requests</code>: 每个工作进程处理的最大请求数，达到后将自动重启</strong></li>
<li><strong><code>max_requests_jitter</code>: 请求处理最大请求数的抖动范围</strong></li>
<li><code>timeout</code>: 工作进程处理请求的超时时间</li>
<li><code>graceful_timeout</code>: 优雅关闭工作进程的超时时间</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3. 进程管理和重启配置 -&gt; max_requests &amp;&amp; max_requests_jitter &amp;&amp; timeout &amp;&amp; graceful_timeout</span></span><br><span class="line"><span class="comment"># 每执行多少请求,即重启服务 该功能用于防止内存泄漏</span></span><br><span class="line"><span class="comment"># 对算法来说,该功能会导致重新初始化服务 可以设置0为关闭</span></span><br><span class="line">max_requests = <span class="number">50000</span></span><br><span class="line"><span class="comment"># 在max_requests 的基础上,随机加减 max_requests_jitter 的参数值 该功能用于防止并发下所有容器同时重启</span></span><br><span class="line"><span class="comment"># 当max_requests=0 时,该配置不生效</span></span><br><span class="line">max_requests_jitter = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 超时时间 根据实际情况配置 推荐30/60</span></span><br><span class="line">timeout = <span class="number">600</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>日志和调试配置<ul>
<li><code>accesslog</code>: 访问日志文件的路径，或者使用特定的值（例如 <code>-</code>）输出到标准输出</li>
<li><code>errorlog</code>: 错误日志文件的路径，或者使用特定的值（例如 <code>-</code>）输入到标准输出</li>
<li><code>loglevel</code>: 日志记录级别，例如 <code>degub</code>,<code>info</code>, <code>warning</code></li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否使用debug模式</span></span><br><span class="line">debug = DEBUG</span><br><span class="line"><span class="comment"># 是否重定向错误到日志文件</span></span><br><span class="line">capture_output = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CMD [<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;gunicorn.conf.py&quot;</span>, <span class="string">&quot;server:create_app()&quot;</span>, <span class="string">&quot;–access-logfile -&quot;</span>]</span><br></pre></td></tr></table></figure>



<h2 id="how-to-choose-worker"><a href="#how-to-choose-worker" class="headerlink" title="how to choose worker"></a>how to choose worker</h2><p>参考：<a href="https://docs.gunicorn.org/en/stable/design.html#choosing-a-worker-type">https://docs.gunicorn.org/en/stable/design.html#choosing-a-worker-type</a></p>
<p>如何选择一个适用的 worker， Gunicorn 提供了多种类型的工作进程（Workers）,每种</p>
<p>工作进程都有不同的工作模型和适用场景。以下是 Gunicorn 支持的常见工作类型：</p>
<ul>
<li><p>Sync - 同步工作进程</p>
<p><code>sync</code> 默认的工作进程类型。它使用同步的方式处理请求，即每个工作进程一次只处理一个请求。适用于 IO 密集型的应用程序，但是在面对长时间运行的请求或高并发情况下可能会出现性能问题。</p>
</li>
<li><p>Async workers - 异步工作进程</p>
<ul>
<li><code>gevent</code>: 使用 gevent 库作为异步处理引擎。适用于 IO 密集型的应用程序，能够处理大量的并发连接，提高性能。</li>
<li><code>eventlet</code>: 使用 <code>eventlet 库</code>作为异步处理引擎。类似于 gevent，适用于 IO 密集型的应用程序，具有良好的并发性能。</li>
<li>……</li>
</ul>
</li>
<li><p>Thread-based Workers (基于线程的工作进程)</p>
<ul>
<li><code>sync</code>: 使用多线程来处理请求。适用于处理计算密集型的任务，可以利用多核 CPU 的优势，但在面对 IO 密集型的应用程序时可能会有性能问题</li>
</ul>
</li>
</ul>
<h2 id="gevent-介绍"><a href="#gevent-介绍" class="headerlink" title="gevent 介绍"></a>gevent 介绍</h2><p>gevent 是一个 Python 网络函数库，通过 Greenlet 协程 + libev 快速事件循环，实现了异步模型。</p>
<p>gevent 的主要特定和工作原理如下：</p>
<ul>
<li><strong>协程</strong> (Greenlet)：gevent 使用 greenlet 库实现协程。协程是一种用户级线程，可以在同一个线程中切换执行。每个协程都有自己的执行上下文和栈，可以独立地运行和暂停，以及在适当的时机切换到其他协程。</li>
<li><strong>事件循环</strong>(Event Loop)：gevent 使用事件循环机制来调度协程的执行。事件循环负责管理协程的调度和协程之间的切换。当一个协程被阻塞时（例如等待 I/O 操作完成），事件循环会切换到其他可运行的协程，以避免阻塞整个程序。</li>
<li><strong>非阻塞式 I/O</strong>：gevent 利用非阻塞式 I/O 来实现协程之间的切换。当一个协程遇到 I/O 操作时（例如网络请求或文件读写），它会将 I/O 操作交给 gevent 的事件循环处理，并切换到其他协程继续执行。当 I/O 操作完成时，事件循环会通知相应的协程，让器继续执行。</li>
<li>基于 <strong>Monkey patching</strong> 的协程化：gevent 通过 Monkey Patching 技术，对 Python 标准库中的一些阻塞式 I/O 操作进行替换，使其变成非阻塞的。</li>
</ul>
<h2 id="gevent-如何实现并发"><a href="#gevent-如何实现并发" class="headerlink" title="gevent 如何实现并发"></a>gevent 如何实现并发</h2><p>在 gevent 中，每个请求的连接都是一个 Greenlet 协程。Gevent 虽然只有一个线程、同时只能处理一个请求，但是在这个请求的异步事件没准备好时，进入到 IO 等待时，能主动 yield 让出控制权、而不是阻塞其他请求的协程，而是先让其他协程执行，当自己的 IO 准备好后，事件循环会将它从 yield 让出控制权的地方，继续恢复执行。</p>
<p>这样，Gevent 就能在不同的请求间不断切换，从而实现并发，以充分利用 CPU、减少 IO 等待时间。并且，切换的 Greenlet 是微线程，它操作的维度是函数，而不是线程/进程，所以来回切换的开销，就没有那么大。</p>
<p>同步 worker 和 异步 worker ,这两种 worker 类型是最常用的。一般而言，对于我们的应用而言，我们的 web app 多半属于 外部 IO 密集型（总要访问第三方服务等），所以用 Gunicorn 的 Gevent 异步 worker，就非常合理。</p>
<p>而如果你的 web app 是 CPU 密集型，或者你希望请求之间不要互相影响，那么可以选择 Gunicorn 的 同步 worker。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>常见问题：<a href="https://docs.gunicorn.org/en/stable/faq.html#faq">https://docs.gunicorn.org/en/stable/faq.html#faq</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/36834234/eventlet-vs-greenlet-vs-gevent">https://stackoverflow.com/questions/36834234/eventlet-vs-greenlet-vs-gevent</a></p>
<p><a href="https://docs.gunicorn.org/en/latest/design.html#how-many-workers">https://docs.gunicorn.org/en/latest/design.html#how-many-workers</a></p>
<p><a href="https://bbs.huaweicloud.com/blogs/309794">https://bbs.huaweicloud.com/blogs/309794</a></p>
<p><a href="https://docs.gunicorn.org/en/stable/design.html#choosing-a-worker-type">https://docs.gunicorn.org/en/stable/design.html#choosing-a-worker-type</a></p>
]]></content>
      <categories>
        <category>gunicorn</category>
      </categories>
      <tags>
        <tag>gunicorn</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础总结</title>
    <url>/posts/ef472d6b/</url>
    <content><![CDATA[<h1 id="SQL-基础"><a href="#SQL-基础" class="headerlink" title="SQL 基础"></a>SQL 基础</h1><p>我们通常将 SQL 分为四类：</p>
<ul>
<li><p>DDL (数据定义语言)</p>
<p><code>create</code> <code>drop</code> <code>alter</code></p>
</li>
<li><p>DML(数据操作语言)</p>
<p><code>insert</code> <code>delete</code> <code>update</code></p>
</li>
<li><p>DQL(数据查询语言)</p>
<p><code>select</code></p>
</li>
<li><p>DCL(数据控制语言)</p>
<p><code>grant</code> <code>revoke</code></p>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>参考：<a href="https://tianzhichao.com/posts/26a608fc/">https://tianzhichao.com/posts/26a608fc/</a></p>
<blockquote>
<p>理论上来说，事务有着极其严格的定义，它必须同时满足四个特性：</p>
</blockquote>
<ul>
<li><strong>原子性（Atomicity)</strong><br>事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li>
<li><strong>一致性（consistency）</strong><br>事务应确保数据库的状态从一个一致状态转变为另一个一致状态</li>
<li><strong>隔离型（isolation）</strong><br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li><strong>持久性（durability）</strong><br>已被提交的事务对数据库的修改应该永久保存在数据库中</li>
</ul>
<p>事务的实现是通过 redo log &amp;&amp; undo log，以及锁实现的</p>
<p>redo log 实现持久化和原子性，undo log 实现一致性状态变化，锁实现事务的隔离性。</p>
<p>redo log 是恢复提交事务修改的页操作，undo log 是回滚行记录到特定的版本。二者记录的内容也不同，redo log 是物理日志，记录页的物理修改操作，undo log<br>是逻辑日志，根据每行记录进行记录。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote>
<p>索引是关系型数据库中用来提升查询性能最为重要的手段。</p>
</blockquote>
<p>对于 MySQL 8.0 版本的 InnoDB 存储引擎来说，它支持三种类型的索引：</p>
<ul>
<li>B+ 树索引（默认索引）</li>
<li>全文索引（FULLTEXT）</li>
<li>R 树索引</li>
</ul>
<blockquote>
<p>B+ 树目前在基于磁盘进行数据存储和排序上最有效率的数据结构。B+树是一颗平衡树，树的高度通常为 3 或 4，但是却可以保存从从百万级到十亿级的数据，而从这些数据里面查询一条数据，只需要 3 次或 4 次 I/O 操作。</p>
</blockquote>
<blockquote>
<p>B 树和 B+ 树的区别：<a href="https://www.jianshu.com/p/ace3cd6526c4">https://www.jianshu.com/p/ace3cd6526c4</a></p>
</blockquote>
<h4 id="从应用层次上划分"><a href="#从应用层次上划分" class="headerlink" title="从应用层次上划分"></a>从应用层次上划分</h4><ul>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：一个索引包含多个列</li>
</ul>
<h4 id="从表记录的存储形式上来划分"><a href="#从表记录的存储形式上来划分" class="headerlink" title="从表记录的存储形式上来划分"></a>从表记录的存储形式上来划分</h4><ul>
<li>聚簇索引：表记录的排列顺序和索引的排列顺序一致</li>
<li>非聚簇索引：表记录的排列顺序和索引的排列顺序不一致</li>
</ul>
<h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h4><blockquote>
<p>在 InnoDB 中，表数据文件本身就是按照 B+Tree 组织的一个索引结构。<br>聚簇索引就是按照每张表的主键构造一颗 B+ 树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。<br>一般建表会用一个自增主键做聚簇索引，没有的话 MySQL 会默认创建<br>在日常的开发任务中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需要找主键索引的二级索引，先找到主键索引再通过主键索引找到数据。</p>
</blockquote>
<h3 id="索引的执行计划"><a href="#索引的执行计划" class="headerlink" title="索引的执行计划"></a>索引的执行计划</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_student where stuname=&#x27;林震南&#x27;\G</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_student</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 11</span><br><span class="line">     filtered: 10.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>在以上的 SQL 执行计划中：</p>
<ol>
<li><p><code>select_type</code>: 查询的类型</p>
<ul>
<li><code>SIMPLE</code> 简单 select, 不需要 UNION 操作或子查询</li>
<li><code>PRIMARY</code> 如果查询包含子查询，最外层的 SELECT 被标记为 PRIMARY</li>
<li><code>UNOIN</code> UNION 操作中第二个或后面的 SELECT 语句</li>
<li><code>SUBQUERY</code> 子查询中的第一个 SELECT</li>
<li><code>DERIVED</code> 派生表的 SELECT 子查询</li>
</ul>
</li>
<li><p><code>table</code> 查询对应的表。</p>
</li>
<li><p><code>type</code> MySQL 在表中找到满足条件的行的索引方式</p>
<ul>
<li>ALL(全表扫描)</li>
<li>index(索引全扫描，只遍历索引树)</li>
<li>range(索引范围扫描)</li>
<li>ref(非唯一索引扫描)</li>
<li>eq_ref(唯一索引扫描)</li>
<li>const/system(常量级查询)</li>
<li>NULL(不需要访问表或索引)</li>
</ul>
<p>在所有的访问类型中，很显然 ALL 是性能最差的，它代表的是全表扫描。</p>
</li>
<li><p><code>possible_keys</code>: MySQL 可以选择的索引，但是有时候可能不会使用</p>
</li>
<li><p><code>key</code> MySQL 真正使用的索引，如果为 NULL 就表示没有使用索引</p>
</li>
<li><p><code>key_len</code> 使用的索引的长度，在不影响查询的情况下肯定是长度越短越好</p>
</li>
<li><p><code>rows</code> 执行查询需要扫描的行数，这时一个预估值</p>
</li>
<li><p><code>extra</code> 关于查询额外的信息</p>
<ul>
<li> <code>Using filesort</code>: MySQL 无法利用索引完成排序操作</li>
<li><code>Using index</code> 只使用索引的信息而不需要进一步查表来获取更多的信息</li>
<li><code>Using temparary</code> MySQL 需要使用临时表来存储结果集，常用语分组和排序</li>
<li><code>Impossible where</code> <code>where</code> 子句会导致没有符合条件的行</li>
<li><code>Distinct</code> 发现第一个匹配行后，停止为当前的行组合搜索更多的行</li>
<li><code>Using where</code> 查询的列未被索引覆盖，筛选条件并不是索引的前导列</li>
</ul>
</li>
</ol>
<h3 id="索引设计的原则"><a href="#索引设计的原则" class="headerlink" title="索引设计的原则"></a>索引设计的原则</h3><ol>
<li><strong>最适合索引的列是出现在 WHERE 子句和连接子句中的列</strong></li>
<li>索引列的基数越大（取值多、重复值少）索引的效果就越好</li>
<li>使用<strong>前缀索引</strong>可以减少索引占用的空间，内存中可以缓存更多的索引</li>
<li><strong>索引不是越多越好</strong>，虽然索引加速的读操作，但是写操作（增、删、改）都会变慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样</li>
<li>使用 InnoDB 存储引擎时，表的普通索引都会保存主键的值，所以<strong>主键尽可能选择较短的数据类型</strong>，这样可以有效的减少索引占用的空间，提升索引的缓存效果。</li>
<li>InnoDB 使用的 B+ tree 索引，<strong>数值类型的列除了等值判断时索引会生效，使用 &gt; |&lt;| &gt;=|&lt;=|BETWEEN … AND … 、&lt;&gt; 时，索引仍然生效；</strong>对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他情况就会导致索引失效，这就意味着很有可能会做全表扫描。</li>
</ol>
<h3 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h3><h4 id="1-联合索引不满足最左匹配原则"><a href="#1-联合索引不满足最左匹配原则" class="headerlink" title="1. 联合索引不满足最左匹配原则"></a>1. 联合索引不满足最左匹配原则</h4><p><strong>在联合索引的场景下，查询条件不满足最左匹配原则。</strong></p>
<p>顾名思义，在联合索引中，最左则的字段优先匹配。因此，在创建联合索引时，where 子句中使用最频繁的字段放在组合索引的最左则。</p>
<p>例如：unoin_idx 联合索引组成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">KEY `union_idx` (`id_no`, `username`, `age`)</span><br></pre></td></tr></table></figure>

<p>走索引的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t_user where id_no = &quot;1002&quot;;</span><br><span class="line">select * from t_user where id_no and username = &quot;1002&quot;;</span><br><span class="line">select * from t_user where id_no = &quot;1002&quot; and username = &quot;111&quot; and age = &quot;1002&quot;;</span><br></pre></td></tr></table></figure>

<p>以下不会走索引：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from t_user where username = &quot;1002&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from t_user where age = &quot;1002&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from t_user where username and age = &quot;1002&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-select"><a href="#2-使用-select" class="headerlink" title="2. 使用 select *"></a>2. 使用 select *</h4><p><strong>在联合索引下，尽量使用明确的查询列来趋向于走覆盖索引;</strong></p>
<p>在 《阿里巴巴开发手册》的 ORM 映射章节中有一条「强制」的规范：</p>
<ul>
<li>一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。3）无用字段增加网络消耗，尤其是 text 类型的字段。</li>
</ul>
<h4 id="3-索引列参与计算"><a href="#3-索引列参与计算" class="headerlink" title="3. 索引列参与计算"></a>3. 索引列参与计算</h4><p><strong>索引列参与了运算，会导致全表扫描，索引失效。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id+1=2</span><br></pre></td></tr></table></figure>

<p>索引列参与了计算，会导致全表扫描，索引失效</p>
<h4 id="4-索引列参使用了函数示例"><a href="#4-索引列参使用了函数示例" class="headerlink" title="4. 索引列参使用了函数示例"></a>4. 索引列参使用了函数示例</h4><p><strong>索引列参与了函数处理，会导致全表扫描，索引失效。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exlain select * from t_user where SUBSTR(id_no, 1, 3) = &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>此时，索引失效的原因与第三种情况一样，都是因为数据库要先进行全表扫描，获得数据之后再进行截取、计算，导致索引失效。同时，还伴随着性能问题</p>
<h4 id="5-错误的-Like-使用"><a href="#5-错误的-Like-使用" class="headerlink" title="5. 错误的 Like 使用"></a>5. 错误的 Like 使用</h4><p><strong>模糊查询时(like语句)，模糊匹配的占位符位于条件的首部。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id_no like &#x27;%00%&#x27;</span><br></pre></td></tr></table></figure>

<p>针对 like 的使用非常频繁，但使用不当往往会导致不走索引。常见的 like 使用方式有：</p>
<ul>
<li>方式一：like ‘%abc’;</li>
<li>方式二：like ‘abc%’;</li>
<li>方式三：like ‘%abc%’</li>
</ul>
<p>其中方式一和方式三，由于占位符出现在首部，导致无法走索引。</p>
<p>索引本来就相当于目录，从左到右逐个排序。而条件的左侧使用了占位符，导致无法按照正常的目录进行匹配，导致索引失效就很正常了。</p>
<h4 id="6-类型隐式转换"><a href="#6-类型隐式转换" class="headerlink" title="6. 类型隐式转换"></a>6. 类型隐式转换</h4><p>参数类型与字段类型不匹配，导致类型发生了隐式转换，索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id_no = 1002;</span><br></pre></td></tr></table></figure>

<p>id_no 字段类型为 varchar，但在 SQL 语句中使用了 int 类型，导致全表扫描。</p>
<h4 id="7-使用-OR-操作"><a href="#7-使用-OR-操作" class="headerlink" title="7. 使用 OR 操作"></a>7. 使用 OR 操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id = 2 or username = &quot;Tom2&quot;</span><br></pre></td></tr></table></figure>

<p>上述的查询中，id 字段是有索引的，但是使用 or 关键字，索引竟然失效了。</p>
<p>当单独使用 username 进行查询时，会全表扫描，索引也就不会再走索引了。</p>
<h4 id="8-两列做比较"><a href="#8-两列做比较" class="headerlink" title="8. 两列做比较"></a>8. 两列做比较</h4><p><strong>两列数据做比较，即便两列都创建了索引，索引也会失效</strong></p>
<p>如果两个列数据都有索引，但在查询条件中两列数据进行了对比操作，则会导致索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id &gt; age;</span><br></pre></td></tr></table></figure>

<h4 id="9-不等于比较"><a href="#9-不等于比较" class="headerlink" title="9. 不等于比较"></a>9. 不等于比较</h4><p><strong>查询条件使用不等进行比较时，需要慎重，普通索引会查询结果集占比较大时索引会失效。</strong></p>
<p>当查询条件为字符串时，使用 “&lt;&gt;” 或 “!=” 作为条件查询，有可能不走索引，但也不全是。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id_no != &quot;1002&quot; </span><br></pre></td></tr></table></figure>

<h4 id="10-is-not-null"><a href="#10-is-not-null" class="headerlink" title="10. is not null"></a>10. is not null</h4><p><strong>查询条件使用 is null 时正常走索引，使用 is not null 时，不走索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id_no is not null;</span><br></pre></td></tr></table></figure>

<h4 id="11-not-in-和-not-exists"><a href="#11-not-in-和-not-exists" class="headerlink" title="11. not in 和 not exists"></a>11. not in 和 not exists</h4><ul>
<li><strong>查询条件使用not in时，如果是主键则走索引，如果是普通索引，则索引失效</strong>。</li>
<li><strong>查询条件使用not exists时，索引失效。</strong></li>
</ul>
<p>在日常中使用比较多的范围查询有 in、exists、not  in、not exists、between and </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id in (2,3);</span><br><span class="line"></span><br><span class="line">explain select * from t_user where id_no in (&#x27;1001&#x27;,&#x27;1002&#x27;);</span><br><span class="line"></span><br><span class="line">explain select * from t_user u1 where exists (select 1 from t_user u2 where u2.id  = 2 and u2.id = u1.id);</span><br><span class="line"></span><br><span class="line">explain select * from t_user where id_no between &#x27;1002&#x27; and &#x27;1003&#x27;;</span><br></pre></td></tr></table></figure>

<p>上述四种语句都会正常走索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_use where id_no not in (&quot;1002&quot;, &quot;1003&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>当使用 not in 时，不走索引？</strong>当条件列换成主键试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id not in (2,3)</span><br></pre></td></tr></table></figure>

<p><strong>如果是主键，则正常走索引。</strong></p>
<h4 id="12-order-by-导致索引失效"><a href="#12-order-by-导致索引失效" class="headerlink" title="12. order by 导致索引失效"></a>12. order by 导致索引失效</h4><p>当查询条件涉及到 order by、limit 等条件时，是否走索引的情况比较复杂，而且与 MySQL 版本有关，通常普通索引，如果未使用 limit，则不会走索引。order by 多个字段时，可能不会走索引。其他情况使用 explain 验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select id from t_user order by age;</span><br><span class="line">explain select id , username from t_user order by age;</span><br><span class="line">explain select id_no from t_user order by id_no;</span><br></pre></td></tr></table></figure>

<p>当索引覆盖的场景也正常走索引的。</p>
<h4 id="13-参数不同导致索引失效"><a href="#13-参数不同导致索引失效" class="headerlink" title="13. 参数不同导致索引失效"></a>13. 参数不同导致索引失效</h4><p><strong>当查询条件为大于等于、in等范围查询时，根据查询结果占全表数据比例的不同，优化器有可能会放弃索引，进行全表扫描。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where create_time &gt; &#x27;2023-02-24 09:04:23&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where create_time &gt; &#x27;2022-02-27 09:04:23&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述两个查询，前者走索引，后者进行了全表扫描。</p>
<p>为什么同样的查询语句，知识因为查询的参数值不同，却会出现一个走索引，一个不走索引的情况呢？</p>
<p><strong>答案很简单：上述索引失效是因为 DBMS 发现全表扫描比走索引效率更高，因此就放弃了走索引。</strong></p>
<h4 id="14-其他"><a href="#14-其他" class="headerlink" title="14. 其他"></a>14. 其他</h4><p><strong>Mysql优化器的其他优化策略，比如优化器认为在某些情况下，全表扫描比走索引快，则它就会放弃索引。</strong></p>
<p>当然，还有其他一些是否走索引的情况，这与索引的类型时 B-tree 索引还是位图索引也有关系，就不再详细展开。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><blockquote>
<p>事务的隔离级别是通过锁来实现</p>
</blockquote>
<p>四种隔离级别分别是, 从低到高：</p>
<ul>
<li>READ-UNCOMMITTED（读取未提交）</li>
<li>READ-COMMITTED（读取已提交）</li>
<li>REPEATABLE-READ（可重复读）</li>
<li>SERIALIZABLE（可串行化）</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>Mysql 默认采用的 <strong>REPEATABLE_READ</strong> 隔离级别</p>
<h4 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h4><ul>
<li>脏读（Dirty Read）:<br>读取到了错误的数据，A 事务执行 update 操作，B 事务执行查询获取结果，此时 A 事务 RollBack 导致读取数据不正确。</li>
<li>不可重复读（Non-repeatable read）:<br>在一个事务的两次查询之中数据不一致，这可能是<strong>两次查询过程中间插入了一个事务更新的原有的数据</strong>。</li>
<li>幻读（Phantom Read）:<br><strong>一个事务的两次查询中夹杂着插入事务的操作，数据量不一致</strong></li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><p><a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a></p>
</li>
<li><p><a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day36-40/37.SQL%E8%AF%A6%E8%A7%A3.md#ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80">https://github.com/jackfrued/Python-100-Days/blob/master/Day36-40/37.SQL%E8%AF%A6%E8%A7%A3.md#ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80</a></p>
</li>
<li><p><a href="https://www.51cto.com/article/702691.html">https://www.51cto.com/article/702691.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引总结</title>
    <url>/posts/6e16c56e/</url>
    <content><![CDATA[<h1 id="什么是-索引？"><a href="#什么是-索引？" class="headerlink" title="什么是 索引？"></a>什么是 <strong>索引</strong>？</h1><p><strong>索引（ MySQL 中也叫做<code>键(key)</code>）</strong> 是<strong>存储引擎</strong>用于<strong>快速找到记录</strong>的一种<strong>数据结构</strong>。本文主要学习的是基于 InnoDB 存储引擎。<br>索引对于良好的性能非常关键，对于较大的数据量来说，索引的创建愈发重要。</p>
<h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><blockquote>
<p>索引有很多种类型，可以为不同的场景提供更好的性能。</p>
</blockquote>
<h2 id="从存储结构上分"><a href="#从存储结构上分" class="headerlink" title="从存储结构上分"></a>从存储结构上分</h2><ul>
<li>Btree 索引 （B+tree、B-tree）</li>
<li>full-index 全文索引</li>
<li>RTree</li>
</ul>
<h2 id="从应用层次上划分"><a href="#从应用层次上划分" class="headerlink" title="从应用层次上划分"></a>从应用层次上划分</h2><ul>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：一个索引包含多个列</li>
</ul>
<h2 id="从表记录的存储形式上来划分"><a href="#从表记录的存储形式上来划分" class="headerlink" title="从表记录的存储形式上来划分"></a>从表记录的存储形式上来划分</h2><ul>
<li>聚簇索引：表记录的排列顺序和索引的排列顺序一致</li>
<li>非聚簇索引：表记录的排列顺序和索引的排列顺序不一致</li>
</ul>
<h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><blockquote>
<p>在 InnoDB 中，表数据文件本身就是按照 B+Tree 组织的一个索引结构。<br>聚簇索引就是按照每张表的主键构造一颗 B+ 树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。<br>一般建表会用一个自增主键做聚簇索引，没有的话 MySQL 会默认创建<br>在日常的开发任务中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需要找主键索引的二级索引，先找到主键索引再通过主键索引找到数据。</p>
</blockquote>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><blockquote>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
</blockquote>
<p>聚簇索引就是按照每张表的主键构建一颗 B+ 树，同时叶子节点存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。这个特性决定了索引组织表中的数据也是索引的一部分，每张表只能拥有一个聚簇索引。<br><img src="../../images/mysql/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="direct"></p>
<h2 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h2><ul>
<li>数据访问更快，因为**聚簇索引是将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li>
<li>聚簇索引对于主键的排序查找和范围查找速度更快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
</ul>
<h2 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h2><ul>
<li></li>
<li>插入速度严重依赖插入顺序，按照主键的顺序插入是最快的方式。一般定义一个自增的 ID 列作为主键，但是如果不是按照主键顺序加载数据，那么在jia</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动，一般对于 InnoDB 表，定义主键不可更新</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
<h1 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h1><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存放的不再是行的物理位置，而是主键值。<br>通过辅助索引找到主键值，再通过主键值找到数据行的数据页，再通过数据页中的 Page Directory 找到数据行。</p>
<p>InnoDB 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点包含键值外，还包含了相应行数据的聚簇索引键。</p>
<h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h2><blockquote>
<p>特点：<strong>每一个叶子节点都包含指向下一个叶子节点的指针</strong>，从而方便叶子节点的范围遍历</p>
</blockquote>
<p>B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。<br><img src="../../images/mysql/B+Tree%E7%B4%A2%E5%BC%95.png" alt="img.png"></p>
<h2 id="B-Tree-索引检索数据的原理"><a href="#B-Tree-索引检索数据的原理" class="headerlink" title="B-Tree 索引检索数据的原理"></a>B-Tree 索引检索数据的原理</h2><p>存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是<strong>从索引的根节点开始进行搜索</strong>。<br>根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。这些指针<strong>实际上定义了子节点页中值的上限和下限</strong>，通过比较<strong>节点页中的值和要查找的值</strong>可以找到合适的指针进入下层子节点。<br>最终存储引擎的查找只会有两种情况：<strong>1. 找到对应的值。2. 记录不存在。</strong></p>
<p><strong>叶子节点指针指向的是被索引的数据，而不是其他节点页。</strong></p>
<p>树的深度和表的大小直接相关</p>
<p>B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。</p>
<p>B-Tree 索引适用于<strong>全值键、键值范围或键前缀</strong>查找。键前缀查找只适用于最左前缀查找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE People (</span><br><span class="line">    last_name varchar(50) not null DEFAULT &#x27;&#x27; comment &#x27;姓&#x27;,</span><br><span class="line">    first_name varchar(50) not null DEFAULT &#x27;&#x27; comment &#x27;名&#x27;,</span><br><span class="line">    dob date not null DEFAULT &#x27;&#x27; comment &#x27;出生日期&#x27;,</span><br><span class="line">    gender enum(0, 1) not null comment &#x27;&#x27;,</span><br><span class="line">    key(last_name, first_name, dob)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO People values (&#x27;Cuba&#x27;, &#x27;Allen&#x27;, &#x27;1960-01-01&#x27;),</span><br><span class="line">(&#x27;Angelina&#x27;, &#x27;Astaire&#x27;, &#x27;1980-03-04&#x27;),</span><br><span class="line">(&#x27;Julla&#x27;, &#x27;Barrymore&#x27;, &#x27;2000-05-16&#x27;),</span><br><span class="line">(&#x27;Christian&#x27;, &#x27;Akroyd&#x27;, &#x27;1958-12-07&#x27;),</span><br><span class="line">(&#x27;Akroyd&#x27;, &#x27;Klrsten&#x27;, &#x27;1978-11-02&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="../../images/mysql/BTree%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9.png" alt="direct"></p>
<h2 id="B-Tree-索引的查询类型"><a href="#B-Tree-索引的查询类型" class="headerlink" title="B-Tree 索引的查询类型"></a>B-Tree 索引的查询类型</h2><blockquote>
<p>explain 分析 SQL 的执行计划<br>需要重点关注 type、rows、filtered、extra。<br>type 由上至下，效率越来越高</p>
<ul>
<li>ALL 全表扫描</li>
<li>index 索引全扫描</li>
<li>range 索引范围扫描，常用语&lt;,&lt;=,&gt;,=&gt;,between, in like 等操作</li>
<li>ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</li>
<li>eq_ref 类似 ref,区别在于使用的是唯一索引，使用主键的关联查询</li>
<li>const/system 单条记录，系统会把匹配行中的其它列作为常数处理，如主键或唯一索引查询</li>
<li>null MySQL 不访问任何表或索引，直接返回结果</li>
</ul>
</blockquote>
<blockquote>
<p>虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引<code>idx1(a, b, c)</code>,<code>idx2(a, c)</code>，SQL为<code>select * from t where a = 1 and b in (1, 2) order by c;</code>如果走idx1，那么是type为range，如果走idx2，那么type是ref；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2</p>
</blockquote>
<blockquote>
<p><strong>Extra</strong></p>
</blockquote>
<blockquote>
<ul>
<li>Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。</li>
<li><strong>Using temporary：使用了临时表保存中间结果，性能特别差，需要重点优化</strong></li>
<li>Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据。</li>
<li>Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</li>
</ul>
</blockquote>
<ul>
<li><strong>全值匹配</strong><pre><code>**全值匹配指的是和索引中所有列进行匹配**
</code></pre>
例如:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and first_name=&#x27;Allen&#x27; and dob=&#x27;1960-01-01&#x27;\G;</span><br><span class="line">```  </span><br><span class="line">output:</span><br><span class="line">```markdown</span><br><span class="line">id            | 1</span><br><span class="line">select_type   | SIMPLE</span><br><span class="line">table         | People</span><br><span class="line">partitions    | &lt;null&gt;</span><br><span class="line">type          | ref</span><br><span class="line">possible_keys | last_name</span><br><span class="line">key           | last_name</span><br><span class="line">key_len       | 107</span><br><span class="line">ref           | const,const,const</span><br><span class="line">rows          | 1</span><br><span class="line">filtered      | 100.0</span><br><span class="line">Extra         | &lt;null&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这里的 type 为 ref, <strong>ref 表示使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录</strong>，常出现在关联查询中</p>
<ul>
<li><p><strong>匹配索引最左前缀</strong><br>  查找所有姓为 <code>Allen</code> 的人，例如 <code>explain select * from People where last_name=&#39;Cuba&#39;\G;</code><br>output:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | ref</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 52</span></span><br><span class="line"><span class="emphasis">ref           | const</span></span><br><span class="line"><span class="emphasis">rows          | 2</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>匹配列前缀</strong><br>  查找只<strong>匹配某一列的值的开头部分</strong>，只使用到了索引的第一列。<br>例如 <code>explain select * from People where last_name like &#39;C%&#39;\G;</code></p>
</li>
</ul>
<p>output:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | range</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 52</span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 2</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | Using index condition</span></span><br></pre></td></tr></table></figure>

<p>这里的 type 为 range, key 为 last_name, <strong>range 表示索引范围扫描，常用语&lt;,&lt;=,&gt;,=&gt;,between, in like 等操作</strong></p>
<ul>
<li><p>匹配范围值<br>  可用于查找姓在 <code>Angelina</code> 和 <code>Julla</code> 之间的人<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select last_name from People</span><br><span class="line">where last_name between &#x27;Angelina&#x27; and &#x27;Julla&#x27;;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | range</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 52</span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 3</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | Using where; Using index</span></span><br></pre></td></tr></table></figure>
<p>这里 key 使用为 last_name, type 为 range 范围查询。</p>
</li>
<li><p><strong>精确匹配某一列并范围匹配另一列, 即第一列全匹配，第二列 first_name 范围匹配</strong><br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and first_name between &#x27;Allen&#x27; and &#x27;zxxx&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | range</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 104</span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 2</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | Using index condition</span></span><br></pre></td></tr></table></figure>
<p>这里索引用到了 last_name, type 为 range 范围查询。</p>
</li>
<li><p><strong>只访问索引的查询</strong><br>B-Tree 通常可以支持 “只访问索引的查询”，即查询只需要访问索引，无需访问数据行。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select last_name from People</span><br><span class="line">where last_name=&#x27;Allen&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>索引也可以用到 order by 排序操作，order by 子句满足前面列出的几种查询类型。</p>
</li>
</ul>
<h2 id="B-Tree-索引的限制"><a href="#B-Tree-索引的限制" class="headerlink" title="B-Tree 索引的限制"></a>B-Tree 索引的限制</h2><ul>
<li><strong>需要满足最左原则</strong>，即若不是按照索引的最左列开始查找的话，无法使用索引；<br>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where first_name=&#x27;Allen&#x27;\G;</span><br><span class="line"></span><br><span class="line">explain select * from People</span><br><span class="line">where dob=&#x27;1960-01-01&#x27;\G;</span><br></pre></td></tr></table></figure>
output:<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | ALL</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span><br><span class="line">key           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span><br><span class="line">key<span class="emphasis">_len       | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 7</span></span><br><span class="line"><span class="emphasis">filtered      | 14.29</span></span><br><span class="line"><span class="emphasis">Extra         | Using where</span></span><br></pre></td></tr></table></figure></li>
<li>不能跳过索引中的列。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and dob=&#x27;1960-01-01&#x27;\G;</span><br></pre></td></tr></table></figure>
output:<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | ref</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 52</span></span><br><span class="line"><span class="emphasis">ref           | const</span></span><br><span class="line"><span class="emphasis">rows          | 2</span></span><br><span class="line"><span class="emphasis">filtered      | 14.29</span></span><br><span class="line"><span class="emphasis">Extra         | Using index condition</span></span><br></pre></td></tr></table></figure>
这样只是使用到了索引 <code>last_name</code>，<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and first_name=&#x27;Allen&#x27; and dob=&#x27;1960-01-01&#x27;\G;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | ref</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 107</span></span><br><span class="line"><span class="emphasis">ref           | const,const,const</span></span><br><span class="line"><span class="emphasis">rows          | 1</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>
<p>通过 ref 的 <code>const, const, const</code> 可以知道，前者只用到了 <code>last_name</code> index，而后者都用到了<br>这里可以看到 type 类型为 ALL 表示全表扫描；</p>
<ul>
<li>若查询中有<strong>某个列的范围查询，则右边所有列都无法使用索引优化查找</strong>。<br>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and first_name like &#x27;A%&#x27; and dob=&#x27;1960-01-01&#x27;\G;</span><br></pre></td></tr></table></figure>
output:<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | range</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 107</span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 1</span></span><br><span class="line"><span class="emphasis">filtered      | 14.29</span></span><br><span class="line"><span class="emphasis">Extra         | Using index condition</span></span><br></pre></td></tr></table></figure>
<h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1></li>
<li><strong>索引大大减少了服务器需要扫描的数据量</strong></li>
<li><strong>索引可以帮助服务器避免排序和临时表</strong></li>
<li>索引可以将随机 I/O 变为顺序 I/O</li>
<li>索引对于 InnoDB (对索引支持行级锁) 非常重要，因为它可以让查询锁更少的元祖。<br>在 MySQL 5.1 和更新的版本中，InnoDB 可以在服务器端过滤掉行后就释放锁，但在早期的 MySQL 版本中，InnoDB 直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。<br>InnoDB 仅对需要访问的元组加锁，而<strong>索引能够减少 InnoDB 访问的元组数</strong>。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。</li>
<li>关于 InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但是访问主键索引需要排他锁（写锁）</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li><strong>由于索引的存在，在进行`INSERT、UPDATE、DELETE 时，需要进行数据的更新修改，会降低更新表的速度</strong>。MySQL 不仅要保存数据，还要保存索引文件。</li>
<li><strong>建立索引会占用磁盘空间的索引文件。当数据量比较大的表及组合索引较多时，索引文件会膨胀的很快</strong></li>
<li>如果某个数据列包含许多重复的内容，建立索引就没有实际效果。</li>
<li>对于数据量非常小的表，全表扫描更高效。</li>
</ul>
<p>综上：建立一个<code>好</code>的索引是非常考究的，需要根据业务和实际场景不断的优化。</p>
<h1 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h1><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>这类索引是最基本的索引，普通索引的唯一任务就是加快对数据的访问速度。<br>这类索引应该只为最经常出现在查询条件（where column = ）或 排序条件（order by column）中的数据列创建索引。</p>
<ul>
<li>创建<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column)</span><br></pre></td></tr></table></figure>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2>普通索引允许被索引的数据列包含重复的值，而唯一索引列的值必须唯一，但允许有空值如果是组合索引，则列值的组合必须唯一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX idx_xxx ON my_table (column)</span><br></pre></td></tr></table></figure>

<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>它是一种特殊的唯一索引，不允许有空值。一个表只能有一个主键。</p>
<p>一般在创建主键的时候，会同时创建。</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>组合索引也可称为联合索引，为表的多个列创建索引；<br>为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE my_table ADD INDEX idx_name_city_age (name, city, age)</span><br></pre></td></tr></table></figure>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：<br><code>username, city, age</code><br><code>username, city</code><br><code>username</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>「 高性能的索引 」</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 MySQL 索引采用 B+ 树实现？</title>
    <url>/posts/a165b642/</url>
    <content><![CDATA[<h1 id="MySQL-索引的数据结构——-B-树"><a href="#MySQL-索引的数据结构——-B-树" class="headerlink" title="MySQL 索引的数据结构—— B+ 树"></a>MySQL 索引的数据结构—— B+ 树</h1><blockquote>
<p>数据库索引是如何实现的？底层使用的是什么数据结构和算法呢？</p>
</blockquote>
<p>对于数据来说，需要进行常用的一些<strong>查询操作</strong>，例如：</p>
<ul>
<li>根据某个值查找数据，比如 select * from user where id=1;</li>
<li>根据区间查找数据，例如 select * from user where id &gt; 1 and id &lt; 10;</li>
<li>排序，select * from user order by age;</li>
</ul>
<p>还有一些非功能需求，例如：安全、性能、用户体验等等；</p>
<p>对于非功能性需求，我们着重考虑性能方面的需求：<strong>执行效率和存储</strong>；</p>
<h3 id="对比常用的数据结构"><a href="#对比常用的数据结构" class="headerlink" title="对比常用的数据结构"></a>对比常用的数据结构</h3><ul>
<li><p><del>散列表</del></p>
<p><del>散列表的查询性能很好，时间复杂度是 O(1)，但是散列表不能支持按照区间快速查找数据。</del></p>
</li>
<li><p><del>平衡二叉树</del></p>
<p>查询性能较高，时间复杂度为 O(logn)，但是仍然不足以支持按照区间快速查找数据</p>
</li>
<li><p>跳表</p>
<p>查询的时间复杂度为 O(logn)，并且跳表也支持按照区间快速地查找数据。我们只需要定位区间的起点值对应在链表中的节点，然后从这个节点开始，顺序遍历链表，直到结束。</p>
</li>
</ul>
<p><strong>根据分析，跳表是可以满足部分需求的。</strong></p>
<p>实际上，数据库索引所使用到的数据结构和跳表非常相似，叫做 B+ 树。只不过它是通过二叉查找树演化过来的，而非跳表。</p>
<h3 id="二叉树的改造——B-树过程"><a href="#二叉树的改造——B-树过程" class="headerlink" title="二叉树的改造——B+树过程"></a>二叉树的改造——B+树过程</h3><ul>
<li><p>支持范围查询</p>
<p>子节点只存储索引，数据存储在叶子节点</p>
</li>
<li><p>索引的存储问题</p>
<ul>
<li>时间换空间思想，存储在磁盘中</li>
</ul>
</li>
<li><p>减少了磁盘 IO </p>
<ul>
<li>使用多叉树，降低树的高度，减少磁盘 IO</li>
</ul>
</li>
<li><p>增/删数据的方法</p>
<ul>
<li>节点分裂/节点阈值管理</li>
</ul>
</li>
</ul>
<p>前面的分析可以知道二叉树的查找过程只能对单个数据的查找，并不能按照区间进行查找</p>
<p>我们可以对其进行改造：</p>
<p><strong>树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子结点串在一条链表上，链表中的数据是从大到小有序的。</strong></p>
<img src="https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg?wh=1142*738" alt="img" style="zoom:50%;" />

<p>完成改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当找到某个叶子节点之后，我们再顺着链表往后遍历。</p>
<p>但是当我们需要为几千万、上亿的数据构建索引，若在将索引存储在内存中，会占用大量的内存。</p>
<p>例如：</p>
<blockquote>
<p>比如，我们给以一亿个数据构建二叉查找树索引，那么索引中的节点也大约是 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1 GB 的内存空间，将这么大的数据存储在内存中是不可行的</p>
<p>例如使用时间换空间的思路，我们将索引存储在硬盘中，通常磁盘的访问速度是毫秒级别的，相比内存需要的时间是上万或者几十万倍。</p>
</blockquote>
<p>二叉查找树，经过改造之后，支持区间查找了。当把索引存储在硬盘中时，每个节点的访问相当于一次 磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。</p>
<p><strong>那么优化的关键时减少磁盘 IO 操作数，那么如何降低树的高度呢？</strong><br>我们只需要将树的分叉增多，例如 5 叉树，10 叉树。</p>
<p>对于相同个树的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？多大才是合适的。</p>
<p><strong>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4 KB），这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读取一页的数据，当读取的数据量超过一页时，就会触发多次 IO 操作。所以，当我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作</strong></p>
<img src="https://static001.geekbang.org/resource/image/ea/30/ea4472fd7bb7fa948532c8c8ba334430.jpg?wh=1142*886" alt="img" style="zoom: 50%;" />

<p>虽然索引可以提高数据库的查询效率，但是写入操作会变慢，这是因为：<strong>数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因</strong></p>
<h2 id="数据写入的节点更新"><a href="#数据写入的节点更新" class="headerlink" title="数据写入的节点更新"></a>数据写入的节点更新</h2><p>对于一个 B+ 树来说，m 值是根据页的大小事先计算好的。每个节点最多只能有 m 个子节点。在数据写入过程中，这样就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小。如何解决该问题呢？</p>
<p>当一个数据插入的时候，该页如果已经满了，我们只需要将这个节点分裂成两个节点。但是父节点为了为该节点建立索引，也会出现节点溢出情况，同样，我们也可以将该父节点分裂，采用这种级联反应，一直影响到根节点。</p>
<img src="https://static001.geekbang.org/resource/image/18/e0/1800bc80e1e05b32a042ff6873e6c2e0.jpg?wh=1142*856" alt="img" style="zoom: 50%;" />

<h2 id="数据的删除"><a href="#数据的删除" class="headerlink" title="数据的删除"></a>数据的删除</h2><p>我们在删除某个数据的时候，也要对应地更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。</p>
<p>对于这种情况，我们可以设置一个阈值。在 B+ 树中，这个阈值等于 m/2。如果这个节点的子节点个数小于 m/2，我们就将它和相邻的兄弟节点合并。不过，合并之后节点的子节点个数有可能会超过 m。针对这种情况，可以进行分裂。</p>
<img src="https://static001.geekbang.org/resource/image/17/18/1730e34450dad29f062e76536622c918.jpg?wh=1142*856" alt="img" style="zoom:50%;" />



<h2 id="索引的深度问题"><a href="#索引的深度问题" class="headerlink" title="索引的深度问题"></a>索引的深度问题</h2><p>mysql 深度问题一般从 B+ 树的结构和数据库大小去分析，索引字段占内存大小，指针占内存大小（6Byte）</p>
<ul>
<li>B+ 树非叶子节点存放的都是 key+nest 指针。叶子节点存放数据。</li>
<li>非叶子节点键值数=子节点数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_page_size&#x27;</span><br><span class="line">--&gt; </span><br><span class="line">16384;</span><br></pre></td></tr></table></figure>

<p>mysql 索引中索引页默认大小 16 k；</p>
<p>假设 主键 id 为 bigint 类型：8 bytes</p>
<p>指针大小：6 bytes</p>
<p>已知，B+ 树子节点只存储指针，叶子节点存储数据。</p>
<p>16384/（8+6）= 1170</p>
<p>于是，对于每页来说，可以存储 1170 条数据；</p>
<ul>
<li>则 B+ 树深度和数据库数量的关系：</li>
</ul>
<p>​        1170 <code>**</code> （n-1）<code>*</code> 16</p>
<ul>
<li>深度为 3 ：</li>
</ul>
<p>​        1170 *1170 *16 = 21902400（2千万数据）</p>
<p><strong>所以一般数据库b+深度也就 3-5 层</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/styhm/article/details/109512895">https://blog.csdn.net/styhm/article/details/109512895</a></p>
<p><a href="https://time.geekbang.org/column/article/77830">https://time.geekbang.org/column/article/77830</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊 MySQL 事务</title>
    <url>/posts/26a608fc/</url>
    <content><![CDATA[<h1 id="InnoDB-Architecture"><a href="#InnoDB-Architecture" class="headerlink" title="InnoDB Architecture"></a>InnoDB Architecture</h1><blockquote>
<p>InnoDB 架构</p>
</blockquote>
<img src="/images/InnoDB-Architecture.png" width = "550" height = "500" alt="" align=center />

<h1 id="什么是事务（Transaction）"><a href="#什么是事务（Transaction）" class="headerlink" title="什么是事务（Transaction）"></a>什么是事务（Transaction）</h1><blockquote>
<p><strong>事务（Transaction）是访问和更新数据库的程序执行单元</strong>；是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位。<br>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
</blockquote>
<p>MySQL 中服务器层是不管理事务的，事务是由存储引擎实现的，下文中统一表示为 InnoDB</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><blockquote>
<p>理论上来说，事务有着极其严格的定义，它必须同时满足四个特性：</p>
</blockquote>
<ul>
<li><strong>原子性（Atomicity)</strong><br>事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li>
<li><strong>一致性（consistency）</strong><br>事务应确保数据库的状态从一个一致状态转变为另一个一致状态</li>
<li><strong>隔离型（isolation）</strong><br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li><strong>持久性（durability）</strong><br>已被提交的事务对数据库的修改应该永久保存在数据库中</li>
</ul>
<p>接下来将逐一解释这四个特性：</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><blockquote>
<p>事务是如何实现 ACID 的</p>
</blockquote>
<img src="/images/事务的实现.png" width = "500" height = "300" alt="" align=center />

<p>事务的实现是通过<code>redo log</code> &amp;&amp; <code>undo log</code>, 以及 <code>锁</code>来实现的。</p>
<p>redo log 实现持久化和原子性，undo log 实现一致性，锁实现事务的隔离性。<br>redo log 是恢复提交事务修改的页操作，undo log 是回滚行记录到特定的版本。二者记录的内容也不同，redo log 是物理日志，记录页的物理修改操作，undo log<br>是逻辑日志，根据每行记录进行记录。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote>
<p>原子性表示一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；<br>如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p>
</blockquote>
<h4 id="原子性的实现-undo-log"><a href="#原子性的实现-undo-log" class="headerlink" title="原子性的实现 - undo log"></a>原子性的实现 - undo log</h4><blockquote>
<p>首先，介绍一下各种日志，MySQL 的日志类型有很多种，例如二进制日志、错误日志、查询日志、慢查询日志等<br>在 InnoDB 存储引擎还提供了两种事务日志:</p>
<ul>
<li>redo log (重做日志)</li>
<li>undo log（回滚日志）<br>其中 <strong>redo log 用于保证事务持久性</strong>；<strong>undo log 则是事务原子性和隔离型实现的基础</strong>。</li>
</ul>
</blockquote>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><blockquote>
<p>一致性是指事务将数据库从一种一致性状态转变为下一种一致性状态。在事务开始之前和之后，数据库的完整性约束没有被破坏。</p>
</blockquote>
<h4 id="一致性事务的状态"><a href="#一致性事务的状态" class="headerlink" title="一致性事务的状态"></a>一致性事务的状态</h4><blockquote>
<p>因为事务是原子性的，所以从整体上来看的话，事务是密不可分的一个整体那么就可以将事务分状态看：</p>
<ul>
<li>Active(执行中)</li>
<li>Commited（执行成功，已提交）</li>
<li>Failed（执行失败）</li>
</ul>
</blockquote>
<img src="/images/trasaction.png" width = "300" height = "150" alt="" align=center />


<p>但是如果放大来看的话，事务也分为多个中间态。</p>
<img src="/images/trasaction-midware.png" width = "400" height = "250" alt="" align=center />

<ul>
<li>Active: 事务的初始状态，表示事务正在执行；</li>
<li>Partially Commited:  在最后一条语句执行之后；</li>
<li>Failed: 发现事务无法正常执行之后；</li>
<li>Aborted: 事务被回滚并且数据库恢复到了事务进行之前的状态之后；</li>
<li>Commited: 成功执行整个事务；</li>
</ul>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><blockquote>
<p>通过以上的介绍，我们知道 redo log 是实现事务的<code>原子性</code>和<code>持久性</code>。redo log 由两部分组成：</p>
<ul>
<li>内存中的日志缓存(redo log buffer)</li>
<li>重做日志文件(redo log file)</li>
</ul>
</blockquote>
<h4 id="redo-log-的更新流程"><a href="#redo-log-的更新流程" class="headerlink" title="redo log 的更新流程"></a>redo log 的更新流程</h4><p>以一次 update 例子：<br><img src="/images/redo-log.png" width = "600" height = "450" alt="" align=center /></p>
<ul>
<li>update 操作</li>
<li>先将原始数据从磁盘中读取到内存，修改内存中的数据</li>
<li>生成一条重做日志写入 redo log buffer, 记录数据被修改后的值</li>
<li>当事务提交时，需要将 redo log buffer 中的内容刷新到 redo log file</li>
<li>事务提交后，将内存中修改的数据写入磁盘中</li>
</ul>
<p>为了确保每次日志都写入重做日志文件，InnoDB 存储引擎会调用一次 fsync 操作</p>
<h4 id="redo-log-存储格式内容"><a href="#redo-log-存储格式内容" class="headerlink" title="redo log 存储格式内容"></a>redo log 存储格式内容</h4><p>首先比较一下 binlog 二进制日志，binlog 主要是主从复制和进行 POINT-IN-TIME 的恢复</p>
<p>binlog 只有在<strong>事务提交的时候</strong>才会写入，且是<strong>数据库的上层中</strong>产生的。redo log 是 Innodb 引擎层产生的。</p>
<img src="/images/redo log 日志格式.png" width = "300" height = "200" alt="" align=center />

<p>binlog 日志是每次事务才会写入，所以每个事务只会有一条日志，记录的是 SQL 语句</p>
<p>redo log 是事务开始就会写入，*T1 表示事务提交。记录的是物理格式日志，即每个页的修改</p>
<p>redo log 默认是以 block(块)的方式为单位进行存储，每个块是 512 个字节。不同的数据库引擎有对应的重做日志格式，Innodb 的存储管理是基于页的，所以其重做日志也是基于页的</p>
<img src="/images/redo-log-structure.png" width = "300" height = "70" alt="" align=center />

<ul>
<li>redo_log_type 重做日志类型</li>
<li>space 表空间的 ID</li>
<li>page_no 页的偏移量</li>
<li>redo_log_body 存储内容</li>
</ul>
<p>当我们执行插入语句时，日志内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO user values (1,2,3,43);</span><br><span class="line"></span><br><span class="line">page(2,3), offset 32, value 1,2,3,43 # 主键索引</span><br><span class="line">page(2,4), offset 64, value 2 # 辅助索引</span><br></pre></td></tr></table></figure>

<p>那么 redo log 为什么可以实现事务的原子性和持久性呢？</p>
<ul>
<li>原子性，<strong>redo log 记录了事务期间操作的物理日志</strong>，事务提交之前，并没有写入磁盘，保存在内存中，如果事务失败，数据库磁盘将不会发生改变，回滚掉内存部分的数据即可</li>
<li>持久性，<strong>redo log 会在事务提交时将日志存储到磁盘 redo log file, 保证日志的持久性</strong>。</li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><h4 id="什么是-undo-log"><a href="#什么是-undo-log" class="headerlink" title="什么是 undo log"></a>什么是 <code>undo log</code></h4><blockquote>
<p>undo log 则是事务<code>原子性</code>和<code>隔离性</code>实现的基础。<br>重做日志记录了事务的行为，可以友好地通过其对页进行<strong>重做</strong>操作。<br>当发生事务性操作的时候，InnoDB 就会产生一定量的 undo log。当<strong>回滚</strong>或者<strong>事务执行失败</strong>的情况发生的时候，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。<br>undo log 是采用段（segment）的记录方式来记录的，每个 undo 操作在记录的时候占用一个 undo log segment</p>
</blockquote>
<p><strong>由于 undo log 属于逻辑日志，不能物理地将数据库恢复成执行语句或者事务之前的样子。</strong><br>所有的修改操作都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p>
<p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的任务就是协调对数据记录的并发访问。<br><strong>对于表空间而言，并不会修改成之前的样子。</strong></p>
<h4 id="undo-log-是如何恢复数据的？"><a href="#undo-log-是如何恢复数据的？" class="headerlink" title="undo log 是如何恢复数据的？"></a>undo log 是如何恢复数据的？</h4><p>undo log 属于<strong>逻辑日志</strong>，它记录的是 sql 执行相关的信息, 当用户执行 ROLLBACK 时</p>
<ul>
<li><strong>对于每个<code>insert</code>,记录<code>delete</code>;</strong></li>
<li><strong>对于每个<code>delete</code>,记录<code>insert</code>;</strong></li>
<li><strong>对于每个<code>update</code>,记录之前的<code>update</code>;</strong></li>
</ul>
<p>通过以上的操作便可实现<strong>回滚</strong>。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><blockquote>
<p>事务的隔离级别是通过锁来实现</p>
</blockquote>
<p>四种隔离级别分别是, 从低到高：</p>
<ul>
<li>READ-UNCOMMITTED（读取未提交）</li>
<li>READ-COMMITTED（读取已提交）</li>
<li>REPEATABLE-READ（可重复读）</li>
<li>SERIALIZABLE（可串行化）</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>Mysql 默认采用的 <strong>REPEATABLE_READ</strong> 隔离级别</p>
<h4 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h4><ul>
<li>脏读（Dirty Read）:<br>读取到了错误的数据，A 事务执行 update 操作，B 事务执行查询获取结果，此时 A 事务 RollBack 导致读取数据不正确。</li>
<li>不可重复读（Non-repeatable read）:<br>在一个事务的两次查询之中数据不一致，这可能是<strong>两次查询过程中间插入了一个事务更新的原有的数据</strong>。</li>
<li>幻读（Phantom Read）:<br><strong>一个事务的两次查询中夹杂着插入事务的操作，数据量不一致</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解事务的特性，原子性，一致性，持久性，隔离性，可以在使用中，更好的定位到问题，更好的设计业务系统。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>GIL 解释及探究</title>
    <url>/posts/723b604d/</url>
    <content><![CDATA[<h1 id="什么是-GIL-？"><a href="#什么是-GIL-？" class="headerlink" title="什么是 GIL ？"></a>什么是 GIL ？</h1><p>GIL，全称 <code>Global Interpreter Lock</code>, 即<code>全局解释器锁</code>, 它的官方解释如下：</p>
<blockquote>
<p>In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
</blockquote>
<blockquote>
<p>在 CPython 解释器中，全局解释器锁 GIL 是在于执行 Python 字节码时，为了保护访问 Python 对象而阻止多个线程执行的一把互斥锁。<br>这把锁的存在主要是因为 CPython 解释器的内存管理不是线程安全的。然而直到今天 GIL 依旧存在，现在很多功能已经习惯于依赖它作为执行的保证。</p>
</blockquote>
<ul>
<li>GIL 是存在于 CPython 解释器中的，属于解释器层级，而并非属于 Python 的语言特性。也就是说，如果你自己有能力<br>实现一个 Python 解释器，完全可以不用 GIL。</li>
<li>GIL 是为了让解释器在执行 Python 代码时，同一时刻只有一个线程在运行，以此保证<code>内存管理是安全</code>的</li>
<li>历史原因，现在很多 Python 项目已经习惯于依赖 GIL (开发者认为 Python 就是线程安全的，写代码时对共享资源的访问不会加锁)</li>
</ul>
<p>常见的 Python 解释器还有：</p>
<ul>
<li>CPython</li>
<li>IPython</li>
<li>PyPy: 目标是加快执行速度，采用 JIT 技术，对 Python 代码进行动态编译，可以显著提高代码的执行速度。</li>
<li>Jpython: 运行在 Java 平台的 Python 解释器，可以把 Python 编译为 Java 字节码</li>
<li>IronPython: .Net 平台</li>
</ul>
<h2 id="GIL-带来的问题"><a href="#GIL-带来的问题" class="headerlink" title="GIL 带来的问题"></a>GIL 带来的问题</h2><p>一个 Python 线程想要执行一段代码，必须先拿到 <code>GIL 锁</code>后才被允许执行，也就是说，即使我们使用了多线程，但同一时刻却只有一个线程在执行。</p>
<h2 id="GIL-原理"><a href="#GIL-原理" class="headerlink" title="GIL 原理"></a>GIL 原理</h2><p>其实，由于 <strong>Python 的线程就是 C 语言的 pthread</strong>, 它是通过操作系统调度算法调度执行的。</p>
<p>python3.x 进行了优化，<strong>基于固定时间的调度方式，就是每执行固定时间的字节码，或者遇到系统 IO 时，强制释放</strong><br>GIL，触发系统的线程调度。</p>
<p>而在python3.x中，<strong>GIL不使用 ticks 计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），</strong><br>这样对<strong>CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题</strong>，所以效率依然不尽如人意。</p>
<p><strong>多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，<br>但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低</strong></p>
<p>而线程在调度时，又依赖系统的 CPU 环境，也就是在单核 CPU 或者多核 CPU 下，多线程在调度切换时的成本是不同的。</p>
<p>如果多线程运行一个 <code>CPU 密集型任务</code>，那么 Python 多线程是无法提高运行效率的。</p>
<p>如果需要运行 IO 密集型任务，Python 多线程是可以提高运行效率的。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>IO 密集型任务场景，可以使用多线程提高运行效率</li>
<li>CPU 密集型任务场景，不使用多线程，推荐使用多进程方式部署运行</li>
<li>更换没有 GIL 的 Python 解释器，需要预评估运行结果是否与 CPython 一致</li>
<li>编写 Python 的 C 扩展模块，将 CPU 密集型任务交给 C 模块处理。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 内存管理，垃圾回收，缓存重用机制</title>
    <url>/posts/ec5b3295/</url>
    <content><![CDATA[<h2 id="详谈-python-的内存管理"><a href="#详谈-python-的内存管理" class="headerlink" title="详谈 python 的内存管理"></a>详谈 python 的内存管理</h2><blockquote>
<p>python 作为一门高级语言，调用相关变量时，无需实现声明，变量无需指定类型，python 解释器会自动帮你回收，这一切都由<br><code>python 内存管理器</code>承担了复杂的内存管理工作。<br>这里主要介绍基于 Cpython 实现的内存管理</p>
</blockquote>
<blockquote>
<p>python 内存管理机制 —— Pymalloc</p>
</blockquote>
<h3 id="主要实现方式"><a href="#主要实现方式" class="headerlink" title="主要实现方式"></a>主要实现方式</h3><ul>
<li>针对<code>小对象</code>, 就是对象大小小于<code>256kb</code>时，pymalloc 会在<code>内存池中申请内存空间</code></li>
<li>针对<code>大对象</code>, 对象大小<code>大于 256kb</code>时，会执行<code>new/malloc 行为</code>来申请新的内存空间</li>
</ul>
<h3 id="python-内存池（memory-pool）"><a href="#python-内存池（memory-pool）" class="headerlink" title="python 内存池（memory pool）"></a>python 内存池（memory pool）</h3><blockquote>
<p>为什么要引入内存池？<br>当创建大量消耗小内存的对象时，频繁调用<code>new/malloc</code>会导致大量的内存碎片，导致效率降低</p>
</blockquote>
<ul>
<li><code>内存池的作用就是预先在内存中申请一定数量的，大小相等的内存块（256kb）留作备用</code>，当有新的内存需求时，就优先从内存池中分配给这个需求。</li>
<li>减少内存碎片化，提升效率</li>
</ul>
<img src="/images/python 内存池.png" width = "600" height = "700" alt="" align=center />

<ul>
<li><p>python 的对象管理主要位于 Level + 1 ~ Level +3 层</p>
</li>
<li><p>Level 3: 该层特定对象内存分配器，主要是 <code>python 内置的对象（int, dict, arr）</code>都有独立的私有内存池，对象<br>之间的内存池不共享，例如 <code>int</code> 释放的内存，不会被分配给 <code>float</code>使用。</p>
</li>
<li><p>Level 2: python 对象分配器：当申请的<code>内存大小小于256KB</code>时，内存对象的分配主要由<code>Python 对象</code> 分配器（python’s object allocator）实施</p>
</li>
<li><p>Level 1: python 内存分配器：当申请的<code>内存大小大于256KB</code>时，由 Python 原生的内存分配器进行分配，本质上是调用 C 标准库中的 malloc/readlloc 等函数</p>
</li>
</ul>
<h3 id="内存池的内存释放"><a href="#内存池的内存释放" class="headerlink" title="内存池的内存释放"></a>内存池的内存释放</h3><blockquote>
<p>内存释放，当一个对象的引用计算变为 0 时，Python 就会调用它的析构函数（__del__）。调用析构函数并不意味着最终一定会调用<br>free 来释放内存空间，会导致频繁申请、释放内存空间使得 Python 的执行效率大打折扣。因此在析构时也采用了内存池机制，内存池申请到的内存会被归还到内存池中，<br>以免频繁地申请和释放动作</p>
</blockquote>
<p>接下来就会讲到 Python 的垃圾回收机制。</p>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><blockquote>
<p>如果别人问你，什么是 Python 的垃圾回收机制，你可以用一句话概括<br><strong>Python 的垃圾回收机制采用`引用计数为主，标记-清除和分代回收为辅的策略</strong></p>
</blockquote>
<p>Python 一切皆为对象，包括 int、str 等等基本的对象。Cpython 的实现中，有一个结构体为 PyObject, Cpython 中的每个其他对象都在使用它</p>
<p>PyObject 是 Python 中所有对象的祖父，它只包含两件事：</p>
<ul>
<li>ob_refcnt: 引用计数器</li>
<li>ob_type: 指向另一种类型的指针</li>
</ul>
<p>对于对象来说，无非是对象的创建和删除</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><blockquote>
<p>每个对象都会维护一个 <code>ob_refcnt</code> 来记录当前对象被引用的次数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">a = [<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))</span><br><span class="line"><span class="comment"># OUTPUT getrefcount 会增加一次引用</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象引用计数 +1</p>
<ul>
<li><ol>
<li>对象被创建 <code>a=1</code></li>
</ol>
</li>
<li><ol start="2">
<li>对象被引用 <code>a=b</code></li>
</ol>
</li>
<li><ol start="3">
<li>对象被作为参数，传入函数中 def count(a, b)</li>
</ol>
</li>
<li><ol start="4">
<li>对象作为一个元素被存储 <code>li = [1,2, a]</code></li>
</ol>
</li>
</ul>
</li>
<li><p>对象的引用计数 -1</p>
<ul>
<li><ol>
<li>对象的引用被显示销毁时，<code>del a</code></li>
</ol>
</li>
<li><ol start="2">
<li>对象的引用别名被赋予新的对象, <code>a=26</code></li>
</ol>
</li>
<li><ol start="3">
<li>一个对象离开它的作用域, 例如一个函数执行完成后，内部的<code>局部变量的引用计数器就会减一</code>(全局变量不变)</li>
</ol>
</li>
<li><ol start="4">
<li>将该元素从容器中删除时，或者容器被销毁</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>当指向对象的内存的引用计数为 0 时，该内存就会被 Python 虚拟机销毁</strong></p>
<p>特性：</p>
<blockquote>
<p>优点：1. 高效。2。 实时性，一旦没有引用，内存就直接释放了。3. 对象有确定的生命周期 4. 易于实现<br>缺点：1. 维护引用计数消耗资源。2. 无法解决循环引用问题</p>
</blockquote>
<h2 id="为什么要使用标记清除"><a href="#为什么要使用标记清除" class="headerlink" title="为什么要使用标记清除"></a>为什么要使用标记清除</h2><p>标记清除算法作为Python的辅助垃圾收集技术，主要处理的是一些容器对象，比如list、dict、tuple等，因为对于字符串、数值对象是不可能造成循环引用问题。</p>
<blockquote>
<p>对于一个对象来说，当出现循环引用的时候，例如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = []</span><br><span class="line">a.append(b)</span><br><span class="line">b.append(a)</span><br></pre></td></tr></table></figure>
<p>的时候，就出现了循环引用的情况，这样该对象的引用计数<br>的值都会是 1 而不是 0，那么垃圾回收的机制就会失效，针对这种情况，又出现了标记清除的功能来解决循环引用的问题。</p>
<h3 id="什么是标记清除？"><a href="#什么是标记清除？" class="headerlink" title="什么是标记清除？"></a>什么是标记清除？</h3><blockquote>
<p>[标记清除（Mark-Sweep）] 算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。主要针对一些容器对象，例如<code>list</code>、<code>dict</code>、<code>tuple</code><br>对于字符串和数值对象是不可能造成循环引用的问题的（不可变对象，当出现引用时，会另外开辟空间存储，这个在缓存机制中会详细解释）。</p>
</blockquote>
<p>那么<code>标记清除</code>算法是如何运行的？<br>分为两个阶段：</p>
<ul>
<li><ol>
<li>第一阶段是标记阶段，GC 会把所有的[活动对象]打上标记。</li>
</ol>
</li>
<li><ol start="2">
<li>第二阶段是把那些没有标记的[非活动对象]进行回收。</li>
</ol>
</li>
</ul>
<p>活动对象和非活动对象的标记：<br>对象之间通过引用（指针）连在一起，构成一个有相图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。<br>从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。<br>根对象就是全局变量、调用栈、寄存器。</p>
<img src="/images/有向图.png" width = "400" height = "200" alt="" align=center />

<p>从以上的有向图中：</p>
<ul>
<li>活动对象：A, B, C</li>
<li>非活动对象：D, E</li>
</ul>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><blockquote>
<p>在标记清除对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过<strong>分代回收（Generational Conlletion）</strong>以空间换时间的方法提高垃圾回收效率</p>
</blockquote>
<p>Python 将所有对象分为：</p>
<ul>
<li>年轻代（第 0 代）</li>
<li>中年代（第 1 代）</li>
<li>老年代（第 2 代）</li>
</ul>
<p>所有新建的对象默认是第 0 代对象，经过 GC 扫描存活下来的对象将被移至第一代，在第一代的 GC 扫描中存活下来的对象将被移至第二代。</p>
<blockquote>
<p>GC 扫描次数 (第 0 代 &gt; 第 1 代 &gt; 第 2 代)</p>
</blockquote>
<h3 id="GC-分代回收是如何触发的？"><a href="#GC-分代回收是如何触发的？" class="headerlink" title="GC 分代回收是如何触发的？"></a>GC 分代回收是如何触发的？</h3><blockquote>
<p>当某个世代中被分配的对象与被释放的对象数量之差到达某一个阈值时，就会触发当前一代的 GC 扫描。<br>当某一世代被扫描时，比它年轻的一代也会被扫描<br>当第 2 代的 GC 扫描发生时，第 0，1 代的 GC 扫描也会发生，即为全代扫描。</p>
</blockquote>
<p>那么这个阈值是如何确定的?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc </span><br><span class="line">gc.get_threshold() <span class="comment">## 分代回收机制的参数阈值设置</span></span><br><span class="line"><span class="comment"># (700, 10, 10)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>700=新分配的对象数量-释放的对象数量，第 0 代 gc 扫描被触发</li>
<li>第一个10：第 0 代 gc 扫描发生 10 次，则第 1 代的 gc 扫描被触发</li>
<li>第二个10：第 1 代的 gc 扫描发生 10 次，则第 2 代的 gc 扫描被触发</li>
</ul>
<h1 id="Python-的缓存重用机制"><a href="#Python-的缓存重用机制" class="headerlink" title="Python 的缓存重用机制"></a>Python 的缓存重用机制</h1><blockquote>
<p>Python 缓存重用机制是为了提高程序执行的效率。Python 解释器启动时从内存空间中开辟出一小部分，用来存储高频使用的数据，这样可以大大减少高频使用的<br>数据创建时申请内存和销毁的开销</p>
</blockquote>
<img src="/images/缓存重用机制.png" width = "600" height = "300" alt="" align=center />

<p>这里基本演示，更加详细的演示，读者可以自行尝试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#范围在 [-5, 256] 之间的小整数</span></span><br><span class="line">int1 = -<span class="number">5</span></span><br><span class="line">int2 = -<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[-5, 256] 情况下的两个变量：&quot;</span>, <span class="built_in">id</span>(int1), <span class="built_in">id</span>(int2))</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#bool类型</span></span><br><span class="line">bool1 = <span class="literal">True</span></span><br><span class="line">bool2 = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bool类型情况下的两个变量：&quot;</span>,<span class="built_in">id</span>(bool1),<span class="built_in">id</span>(bool2))</span><br><span class="line"><span class="comment">#对于字符串</span></span><br><span class="line">s1 = <span class="string">&quot;3344&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;3344&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串情况下的两个交量&quot;</span>, <span class="built_in">id</span>(s1), <span class="built_in">id</span>(s2))</span><br><span class="line"><span class="comment">#大于 256 的整数</span></span><br><span class="line">int3 = <span class="number">257</span></span><br><span class="line">int4 = <span class="number">257</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;大于 256 的整数情况下的两个变量&quot;</span>, <span class="built_in">id</span>(int3), <span class="built_in">id</span>(int4))</span><br><span class="line"><span class="comment">#大于 0 的浮点数</span></span><br><span class="line">f1 = <span class="number">256.4</span></span><br><span class="line">f2 = <span class="number">256.4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;大于 0 的浮点数情况下的两个变量&quot;</span>, <span class="built_in">id</span>(f1), <span class="built_in">id</span>(f2))</span><br><span class="line"><span class="comment">#小于 0 的浮点数</span></span><br><span class="line">f3 = -<span class="number">2.45</span></span><br><span class="line">f4 = -<span class="number">2.45</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于 0 的浮点数情况下的两个变量&quot;</span>, <span class="built_in">id</span>(f3), <span class="built_in">id</span>(f4))</span><br><span class="line"><span class="comment">#小于 -5 的整数</span></span><br><span class="line">n1 = -<span class="number">6</span></span><br><span class="line">n2 = -<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于 -5 的整数情况下的两个变量&quot;</span>, <span class="built_in">id</span>(n1), <span class="built_in">id</span>(n2))</span><br></pre></td></tr></table></figure>
<p>OUTPUT:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[-5, 256] 情况下的两个变量： 4479762592 4479762592</span><br><span class="line">bool类型情况下的两个变量： 4479360112 4479360112</span><br><span class="line">字符串情况下的两个交量 140680232254768 140680232254768</span><br><span class="line">大于 256 的整数情况下的两个变量 140680231657872 140680231657872</span><br><span class="line">大于 0 的浮点数情况下的两个变量 140680231658256 140680231658256</span><br><span class="line">小于 0 的浮点数情况下的两个变量 140680191914768 140680191914768</span><br><span class="line">小于 -5 的整数情况下的两个变量 140680232617328 140680232617328</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>对于<code>int</code>, <code>str</code>,<code>bool</code> 类型而言：<ol>
<li>对于同一个对象，都是缓存同一个内容来使用</li>
</ol>
</li>
<li>对于<code>大于 256 的整数</code>, 浮点数<ol>
<li>如果位于同一代码块，则使用相同的缓存内容；反之，则不使用</li>
</ol>
</li>
<li>对于 <code>小于 0 的整数</code><ol>
<li>Python 没有对其进行缓存操作</li>
</ol>
</li>
</ul>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在 Python 中，主要通过 <code>引用计数</code>来进行垃圾回收；通过<code>标记-清除</code>来解决一些容器对象的循环引用问题；<br>通过<code>分代回收</code>以空间换时间的方式提高垃圾回收效率。</p>
<p>缓存重用机制，作用类似于内存池，提高 Python 的执行效率</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>「 python 垃圾回收机制 」- <a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/">https://andrewpqc.github.io/2018/10/08/python-memory-management/</a><br>「 python GC 源代码 」- <a href="https://docs.python.org/2/library/gc.html">https://docs.python.org/2/library/gc.html</a><br>「 python 垃圾回收需要知道事 」- <a href="https://rushter.com/blog/python-garbage-collector/">https://rushter.com/blog/python-garbage-collector/</a> </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 如何实现装饰器？</title>
    <url>/posts/e67a2035/</url>
    <content><![CDATA[<h1 id="Python-如何实现一个装饰器"><a href="#Python-如何实现一个装饰器" class="headerlink" title="Python 如何实现一个装饰器"></a>Python 如何实现一个装饰器</h1><blockquote>
<p>首先，装饰器为调用高阶函数提供了一种简单的语法<br>根据定义，装饰器是一个函数，它接受另外一个函数并在其基础功能上做统一的扩展</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>对于 Python 来说，一切皆对象，对象也是可以作为参数传递，这就是装饰器实现的基础</p>
</blockquote>
<p>例如，我想实现一个<code>日志打印</code>功能，调用对应方法或者对象时，可以显示其运行的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">    func()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printer(task)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们实现了<code>task</code> 方法，在调用这个方法的时候，会显示调用的相关信息。</p>
<p>可以看到我们使用<code>printer</code> 这个功能的时候，都是采用<code>printer(func)</code>的方式，如果在多处使用的话，<br>那么有没有比较简单的方式，例如在执行<code>task</code>方法的时候，自动去触发<code>printer</code>呢，还能像调用原方法一样？</p>
<p>于是, 我们可以将该方法当成一个参数传递后，返回一个新的对象调用的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run&quot;</span>)</span><br><span class="line"></span><br><span class="line">task = printer(task)</span><br><span class="line">task()</span><br></pre></td></tr></table></figure>

<p>Python 中<code>允许在一个方法中嵌套另外一个方法</code>，这种特殊的机制就是<strong>闭包</strong>。<br>这个内部方法可以保留外部方法的作用域，内部方法也可以访问到外部方法的参数和变量。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><blockquote>
<p>python 支持一种装饰器语法糖「@」，使用这个语法糖，我们也可以实现与上面完全相同的功能</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@printer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><blockquote>
<p>现在我们已经知道，装饰器其实就是先定义好一个闭包，然后使用语法糖<code>@</code>来装饰方法，最后达到重新定义方法的作用<br>但是这样使用的方法其实最终执行的是 <code>inner</code> 方法</p>
</blockquote>
<p>like: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@printer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(task.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: inner</span></span><br></pre></td></tr></table></figure>
<p>如何解决这个问题？</p>
<p>python 其实有内置的 functools 模块，提供了一个 <code>wraps</code> 方法，专门来解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(task.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>装饰器当然也可以传入参数，例如：<code>*args</code>、<code>**kwargs</code><br>例如使用装饰器来计算程序的运行时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">prefix</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s: duration time: %ds&#x27;</span> % (prefix, <span class="built_in">int</span>(end - start)))</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit(<span class="params"><span class="string">&#x27;prefix1&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello %s&#x27;</span> % name)</span><br></pre></td></tr></table></figure>
<h2 id="装饰器模版"><a href="#装饰器模版" class="headerlink" title="装饰器模版"></a>装饰器模版</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<h2 id="类实现装饰器"><a href="#类实现装饰器" class="headerlink" title="类实现装饰器"></a>类实现装饰器</h2><p><code>__call__</code> 魔法方法结合类也可以实现装饰器</p>
<p>这里也给出一个通用模版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, params</span>):</span></span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># do something</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorator(<span class="params"><span class="string">&#x27;params&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="装饰器的使用场景"><a href="#装饰器的使用场景" class="headerlink" title="装饰器的使用场景"></a>装饰器的使用场景</h2><h3 id="记录调用日志"><a href="#记录调用日志" class="headerlink" title="记录调用日志"></a>记录调用日志</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># 记录调用日志</span></span><br><span class="line">            logging.getLogger().setLevel(logging.INFO)</span><br><span class="line">            logging.info(<span class="string">&#x27;call method: %s %s %s&#x27;</span>, func.__name__, args, kwargs)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Logger(<span class="params"><span class="string">&#x27;airflow&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;run <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    task(name=<span class="string">&quot;task&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="路由映射"><a href="#路由映射" class="headerlink" title="路由映射"></a>路由映射</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.url_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">            self.url_map[url] = func</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        func = self.url_map.get(url)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> func:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;No url function: %s&#x27;</span>, url)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router = Router()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.register(<span class="params"><span class="string">&#x27;/page1&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page1</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page1&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(router.call(<span class="string">&#x27;page1&#x27;</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊 greenlet</title>
    <url>/posts/67194a4a/</url>
    <content><![CDATA[<h1 id="聊一聊-greenlet"><a href="#聊一聊-greenlet" class="headerlink" title="聊一聊 greenlet"></a>聊一聊 greenlet</h1><p>在使用 gunicorn 部署项目的时候，了解到很多知名的网络并发框架（gevent, eventlet）都是基于 greenlet 实现的，今天就来学习一下 greenlet 框架的原理和使用</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>这里写一个简单的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">12</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">34</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">56</span>)</span><br><span class="line">    gr1.switch()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">78</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(run_1)</span><br><span class="line">gr2 = greenlet(run_2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gr1.switch()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们定义了两个方法类，并构建了 greenlet 协程。根据结果分析首先 gr1.switch , gr1 被执行，然后 gr2.swith 切换到 gr2 执行，打印 56，最后切换到 gr1， 打印 34，函数 run_1 返回，同时程序退出。于是 78 就不会被打印。</p>
<p>很好理解吧。使用<code>switch()</code>方法切换协程，也比”yield”, “next/send”组合要直观的多。<strong>上例中，我们也可以看出，greenlet协程的运行，其本质是串行的，所以它不是真正意义上的并发，因此也无法发挥CPU多核的优势，不过，这个可以通过协程+进程组合的方式来解决，</strong>本文就不展开了。另外要注意的是，在没有进行显式切换时，部分代码是无法被执行到的，比如上例中的<code>print 78</code>。</p>
<h2 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h2><p>在使用 greenlet 创建一个协程时，其实是有两个参数是可选的 <code>greenlet(run=None, parent=None)</code>。参数 run 就是其要调用的方法，比如上例中的函数 run_1 和 run_2；parent 参数定义该协程的父协程；</p>
<p>参考文档：<a href="https://greenlet.readthedocs.io/en/latest/api.html#greenlets">https://greenlet.readthedocs.io/en/latest/api.html#greenlets</a></p>
<p>parent 参数若不设置或为空，则其父进程就是程序默认的 main 主协程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">12</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">34</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">56</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(run_1)</span><br><span class="line">gr2 = greenlet(run_2, gr1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gr1.switch()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ending&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">56</span><br><span class="line">34</span><br><span class="line">ending</span><br></pre></td></tr></table></figure>



<p>上述代码中，指定了 gr2 的父协程是 gr1，于是当最后切换至 gr2 时，程序并未退出，而是切换到了 gr1 中，打印了 34 ，最后打印 ending…</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>协程是存放在调用栈中，那一个协程要抛出异常，就会先抛到其父协程中，如果所有的父协程都不捕获此异常，程序才会退出。</p>
<p>上代码</p>
<p>既然协程是存放在栈中，那一个协程要抛出异常，就会先抛到其父协程中，如果所有父协程都不捕获此异常，程序才会退出。我们试下，把上面的例子中函数<code>test2()</code>的代码改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="number">56</span></span><br><span class="line">    <span class="keyword">raise</span> NameError</span><br></pre></td></tr></table></figure>

<p>程序执行后，我们可以看到Traceback信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;parent.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">  gr1.switch()</span><br><span class="line">File &quot;parent.py&quot;, line 5, in test1</span><br><span class="line">  gr2.switch()</span><br><span class="line">File &quot;parent.py&quot;, line 10, in test2</span><br><span class="line">  raise NameError</span><br></pre></td></tr></table></figure>

<p>同时大家可以试下，如果将<code>gr2</code>的父协程设为空，Traceback信息就会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;parent.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">  gr1.switch()</span><br><span class="line">File &quot;parent.py&quot;, line 10, in test2</span><br><span class="line">  raise NameError</span><br></pre></td></tr></table></figure>

<p>因此，如果<code>gr2</code>的父协程是<code>gr1</code>的话，异常先回抛到函数<code>test1()</code>的代码<code>gr2.switch()</code>处。所以，我们再对函数<code>test1()</code>改动下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="number">12</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        gr2.switch()</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="built_in">print</span> <span class="number">90</span></span><br><span class="line">    <span class="built_in">print</span> <span class="number">34</span></span><br></pre></td></tr></table></figure>

<p>运行后的结果，如果<code>gr2</code>的父协程是<code>gr1</code>，则异常被捕获，并打印”90”。否则，异常会被抛出。以上实验很好的证明了，子协程抛出的异常会根据栈里的顺序，依次抛到父协程里。</p>
<p>有一个异常是特例，不会被抛到父协程中，那就是<code>greenlet.GreenletExit</code>，这个异常会让当前协程强制退出。比如，我们将函数<code>test2()</code>改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="number">56</span></span><br><span class="line">    <span class="keyword">raise</span> greenlet.GreenletExit</span><br><span class="line">    <span class="built_in">print</span> <span class="number">78</span></span><br></pre></td></tr></table></figure>

<p>那代码行<code>print 78</code>永远不会被执行。但这个异常不会往上抛，所以其父协程还是可以正常运行。</p>
<p>另外，我们可以通过greenlet对象的<code>throw()</code>方法，手动往一个协程里抛个异常。比如，我们在<code>test1()</code>里调一个<code>throw()</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="number">12</span></span><br><span class="line">    gr2.throw(NameError)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        gr2.switch()</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="built_in">print</span> <span class="number">90</span></span><br><span class="line">    <span class="built_in">print</span> <span class="number">34</span></span><br></pre></td></tr></table></figure>

<p>这样，异常就会被抛出，运行后的Trackback是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;exception.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">  gr1.switch()</span><br><span class="line">File &quot;exception.py&quot;, line 5, in test1</span><br><span class="line">  gr2.throw(NameError)</span><br></pre></td></tr></table></figure>

<p>如果将<code>gr2.throw(NameError)</code>放在”try”语句中，那该异常就会被捕获，并打印”90”。另外，当<code>gr2</code>的父协程不是<code>gr1</code>而是”main”时，异常会直接抛到主程序中，此时函数<code>test1()</code>中的”try”语句就不起作用了。</p>
<h2 id="协程间的消息传递"><a href="#协程间的消息传递" class="headerlink" title="协程间的消息传递"></a>协程间的消息传递</h2><p>我们知道生成器是使用 send 方法来传递参数的。greenlet 也同样支持，只要在其 <code>switch()</code> 方法调用时，传入参数即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">12</span>)</span><br><span class="line">    y = gr2.switch(<span class="number">56</span>)</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_2</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    gr1.switch(<span class="number">34</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">78</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(run_1)</span><br><span class="line">gr2 = greenlet(run_2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gr1.switch()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ending&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">56</span><br><span class="line">34</span><br><span class="line">ending</span><br></pre></td></tr></table></figure>



<p>使用协程来构建生产者消费者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    last = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        receival = pro.switch(last)</span><br><span class="line">        <span class="keyword">if</span> receival <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;consumer: <span class="subst">&#123;receival&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">n</span>):</span></span><br><span class="line">    con.switch()</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; n:</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;producer: <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">        con.switch(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pro = greenlet(producer)</span><br><span class="line">con = greenlet(consumer)</span><br><span class="line">pro.switch(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = greenlet(consumer)</span><br><span class="line">    p = greenlet(producer)</span><br><span class="line">    p.switch(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p>github: <a href="https://github.com/python-greenlet/greenlet">https://github.com/python-greenlet/greenlet</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>iter()</title>
    <url>/posts/3a33b362/</url>
    <content><![CDATA[<h1 id="iter-妙用"><a href="#iter-妙用" class="headerlink" title="iter 妙用"></a>iter 妙用</h1><p>refs: <a href="https://www.geeksforgeeks.org/python-iter-method/">https://www.geeksforgeeks.org/python-iter-method/</a></p>
<blockquote>
<p>今天在对文件进行 md5 生成时，考虑到大文件，需要分块读取，查询相关资料后，iter() 方法可以很巧妙的实现</p>
</blockquote>
<h2 id="iter-用法"><a href="#iter-用法" class="headerlink" title="iter 用法"></a>iter 用法</h2><ul>
<li><p>iter(object[, sentinel])</p>
</li>
<li><p>当第二个参数不存在， 第一个参数必须是<strong>支持迭代协议的容器类型对象</strong>，例如字典等， 或者是支持序列协议的序列类型对象，例如列表等，如果都不支持则报错。</p>
</li>
<li><p>当第二个参数存在， 即<strong>哨兵参数</strong>存在，则第一个参数必须是可调用对象，即函数等，以此种方式创建的迭代器对象将会调用object，可调用对象参数调用时不需要参数，<strong>如果可调用对象调用后返回值与哨兵对象值相同， 则会引发 stopiteration ，调用结束。</strong></p>
</li>
</ul>
<h2 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h2><p>sentinel </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;随机生成1-10的整数&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    num=random.randint(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;The random number is <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">random_number=<span class="built_in">iter</span>(get_number,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(random_number,Iterator))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> random_number:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;get number: <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">--&gt;   </span><br><span class="line"><span class="literal">True</span></span><br><span class="line">The random number <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line">get number: <span class="number">2</span></span><br><span class="line">The random number <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line">get number: <span class="number">3</span></span><br><span class="line">The random number <span class="keyword">is</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="分块读取文件"><a href="#分块读取文件" class="headerlink" title="分块读取文件"></a>分块读取文件</h2><p>当读取到 <code>b&#39;&#39;</code> 时，表示文件读取完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_md5</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    get file md5 checksum</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    hash_md5 = hashlib.md5()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> <span class="built_in">iter</span>(<span class="keyword">lambda</span>: f.read(<span class="number">1024</span>), <span class="string">b&#x27;&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(chunk)</span><br><span class="line">            hash_md5.update(chunk)</span><br><span class="line">    <span class="keyword">return</span> hash_md5.hexdigest()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 中的序列协议一览</title>
    <url>/posts/73c8dd96/</url>
    <content><![CDATA[<h1 id="python-中的序列协议一览"><a href="#python-中的序列协议一览" class="headerlink" title="python 中的序列协议一览"></a>python 中的序列协议一览</h1><blockquote>
<p>在Python中，序列（Sequence）是一种基本的数据结构，用于存储一系列有序的元素。序列是Python中最常见的数据类型之一，它包括字符串（String）、列表（List）、元组（Tuple）等。</p>
<p>序列的特点是可以通过索引访问其中的元素，索引从0开始，并且支持切片操作，可以获取序列的子序列。此外，序列还可以进行迭代、拼接、重复、比较等操作。</p>
</blockquote>
<p>在 python 语言中，通过<strong>存储数据的类型</strong>和<strong>是否可变</strong>可以分为以下 4 种序列：</p>
<ul>
<li>容器序列<ul>
<li>list</li>
<li>tuple</li>
<li>deque</li>
</ul>
</li>
<li>扁平序列<ul>
<li>str</li>
<li>bytes</li>
<li>bytearray</li>
<li>arrar.array</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>可变序列<ul>
<li>list</li>
<li>deque</li>
<li>bytearray</li>
<li>array</li>
</ul>
</li>
<li>不可变序列<ul>
<li>str</li>
<li>tuple</li>
<li>bytes</li>
</ul>
</li>
</ul>
<p><strong>那么关于序列这种对象，其序列协议又是如何的，是如何实现的? 带着这个问题，我们来学习一下 python 序列对象</strong></p>
<h2 id="collections-中-Sequence-MutableSequence"><a href="#collections-中-Sequence-MutableSequence" class="headerlink" title="collections 中 Sequence/MutableSequence"></a>collections 中 Sequence/MutableSequence</h2><p><strong>首先，我们来看一下，在 python 中有这样一个库：collections, 其中包含了一些容器类的实现，其中序列包含 Sequence &amp;&amp; MutableSequence, 其基类的实现关系又是如何的？</strong></p>
<p>我们可以通过查看源码的方式来看一下不可变序列的协议：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sequence</span>(<span class="params">Collection[_T_co], Reversible[_T_co], <span class="type">Generic</span>[_T_co]</span>):</span></span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; _T_co:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index: <span class="built_in">slice</span></span>) -&gt; <span class="type">Sequence</span>[_T_co]:</span> ...</span><br><span class="line">    <span class="comment"># Mixin methods</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">self, value: <span class="type">Any</span>, start: <span class="built_in">int</span> = ..., stop: <span class="built_in">int</span> = ...</span>) -&gt; <span class="built_in">int</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self, value: <span class="type">Any</span></span>) -&gt; <span class="built_in">int</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, value: <span class="built_in">object</span></span>) -&gt; <span class="built_in">bool</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>) -&gt; Iterator[_T_co]:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span>(<span class="params">self</span>) -&gt; Iterator[_T_co]:</span> ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutableSequence</span>(<span class="params"><span class="type">Sequence</span>[_T], <span class="type">Generic</span>[_T]</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index: <span class="built_in">int</span>, value: _T</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; _T:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index: <span class="built_in">slice</span></span>) -&gt; MutableSequence[_T]:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, index: <span class="built_in">int</span>, value: _T</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, index: <span class="built_in">slice</span>, value: Iterable[_T]</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, index: <span class="built_in">slice</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="comment"># Mixin methods</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, value: _T</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span>(<span class="params">self, values: Iterable[_T]</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self, index: <span class="built_in">int</span> = ...</span>) -&gt; _T:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, value: _T</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span>(<span class="params">self: TypeshedSelf, values: Iterable[_T]</span>) -&gt; TypeshedSelf:</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>容器对象</li>
</ul>
<p>对于一个不可变序列来说，首先是属于一个<strong>容器对象</strong>，对于容器对象而言，in/not in 是经常判断一个数据是否在这个容器中，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">contains = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> contains:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现这个协议的魔法方法是：<code>__contains__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, value: <span class="built_in">object</span></span>) -&gt; <span class="built_in">bool</span>:</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>不可变对象/可变对象</li>
</ul>
<p>​    sequence 对象是一个不可变对象，那么是如何实现的？</p>
<p>​    答案是 <code>__getitem__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="meta">@abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; _T_co:</span> ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="meta">@abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index: <span class="built_in">slice</span></span>) -&gt; <span class="type">Sequence</span>[_T_co]:</span> ...</span><br></pre></td></tr></table></figure>

<p>我们可以看到 sequence 对象中只实现了 <code>__getitem__</code> 方法，只可获取对象，于是内部数据就是不可变了，不可修改；</p>
<p>而实现了<code>__setitem__</code>&amp;&amp;<code>__delitem__</code> 表示可以对数据进行修改/删除。</p>
<ul>
<li> 可迭代对象</li>
</ul>
<p>  对于一个容器序列，如何获取其中的元素，例如 for … in .. 操作。这是因为实现了 <code>__iter__</code>魔法方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>) -&gt; Iterator[_T_co]:</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>序列的合并</p>
<p>当对两个序列进行合并时，可以使用 +=，例如：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b += a</span><br></pre></td></tr></table></figure>

<p>这个是如何实现的，其实是因为魔法方法 <code>__iadd__</code> 的实现</p>
<p>通过对两个序列类的学习，我们了解了序列类的一些协议，这样我们就可以基于这些知识自己实现一个序列。</p>
<h2 id="可切片的序列类"><a href="#可切片的序列类" class="headerlink" title="可切片的序列类"></a>可切片的序列类</h2><p>我们先通过 list 来了解一下 python 中 slice 的概念：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># a[start:end:step]</span></span><br><span class="line">b = a[:] <span class="comment"># 返回原列表所有数据的引用</span></span><br><span class="line">b = a[::-<span class="number">1</span>] <span class="comment"># 逆序</span></span><br><span class="line">b = a[::<span class="number">2</span>] <span class="comment"># 间隔一个的数据集合，[1, 3, 5]</span></span><br><span class="line">a[:<span class="number">0</span>] = [<span class="number">1</span>, <span class="number">2</span>] <span class="comment"># 在列表头插入数据</span></span><br><span class="line"><span class="keyword">del</span> a[:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a[::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<p><strong>这里我们将实现一个自定义的不可变切片序列类：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可切片的类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, group_name, company_name, staffs</span>):</span></span><br><span class="line">        self.group_name = group_name</span><br><span class="line">        self.company_name = company_name</span><br><span class="line">        self.staffs = staffs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span>(<span class="params">self</span>):</span></span><br><span class="line">        cls = <span class="built_in">type</span>(self)</span><br><span class="line">        reversed_staffs = self.staffs.reverse()</span><br><span class="line">        <span class="keyword">return</span> cls(group_name=self.group_name, company_name=self.company_name, staffs=reversed_staffs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span>  <span class="comment"># 实现切片的魔法方法</span></span><br><span class="line">        cls = <span class="built_in">type</span>(self)  <span class="comment"># 用于在类的实例方法中获取当前实例所属的类</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">return</span> cls(group_name=self.group_name, company_name=self.company_name, staffs=[self.staffs[item]])</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(item, <span class="built_in">slice</span>):</span><br><span class="line">            <span class="keyword">return</span> cls(group_name=self.group_name, company_name=self.company_name, staffs=self.staffs[item])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.staffs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self.staffs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> self.staffs:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    group = Group(company_name=<span class="string">&quot;1&quot;</span>, group_name=<span class="string">&quot;1.1&quot;</span>, staffs=[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    var = group[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(var)</span><br><span class="line">    <span class="built_in">print</span>(group[<span class="number">0</span>].staffs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(group))</span><br></pre></td></tr></table></figure>

<p>上述代码中，按照序列类的协议实现了一个自定义的序列，借助了内置的序列类 list </p>
<h2 id="bisect-模块介绍"><a href="#bisect-模块介绍" class="headerlink" title="bisect 模块介绍"></a>bisect 模块介绍</h2><p>模块介绍：<a href="https://docs.python.org/zh-cn/3/library/bisect.html">https://docs.python.org/zh-cn/3/library/bisect.html</a></p>
<blockquote>
<p><code>bisect</code>模块是Python标准库中的一个模块，提供了对已排序列表的二分查找和插入操作的支持。它基于二分查找算法，在有序序列中进行高效的查找和插入。</p>
<p><code>bisect</code>模块提供了以下常用的函数：</p>
<ol>
<li><code>bisect_left(a, x, lo=0, hi=len(a))</code>： 返回在已排序列表 <code>a</code> 中将元素 <code>x</code> 插入的位置（左边界）。 如果 <code>x</code> 已经存在于列表中，那么返回其最左边的位置。可选参数 <code>lo</code> 和 <code>hi</code> 可用于指定查找范围。</li>
<li><code>bisect_right(a, x, lo=0, hi=len(a))</code>： 返回在已排序列表 <code>a</code> 中将元素 <code>x</code> 插入的位置（右边界）。 如果 <code>x</code> 已经存在于列表中，那么返回其最右边的位置。可选参数 <code>lo</code> 和 <code>hi</code> 可用于指定查找范围。</li>
<li><code>bisect(a, x, lo=0, hi=len(a))</code>： <code>bisect_right</code> 的别名函数，返回在已排序列表 <code>a</code> 中将元素 <code>x</code> 插入的位置（右边界）。</li>
<li><code>insort_left(a, x, lo=0, hi=len(a))</code>： 将元素 <code>x</code> 按照有序方式插入到已排序列表 <code>a</code> 中的正确位置（左边界）。 可选参数 <code>lo</code> 和 <code>hi</code> 可用于指定插入范围。</li>
<li><code>insort_right(a, x, lo=0, hi=len(a))</code>： 将元素 <code>x</code> 按照有序方式插入到已排序列表 <code>a</code> 中的正确位置（右边界）。 可选参数 <code>lo</code> 和 <code>hi</code> 可用于指定插入范围。</li>
</ol>
<p><code>bisect</code>模块的函数可用于在<strong>已排序的序列中进行高效的查找和插入操作</strong>，例如在有序列表中快速找到插入点，或者将元素按照正确的顺序插入到列表中。这在需要处理大量数据的应用中特别有用，如搜索、排名、数据统计等场景。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">inter_li = []</span><br><span class="line">bisect.insort(inter_li, <span class="number">3</span>)</span><br><span class="line">bisect.insort(inter_li, <span class="number">2</span>)</span><br><span class="line">bisect.insort(inter_li, <span class="number">5</span>)</span><br><span class="line">bisect.insort(inter_li, <span class="number">6</span>)</span><br><span class="line">bisect.insort(inter_li, <span class="number">0</span>)</span><br><span class="line">bisect.insort(inter_li, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="列表的使用场景-amp-amp-其他容器对象介绍"><a href="#列表的使用场景-amp-amp-其他容器对象介绍" class="headerlink" title="列表的使用场景&amp;&amp;其他容器对象介绍"></a>列表的使用场景&amp;&amp;其他容器对象介绍</h2><p>什么时候我们不该使用列表？</p>
<ul>
<li>array<br><strong>C 语言中的数组，连续的数组空间，存储的数据类型是一致的</strong><br>官方参考文档：<a href="https://docs.python.org/zh-cn/3/library/array.html">https://docs.python.org/zh-cn/3/library/array.html</a><br>常用的类型映射：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="type">Type</span> code   C <span class="type">Type</span>             Minimum size <span class="keyword">in</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span>         signed integer     <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span>         unsigned integer   <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;u&#x27;</span>         Unicode character  <span class="number">2</span> (see note)</span><br><span class="line"><span class="string">&#x27;h&#x27;</span>         signed integer     <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;H&#x27;</span>         unsigned integer   <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;i&#x27;</span>         signed integer     <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;I&#x27;</span>         unsigned integer   <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;l&#x27;</span>         signed integer     <span class="number">4</span></span><br><span class="line"><span class="string">&#x27;L&#x27;</span>         unsigned integer   <span class="number">4</span></span><br><span class="line"><span class="string">&#x27;q&#x27;</span>         signed integer     <span class="number">8</span> (see note)</span><br><span class="line"><span class="string">&#x27;Q&#x27;</span>         unsigned integer   <span class="number">8</span> (see note)</span><br><span class="line"><span class="string">&#x27;f&#x27;</span>         floating point     <span class="number">4</span></span><br><span class="line"><span class="string">&#x27;d&#x27;</span>         floating point     <span class="number">8</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_arr = array.array(<span class="string">&quot;i&quot;</span>)</span><br><span class="line">    my_arr.append(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># my_arr.append(&quot;abc&quot;)</span></span><br><span class="line">    <span class="built_in">print</span>(my_arr)</span><br></pre></td></tr></table></figure>
<p>更为详细的用法可以参考官方文档</p>
<ul>
<li>deque</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>with 上下文管理器</title>
    <url>/posts/426e2f30/</url>
    <content><![CDATA[<h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><p><code>with</code> 的语法格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">    <span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>

<p>with 语法非常简单，我们只需要 <code>with</code> 一个表达式，然后就可以执行自定义的业务逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment"># do_something...</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>with 非常简单，我们只需要 <code>with</code> 一个表达式，然后就可以执行自定义的业务逻辑。</p>
<p>一个类在 Python 中，只要实现以下方法，就实现了 「 上下文管理协议 」：</p>
<ul>
<li><code>__enter__</code>: 在进入 <code>with</code> 语法块之前调用，返回值会赋值给 <code>with</code> 的 <code>target</code></li>
<li><code>__exit__</code>: 在退出 <code>with</code> 语法块时调用，一般用作异常处理</li>
</ul>
<h1 id="contextlib-模块"><a href="#contextlib-模块" class="headerlink" title="contextlib 模块"></a>contextlib 模块</h1><p>使用 <code>contextlib</code> 模块，我们可以把上下文管理器当成一个 「 装饰器 」来使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;before&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;after&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> test() <span class="keyword">as</span> t:</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>
<h1 id="closing-方法"><a href="#closing-方法" class="headerlink" title="closing 方法"></a>closing 方法</h1><p>closing 主要用在已经实现<code>close</code>方法的资源对象上：</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lock</span>(<span class="params">redis, lock_key, expire</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        locked = redis.<span class="built_in">set</span>(lock_key, <span class="string">&#x27;locked&#x27;</span>, expire)</span><br><span class="line">        <span class="keyword">yield</span> locked</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        redis.delete(lock_key)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 业务调用 with 代码块执行结束后 自动释放资源</span></span><br><span class="line"><span class="keyword">with</span> lock(redis, <span class="string">&#x27;locked&#x27;</span>, <span class="number">3</span>) <span class="keyword">as</span> locked:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> locked:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure>

<h2 id="redis-事务和管道"><a href="#redis-事务和管道" class="headerlink" title="redis 事务和管道"></a>redis 事务和管道</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pipeline</span>(<span class="params">redis</span>):</span></span><br><span class="line">    pipe = redis.pipeline()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> pipe</span><br><span class="line">        pipe.execute()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        pipe.reset()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 业务调用 with 代码块执行结束后 自动执行 excute 方法</span></span><br><span class="line"><span class="keyword">with</span> pipeline(redis) <span class="keyword">as</span> pipe:</span><br><span class="line">    pipe.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">30</span>)</span><br><span class="line">    pipe.zadd(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    pipe.sadd(<span class="string">&#x27;key3&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁与悲观锁-Python 实现</title>
    <url>/posts/102bc233/</url>
    <content><![CDATA[<h1 id="Python-乐观锁与悲观锁"><a href="#Python-乐观锁与悲观锁" class="headerlink" title="Python 乐观锁与悲观锁"></a>Python 乐观锁与悲观锁</h1><p>参考：<a href="https://xie.infoq.cn/article/2085a95ad6b486d3905adc7d6">https://xie.infoq.cn/article/2085a95ad6b486d3905adc7d6</a></p>
<blockquote>
<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题</p>
</blockquote>
<h2 id="什么是乐观锁-？"><a href="#什么是乐观锁-？" class="headerlink" title="什么是乐观锁 ？"></a>什么是乐观锁 ？</h2><blockquote>
<p>乐观锁在操作数据时采用乐观的态度，认为不会出现多个操作数据的事件。因此乐观锁不糊上锁，只是在进行更新操作的时候<br>判断该期间是否同时存在修改了数据的情况：若在修改时数据已被修改则放弃操作，否则继续执行操作。</p>
</blockquote>
<h2 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h2><blockquote>
<ol>
<li>CAS 机制。2.版本号机制。这里将采用 python + orm 的实现方式</li>
</ol>
</blockquote>
<h3 id="CSA-Compare-and-Swap"><a href="#CSA-Compare-and-Swap" class="headerlink" title="CSA (Compare and Swap)"></a>CSA (Compare and Swap)</h3><p>CSA 的操作主要包括了 3 个操作数：</p>
<ul>
<li>需要读写的内存位置(V)</li>
<li>进行比较的预期值(A)</li>
<li>拟写入的新值(B)<br>具体的操作逻辑为：若内存位置的值等于预期的 A 值，则将该位置更新为新值 B, 否则不进行任何操作。<br>直到重试次数消耗完毕。<h3 id="CSA-实现"><a href="#CSA-实现" class="headerlink" title="CSA 实现"></a>CSA 实现</h3><blockquote>
<p>乐观锁（Optimistic Lock）,适用于多读</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="keyword">from</span> 应用名.models <span class="keyword">import</span> GoodsSKU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类视图 (并发，乐观锁)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @transaction.atomic</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;订单创建&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = <span class="number">3</span>  <span class="comment"># 订购3件商品</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置事务保存点</span></span><br><span class="line">        s1 = transaction.savepoint()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 乐观锁，最多尝试5次</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># 查询商品的信息(库存)</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                sku = GoodsSKU.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="comment"># 商品不存在</span></span><br><span class="line">                transaction.savepoint_rollback(s1)</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;商品不存在&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断商品的库存</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; sku.stock:</span><br><span class="line">                transaction.savepoint_rollback(s1)</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;商品库存不足&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新商品的库存和销量</span></span><br><span class="line">            orgin_stock = sku.stock  <span class="comment"># 原库存 (数据库隔离级别必须是Read Committed；如果是Repeatable Read,那么多次尝试读取的原库存都是一样的,读不到其他线程提交更新后的数据。)</span></span><br><span class="line">            new_stock = orgin_stock - count  <span class="comment"># 更新后的库存</span></span><br><span class="line">            new_sales = sku.sales + count  <span class="comment"># 更新后的销量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># update 商品表 set stock=new_stock, sales=new_sales where id=1 and stock = orgin_stock</span></span><br><span class="line">            <span class="comment"># 通过where子句中的条件判断库存是否进行了修改。(并发，乐观锁)</span></span><br><span class="line">            <span class="comment"># 返回受影响的行数</span></span><br><span class="line">            res = GoodsSKU.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>, stock=orgin_stock).update(stock=new_stock, sales=new_sales)</span><br><span class="line">            <span class="keyword">if</span> res == <span class="number">0</span>:  <span class="comment"># 如果修改失败</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">                    <span class="comment"># 如果尝试5次都失败</span></span><br><span class="line">                    transaction.savepoint_rollback(s1)</span><br><span class="line">                    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;下单失败&#x27;</span>&#125;)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 再次尝试</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 否则更新成功</span></span><br><span class="line">            <span class="comment"># 跳出尝试循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提交事务</span></span><br><span class="line">        transaction.savepoint_commit(s1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回应答</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;创建成功&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁 ?"></a>什么是悲观锁 ?</h2><p>悲观锁在操作数据的时候，比较悲观，认为别人会同时修改数据。<br>因此操作数据时会直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>例如，有用户 A 和用户 B，在同一家店铺去购买同一个商品，但是商品的可购买数量只有一个<br><img src="/images/img.png" alt="direct"></p>
<p>若，用户 A 和用户 B 同时下单，就会报错。<br>悲观锁的实现，往往依靠数据库提供的锁机制，在数据库中，我们如何用悲观锁去结局这个事情呢？</p>
<ol>
<li>用户 A 在执行购买商品的时候，先尝试对该商品加上悲观锁。</li>
<li>若加锁失败，说明商品正在被其他事务进行修改，当前查询需要等待或者抛出异常，具体返回的方式需要开发者根据具体情况去定义</li>
<li>加锁成功：对商品进行修改</li>
<li>在此期间如果有其他用户对数据做修改或加锁的操作，都会等待我们解锁后或直接抛出异常<br><img src="/images/img_1.png" alt="direct"></li>
</ol>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>那么如何加上悲观锁呢，1. 首先关闭 MySQL 数据库的自动提交属性。因为 MySQL 默认使用 autocommit 模式（默认提交）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set autocommit = 0;</span><br></pre></td></tr></table></figure>
<p>悲观锁加锁 sql 语句： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select num form t_goods where id = 2 for update</span><br></pre></td></tr></table></figure>
<p>此时，其他事务都不能获取到此行的数据去进行操作。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>yield 关键字初探</title>
    <url>/posts/47efc70b/</url>
    <content><![CDATA[<h1 id="yield-关键字初探"><a href="#yield-关键字初探" class="headerlink" title="yield 关键字初探"></a>yield 关键字初探</h1><p>yield 关键字在 python 中有诸多应用，例如生成器，协程并发等场景</p>
<h2 id="yield-解释"><a href="#yield-解释" class="headerlink" title="yield 解释"></a>yield 解释</h2><p>yiled 是属于 python 中的一个关键字，其用法和 return 类似，但是 return 是返回所有的变量值，yield 会保存一个生成器中的上下文，待下次 yield 时，调用 <code>__next__</code> 方法，返回生成器中的下一个值，直到结束。</p>
<p>生成器和迭代器都是可迭代对象，但是区别是 生成器在调用 <code>__next__</code> 方法时，会逐个返回，保留上下文，而迭代器会直接返回所有的数据。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>如果在一个方法内，包含了<code>yield</code>关键字，那么这个函数就是一个 「 生成器 」。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p>此外，生成器除了和迭代器一样实现迭代数据之外，还包含了其他方法：</p>
<ul>
<li><p><code>generator.__next__()</code>: <strong>执行 <code>for</code> 时调用此方法，每次执行到<code>yield</code>就会停止，然后返回<code>yield</code>后面的值，如果没有数据可迭代，</strong><br><strong>抛出 <code>StopIterator</code>异常，<code>for</code>循环结束。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = count(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> gen.<span class="built_in">next</span>() <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span> gen.<span class="built_in">next</span>() <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span> gen.<span class="built_in">next</span>() <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>generator.send(value)</code>：<strong>外部传入一个值到生成器内部，改变 <code>yield</code> 前面的值</strong></p>
<p>这里有个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">n</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; n:</span><br><span class="line">        value = <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Received value: <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">gen = count(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(gen.__next__())  <span class="comment"># print 0</span></span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="string">&#x27;Hello&#x27;</span>))  <span class="comment"># Received value: Hello, then print 1</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们通过 send 方法传递一个值到生成器中，将 yield x 传递给一个变量 x, 并打印出来；</p>
<p>简单的说，<code>send()</code>就是<code>next()</code>的功能，加上传值给<code>yield</code>。如果你有兴趣看下Python的源码，你会发现，其实<code>next()</code>的实现，就是<code>send(None)</code>。</p>
</li>
<li><p><code>generator.throw(type[,value[,traceback]])</code>:  <strong>外部向生成器抛出一个异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">throw_gen</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Normal&#x27;</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Error&#x27;</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Finally&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gen = throw_gen()</span><br><span class="line"><span class="built_in">print</span>(gen.__next__())  <span class="comment"># Normal</span></span><br><span class="line"><span class="built_in">print</span>(gen.__next__())  <span class="comment"># Finally, then StopIteration</span></span><br></pre></td></tr></table></figure>

<p>和预期结果一样，在创建完一个生成器后，使用 next 方法进行迭代，依次输出：Normal，Finally</p>
<p>当我们想在自定义输入特定 error 时，就可以使用 throw 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = throw_gen()</span><br><span class="line"><span class="built_in">print</span>(gen.<span class="built_in">next</span>())  <span class="comment"># Normal</span></span><br><span class="line"><span class="built_in">print</span>(gen.throw(ValueError))    <span class="comment"># Error</span></span><br><span class="line"><span class="built_in">print</span>(gen.<span class="built_in">next</span>())  <span class="comment"># Finally, then StopIteration</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>generator.cloase()</code>: <strong>关闭生成器</strong></p>
</li>
</ul>
<p>顾名思义，close() 方法就是关闭生成器。生成器被关闭后，再次调用 next 方法时，不管能否遇到 yield 关键字，都会立即抛出 “StopIteration” 异常。</p>
<h2 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h2><p>yield 实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="built_in">next</span>(c)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        c.send(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;producer: <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    i = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        j = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;consumer: <span class="subst">&#123;j&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    producer(c)</span><br></pre></td></tr></table></figure>

<p>上述例子中，consumer 消费者是一个生成器，每次执行到 yield 时挂起，等待生产者的输入，生产者依次调用 send 方法，传入外部值到 消费者中，这样，我们就实现了一个（伪）并发。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>协程实现原理及使用</title>
    <url>/posts/f8c31c0f/</url>
    <content><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>在上一篇文章中：【IO 多路复用】，我们介绍了如何基于 select(poll/epoll) + 回调 + 事件循环编写一个高并发的 IO 多路复用模型，也知道了协程的设计理念也是和 IO 多路复用是类似的。今天我们将学习 【协程】。</p>
<p>在介绍协程之前，我们需要理解准备知识：</p>
<ul>
<li>回调之痛</li>
<li>生成器</li>
</ul>
<h2 id="回调之痛"><a href="#回调之痛" class="headerlink" title="回调之痛"></a>回调之痛</h2><p>在 【IO 多路复用】的实现过程中，我们使用 select 监听不同的事件描述符，并对不同的事件（写，读）注册不同的回调函数。在阅读代码时可以发现，其整体逻辑是没有同步代码编写清楚的，而且还有一些问题， 例如：</p>
<ul>
<li>如果回调函数执行异常时，我们应该如何处理？</li>
<li>如果回调函数内有嵌套关系，如何处理</li>
<li>当嵌套多层时，其中某个环节出错了会导致什么结果？</li>
<li>。。。</li>
</ul>
<p><strong>总结下来就是：可读性差，共享状态管理困难，异常处理困难</strong></p>
<p>那么我们应该如何优化呢？</p>
<p><strong>结论就是：我们希望既有回调模式的高性能，又希望能够以同步的形式编写代码</strong></p>
<h2 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h2><p>首先我们可以了解一下 <strong>C10M</strong> 的问题？</p>
<p><strong>如何利用 8 核CPU，64G 内存，在 10gbps 的网络上保持 1000 万的并发连接。</strong></p>
<p>在前面的文章中，我们实现了 IO 多路复用的模型，在单线程中如何实现并发。在【回调之痛】中，<strong>我们又希望进一步进行优化：回调的高性能，单线程下进行代码切换，同步的形式进行编写代码。</strong></p>
<p>我们知道进程，线程都是由操作系统完成的，在单线程下进行切换是用户态的，也就是需要程序员自己进行函数切换，这个时候，就避免了多线程下的锁机制和切换代价，并发性就会很高。</p>
<p><strong>那么问题来了，如何能够实现在单线程下，实现函数间的切换？</strong></p>
<p>我们知道，在传统代码编写中 A 函数调用 B 函数后，就会直接 return </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>():</span></span><br><span class="line">  b = B() <span class="comment"># 此处暂停，切换</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>而我们需要的是当执行 B 时，在调用位置暂停，去执行 A 的逻辑。</strong></p>
<p>于是，我们需要的是一个可以暂停的函数，并且在适当的时候恢复该函数的执行。<strong>所以我们就引出了 【协程】的概念，一个具有多个入口的函数，可以暂停的函数（可以向暂停的地方传入值）</strong></p>
<p>在 python 中，我们知道生成器是可以暂停的，其中就包含 yield /yield from 的用法，关于迭代器和生成器可以参考我的文章：【迭代器和生成器的实现原理】</p>
<h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><p>在 python 3.3 中新增了 yield from 语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">my_dict = &#123;</span><br><span class="line">    <span class="string">&quot;bobby1&quot;</span>:<span class="string">&quot;http://projectsedu.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bobby2&quot;</span>:<span class="string">&quot;http://www.imooc.com&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> chain(my_list, my_dict, <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>)):</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">bobby1</span><br><span class="line">bobby2</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>chain 函数会依次将可迭代对象遍历然后打印, 同样，我们将使用 <code>yield</code> 也可以实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_chain</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> my_iterable <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> my_iterable:</span><br><span class="line">            <span class="keyword">yield</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> my_chain(my_list, my_dict, <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>)):</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>

<p>同样，我们也可以使用 <code>yield from</code> 实现上述效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_chain</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> my_iterable <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> my_iterable</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> my_chain(my_list, my_dict, <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>)):</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>

<p>于是我们可以简单的将 <code>yield from g</code> 理解为 <code>for v in g: yield v</code> 。 </p>
<p><strong>其次，其最重要的功能是在调用者和子生成器之间建立透明的双向连接</strong></p>
<p>接下来我们再来看个例子：</p>
<ol>
<li>main 调用方 g1(委托生成器) gen 子生成器</li>
<li><strong>yield from 会在调用方与子生成器之间建立一个双向通道</strong>，<strong>这是yield 最核心的点，也为协程的同步实现提供了可能。</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def g1(gen):</span><br><span class="line">    yield from gen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    g = g1()</span><br><span class="line">    g.send(None)</span><br></pre></td></tr></table></figure>

<p>yield from 功能十分强大，具体可参考：<a href="https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-yield-from-syntax-in-python-3-3">https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-yield-from-syntax-in-python-3-3</a></p>
<h2 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h2><p>协程仍然是事件循环+协程模式</p>
<h3 id="async-amp-amp-await"><a href="#async-amp-amp-await" class="headerlink" title="async &amp;&amp; await"></a>async &amp;&amp; await</h3><h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><p>官方使用可以参考：<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a></p>
<p>用于协程调度</p>
<ul>
<li>包含各种特定系统实现的模块化事件循环，包括 windows/linux 等系统</li>
<li>传输和协议抽象</li>
<li>对 TCP/UDP/SSL 子进程、延时调用以及其他具体支持</li>
<li>模仿 futures 模块但适用于事件循环使用的 Future 类</li>
<li>基于 yield from 的协议和任务，可以让你用顺序的方式编写并发代码</li>
<li>必须使用一个将产生阻塞 IO 的调用时，有接口可以把这个事件转移到线程池</li>
<li>模仿 threading 模块中的同步原语，可以用在单线程内的协程之间</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start get url&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end get url&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">&quot;1&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(end_time-start_time)</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">start get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line">end get url</span><br><span class="line"><span class="number">2.0052013397216797</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到一次性提交了 10 个任务，并共计耗时 2 s，实现了并发。</p>
<p>常规方法使用介绍：</p>
<ul>
<li>get_event_loop 获取事件循环</li>
<li>loop.run_until_complete 设定任务结束标志，提交任务</li>
</ul>
<h3 id="gather-amp-amp-wait"><a href="#gather-amp-amp-wait" class="headerlink" title="gather &amp;&amp; wait"></a>gather &amp;&amp; wait</h3><p>gather 用于提交多个任务，相对 wait 而言是高层的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start get url&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end get url&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">&quot;1&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(end_time-start_time)</span><br></pre></td></tr></table></figure>

<p>gather 使用较为灵活，还可以对 tasks 进行分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start get url&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end get url&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">&quot;1&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分组</span></span><br><span class="line">    group1 = asyncio.gather(*tasks)</span><br><span class="line">    loop.run_until_complete(group1)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(end_time-start_time)</span><br></pre></td></tr></table></figure>

<h3 id="run-until-complete-amp-amp-run-forever"><a href="#run-until-complete-amp-amp-run-forever" class="headerlink" title="run_until_complete &amp;&amp; run_forever"></a>run_until_complete &amp;&amp; run_forever</h3><p>前者是如何得知 协程是全部完成的，查看源码可以知道其调用了 <code>add_done_callback()</code>，让事件循环停止</p>
<h3 id="如何取消-task-的运行"><a href="#如何取消-task-的运行" class="headerlink" title="如何取消 task 的运行"></a>如何取消 task 的运行</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">sleep_time</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; waiting&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;done after <span class="subst">&#123;sleep_time&#125;</span>s&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task1 = get_html(<span class="number">1</span>)</span><br><span class="line">    task2 = get_html(<span class="number">2</span>)</span><br><span class="line">    task3 = get_html(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [task1, task2, task3]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        all_tasks = asyncio.Task.all_tasks()</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> all_tasks:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;call task&quot;</span>)</span><br><span class="line">            task.cancel()</span><br><span class="line">        loop.stop()</span><br><span class="line">        loop.run_forever()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure>

<h3 id="子协程"><a href="#子协程" class="headerlink" title="子协程"></a>子协程</h3><p>待补充</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>待补充</p>
<h3 id="ThreadPollExecutor-asyncio"><a href="#ThreadPollExecutor-asyncio" class="headerlink" title="ThreadPollExecutor + asyncio"></a>ThreadPollExecutor + asyncio</h3><p>待补充</p>
<h3 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h3><p>待补充</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>协程实现原理及使用</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式-Python 实现</title>
    <url>/posts/26a37a49/</url>
    <content><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式 ?"></a>什么是单例模式 ?</h1><blockquote>
<p>单例模式（Singleton Pattern）是软件设计中的一种常用设计模式，其目的是在一个进程中，确保某一个类(class)只有一个实例(instance)存在。<br>例如，当我们在操作数据库时，多个服务都要调用数据库的 connection ，其配置信息都是相同的，这种情况就可以使用单例模式。在该系统中，只使用一个用于连接数据库的 connection 实例</p>
</blockquote>
<h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><h3 id="1-模块构建"><a href="#1-模块构建" class="headerlink" title="1. 模块构建"></a>1. 模块构建</h3><blockquote>
<p><strong>Python 的模块就是天然的单例模式</strong>，模块在第一次导入的时候，会生成 <code>.pyc</code> 文件，就会直接加载<code>.pyc</code>文件，而不会再次执行模块<br>因此，我们只需要把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p>
</blockquote>
<p><strong>Singleton.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">singleton = Singleton()</span><br></pre></td></tr></table></figure>
<p>当我们需要使用这个 instance 的时候，直接使用即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Singleton <span class="keyword">import</span> singleton</span><br></pre></td></tr></table></figure>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote>
<p>使用 dict 类型，以 key-value 方式存储类的实例和运行的函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">cls</span>):</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line">    <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">a1 = A(<span class="number">1</span>)</span><br><span class="line">a2 = A(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> a2)</span><br></pre></td></tr></table></figure>
<h3 id="类方法实现"><a href="#类方法实现" class="headerlink" title="类方法实现"></a>类方法实现</h3><blockquote>
<p>使用方法 <code>hasattr</code> 方法判断类中是否已实现了对应的实例方法，实现了就直接返回，未返回就添加单例属性</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line">obj = Singleton.instance()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="多线程场景"><a href="#多线程场景" class="headerlink" title="多线程场景"></a>多线程场景</h3><p>但是在<code>多线程</code>的使用中，由于每个线程有自己的数据资源，所以会<code>存在问题</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">arg</span>):</span></span><br><span class="line">    obj = Singleton.instance()</span><br><span class="line">    <span class="built_in">print</span>(obj) <span class="comment"># 显示 instance 的详情信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task,args=[i,])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上的实例显示出的详情可以看到 obj 的 id 并不一致，解决办法就是加 <code>锁</code>(mutex)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">with</span> Singleton.lock:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>
<p>以上实现方式对整个实例的创建过程都进行了加锁，可以进行优化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                <span class="keyword">with</span> Singleton.lock:</span><br><span class="line">                    Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>
<p>但是这样的实现方式，需要借助 <code>instance 方法</code></p>
<h3 id="new-方法实现"><a href="#new-方法实现" class="headerlink" title="__new__ 方法实现"></a><code>__new__</code> 方法实现</h3><blockquote>
<p>一个类在被实例化的过程中，先是执行默认的<code>__new__</code> 方法，然后再执行<code>__init__</code>方法初始化对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> cls._instance_lock:</span><br><span class="line">                cls._instance = <span class="built_in">super</span>.__new__(cls)</span><br><span class="line">            <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<h3 id="metaclass-方式实现"><a href="#metaclass-方式实现" class="headerlink" title="metaclass 方式实现"></a><code>metaclass</code> 方式实现</h3><blockquote>
<ol>
<li>类由 <code>type</code>创建，创建类时，type 的 <code>__init__</code> 方法自动执行，类() 的方式执行<code>type</code> 的<code>__call__</code>方法（类的 <strong>new__、__init</strong> 方法）</li>
<li>对象由类创建，创建对象时，类的 <code>__init__</code> 方法自动执行，对象()执行类的<code>__call__</code> 方法</li>
</ol>
</blockquote>
<p>其实，我们就是要保证在创建类的时候，保证这个类只有一个实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    _instance_lock = threading.Lock</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> SingletonType._instance_lock:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                    cls._instance = <span class="built_in">super</span>.__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonType</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程</title>
    <url>/posts/341a9d02/</url>
    <content><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>今天我们一起来探讨多线程编程。</p>
<p>首先，什么是线程？</p>
<p>线程相较于进程而言，是 CPU 调度的基本单位，线程是依赖于进程的。对于一个进程而言，其下有多个线程，线程共享进程的资源，线程之间会有竞态。</p>
<p>对于 IO 密集型的程序而言，线程和进程的性能相差不大。</p>
<p>接下来，我们将一起来学习 python 中的多线程编程。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>在 python 中，对于线程的操作库是 <code>threading</code> 模块。我们模拟一下抓取网页的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get html success!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=get_html, args=(<span class="number">2</span>,))</span><br><span class="line"></span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finished&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果我需要并发去抓取不同的网页，应该如何操作呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html_1</span>(<span class="params">url</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;get html 1 <span class="subst">&#123;url&#125;</span> success!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html_2</span>(<span class="params">url</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;get html 2 <span class="subst">&#123;url&#125;</span> success!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=get_html_1, args=(<span class="string">&quot;www.baidu.com&quot;</span>,))</span><br><span class="line">    t2 = threading.Thread(target=get_html_2, args=(<span class="string">&quot;www.souhu.com&quot;</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join() <span class="comment"># 阻塞</span></span><br><span class="line">    t2.start()</span><br><span class="line">    t2.join() <span class="comment"># 阻塞</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finished&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>当然，除了以上的使用线程的方式外，我们还可以通过继承+重写 run 的方法来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetHtmlDetail</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init</span>(<span class="params">self, name</span>):</span></span><br><span class="line">    <span class="built_in">super</span>().__init__(name=name)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running&quot;</span>)</span><br><span class="line"></span><br><span class="line">t1 = GetHtmlDetail(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br></pre></td></tr></table></figure>



<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><p>在前文中，我介绍了线程是依赖进程的，共享进程的资源，在线程间的通信中，我们可以通过共享变量来进行线程间的通信。当然，也可以通过 Queue 等方式进行通信。</p>
<h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>同样，我们也是实现一个生产者-消费者来模拟线程间的通信：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;produce: <span class="subst">&#123;i&#125;</span> in queue&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue:</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">                data = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;consumer data: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   p = Producer()</span><br><span class="line">   c = Consumer()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   p.start()</span><br><span class="line">   c.start()</span><br><span class="line"></span><br><span class="line">   p.join()</span><br><span class="line">   c.join()</span><br></pre></td></tr></table></figure>

<p>以上实现了一个生产者-消费者模型，演示了线程之间通过全局变量进行通信。由于 <code>queue=[]</code> 是非阻塞的，则先在 consumer 中 time.sleep(10) 等待生产物料就绪。在实际的应用中，我们一般不推荐共享变量的方式来完成线程通信，这是因为<strong>全局变量不是线程安全的，那么就会引发一些错误，接下来我们来看一下 Queue.</strong></p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>接下来，我将使用 <code>Queue</code> 来演示，在 python 中 <code>from queue import Queue</code>，其中的 Queue 是多线程安全的。我这里将演示，使用多个消费者来消费一个生产者。</p>
<p>queue.Queue 是一个阻塞队列，故会等待 data 的传入然后消费</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            queue.put(i)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;produce: <span class="subst">&#123;i&#125;</span> in queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            queue.put(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = queue.get()</span><br><span class="line">            <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;consumer: <span class="subst">&#123;self.name&#125;</span> exiting&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;consumer: <span class="subst">&#123;self.name&#125;</span> data: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue(maxsize=<span class="number">100</span>)  <span class="comment"># 避免内存泄露</span></span><br><span class="line">    p = Producer()</span><br><span class="line">    c1 = Consumer(<span class="string">&quot;c1&quot;</span>)</span><br><span class="line">    c2 = Consumer(<span class="string">&quot;c2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line"></span><br><span class="line">    p.join()</span><br><span class="line">    c1.join()</span><br><span class="line">    c2.join()</span><br></pre></td></tr></table></figure>

<p>那么为什么 Queue 是线程安全的呢？这是因为在每个操作之时都会进行获取锁和释放锁的操作。感兴趣的同学可以自行查阅学习。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>在多线程编程中，我们需要考虑线程同步，那么什么是线程同步以及为什么需要线程同步呢？</p>
<p>我们通过一个例子来解释为什么需要线程同步？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        a -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=add)</span><br><span class="line">    t2 = threading.Thread(target=desc)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们对一个全局编程进行操作，但是我们发现打印结果每次都不一样，且不为 0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-307326</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？这是因为 python GIL 的存在，<strong>GIL 是基于固定时间的调度方式，每次执行固定时间的字节码</strong>，导致 t1 还未完成执行完成时切换到了 t2，导致不是我们预期的结果。</p>
<h3 id="Lock-amp-amp-Lock"><a href="#Lock-amp-amp-Lock" class="headerlink" title="Lock &amp;&amp; Lock"></a>Lock &amp;&amp; Lock</h3><p>那么如何解决这个问题呢？这就涉及到了线程的锁操作：Lock &amp;&amp; RLock</p>
<p>这里简单介绍一下这二者的区别：</p>
<blockquote>
<ol>
<li><code>threading.Lock</code>：<ul>
<li><code>Lock</code> 是一个简单的互斥锁（Mutex），也被称为普通锁。</li>
<li>它只有两个状态：锁定（locked）和未锁定（unlocked）。</li>
<li>一旦某个线程获取了 <code>Lock</code>，其他线程就无法获取该锁，直到锁被释放。</li>
<li>即使是同一个线程多次调用 <code>Lock</code> 的 <code>acquire()</code> 方法，也会导致该线程被阻塞，因为它已经持有了该锁。</li>
</ul>
</li>
<li><code>threading.RLock</code>：<ul>
<li><code>RLock</code> 是可重入锁（Reentrant Lock）。</li>
<li>可重入锁允许一个线程多次获得同一个锁而不会发生阻塞，前提是该线程已经持有了这个锁。也就是说，一个线程可以多次调用 <code>RLock</code> 的 <code>acquire()</code> 方法而不会被阻塞，只要它在之前已经获得了该锁，并且对应的 <code>release()</code> 方法的次数和 <code>acquire()</code> 方法的次数相等即可释放该锁。</li>
<li>这种机制允许线程在递归或嵌套函数调用中安全地多次获取同一个锁，避免了死锁的可能性。</li>
</ul>
</li>
</ol>
</blockquote>
<p>现在，我们就可以利用 锁 对以上的代码进行改造，达到我们想要的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        a -= <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=add)</span><br><span class="line">    t2 = threading.Thread(target=desc)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>结果输出为 0；</p>
<p>当然，在使用锁的时候要结合应用场景，锁会影响性能且容器导致死锁，在使用时，要谨慎。</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>用于复杂的线程间的同步，例如我们要完成两个 AI 机器人的问答交互，应该如何实现呢？</p>
<p>我们这里通过一个例子来进行学习：</p>
<p>这里我们将使用两个线程模拟两个 AI 机器人的对话，实现效果是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">天猫精灵: 小爱同学</span><br><span class="line">小爱: 我在</span><br><span class="line">天猫精灵: 我们来对古诗吧</span><br><span class="line">小爱: 好啊</span><br><span class="line">天猫精灵: 我住长江头</span><br><span class="line">小爱: 我住长江尾</span><br></pre></td></tr></table></figure>

<p>我们一般是先使用锁的机制来运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class XiaoAi(threading.Thread):</span><br><span class="line">    def __init__(self, lock):</span><br><span class="line">        super().__init__(name=&quot;小爱&quot;)</span><br><span class="line">        self.lock = lock</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        print(f&quot;&#123;self.name&#125;: 我在&quot;)</span><br><span class="line">        self.lock.release()</span><br><span class="line"></span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        print(f&quot;&#123;self.name&#125;: 好啊&quot;)</span><br><span class="line">        self.lock.release()</span><br><span class="line"></span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        print(f&quot;&#123;self.name&#125;: 我住长江尾&quot;)</span><br><span class="line">        self.lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Tianmao(threading.Thread):</span><br><span class="line">    def __init__(self, lock):</span><br><span class="line">        super().__init__(name=&quot;天猫精灵&quot;)</span><br><span class="line">        self.lock = lock</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        print(f&quot;&#123;self.name&#125;: 小爱同学&quot;)</span><br><span class="line">        self.lock.release()</span><br><span class="line"></span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        print(f&quot;&#123;self.name&#125;: 我们来对古诗吧&quot;)</span><br><span class="line">        self.lock.release()</span><br><span class="line"></span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        print(f&quot;&#123;self.name&#125;: 我住长江头&quot;)</span><br><span class="line">        self.lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    xiaoai = XiaoAi(lock)</span><br><span class="line">    tianmao = Tianmao(lock)</span><br><span class="line"></span><br><span class="line">    tianmao.start()</span><br><span class="line">    xiaoai.start()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>现实是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">天猫精灵: 小爱同学</span><br><span class="line">天猫精灵: 我们来对古诗吧</span><br><span class="line">天猫精灵: 我住长江头</span><br><span class="line">小爱: 我在</span><br><span class="line">小爱: 好啊</span><br><span class="line">小爱: 我住长江尾</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，两个 AI 机器人并没有完成交互的对话，这是为什么呢？</p>
<p>我们知道在 python 语言中，有 GIL 全局解释器锁的机制，其背后代码运行的原理是：<strong>基于固定时间的调度方式，每次执行固定时间的字节码，或者遇到系统 IO 时，强制释放。</strong></p>
<p>在上述代码中，在一个固定时间内，天猫精灵就运行完了所有的代码，这样是不可行的。</p>
<p>于是，我们可以采用 <code>threading.Condition()</code>来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoAi</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, con</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=<span class="string">&quot;小爱&quot;</span>)</span><br><span class="line">        self.con = con</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> self.con:</span><br><span class="line">            self.con.wait()  <span class="comment"># wait() 方法只能通过 notify 唤醒</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>: 我在&quot;</span>)</span><br><span class="line">            self.con.notify()</span><br><span class="line">    </span><br><span class="line">            self.con.wait()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>: 好啊&quot;</span>)</span><br><span class="line">            self.con.notify()</span><br><span class="line">    </span><br><span class="line">            self.con.wait()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>: 我住长江尾&quot;</span>)</span><br><span class="line">            self.con.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tianmao</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, con</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=<span class="string">&quot;天猫精灵&quot;</span>)</span><br><span class="line">        self.con = con</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> self.con:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>: 小爱同学&quot;</span>)</span><br><span class="line">            self.con.notify()  <span class="comment"># 通知调用了 wait() 方的线程</span></span><br><span class="line">            self.con.wait()  <span class="comment"># 等待通知</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>: 我们来对古诗吧&quot;</span>)</span><br><span class="line">            self.con.notify()  <span class="comment"># 通知调用了 wait() 方的线程</span></span><br><span class="line">            self.con.wait()  <span class="comment"># 等待通知</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>: 我住长江头&quot;</span>)</span><br><span class="line">            self.con.notify()  <span class="comment"># 通知调用了 wait() 方的线程</span></span><br><span class="line">            self.con.wait()  <span class="comment"># 等待通知</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    xiaoai = XiaoAi(con)</span><br><span class="line">    tianmao = Tianmao(con)</span><br><span class="line"></span><br><span class="line">    xiaoai.start()  <span class="comment"># 先 wait</span></span><br><span class="line">    tianmao.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>启动顺序很重要，要先 wait, 后 notify</li>
<li>代码逻辑很重要，要先 <code>with self.con:</code>, 后嵌套 wait() 后 notify</li>
</ul>
<p>效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">天猫精灵: 小爱同学</span><br><span class="line">小爱: 我在</span><br><span class="line">天猫精灵: 我们来对古诗吧</span><br><span class="line">小爱: 好啊</span><br><span class="line">天猫精灵: 我住长江头</span><br><span class="line">小爱: 我住长江尾</span><br></pre></td></tr></table></figure>

<p>那么这是如何实现的呢？通过代码逻辑来了解</p>
<p>当小爱同学启动时，会调用 <code>con.wait()</code> 方法，等待被唤醒，当天猫精灵启动时，会调用 <code>con.notify</code> 方法，通知小爱同学，打印语句，然后通过 <code> con.notiry()</code> 通知天猫打印语句。这样循环打印，就完成了两个线程的同步对话机制。</p>
<p>那么这是如何实现的呢？通过代码逻辑来了解</p>
<p>当小爱同学启动时，会调用 <code>con.wait()</code> 方法，等待被唤醒，当天猫精灵启动时，会调用 <code>con.notify</code> 方法，通知小爱同学，打印语句，然后通过 <code> con.notiry()</code> 通知天猫打印语句。这样循环打印，就完成了两个线程的同步对话机制。</p>
<p>现在我们来通过解析 Condition 源码的方式来了解其内部运行的原理是如何的？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Class that implements a condition variable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A condition variable allows one or more threads to wait until they are</span></span><br><span class="line"><span class="string">    notified by another thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the lock argument is given and not None, it must be a Lock or RLock</span></span><br><span class="line"><span class="string">    object, and it is used as the underlying lock. Otherwise, a new RLock object</span></span><br><span class="line"><span class="string">    is created and used as the underlying lock.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, lock=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> lock <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            lock = RLock()</span><br><span class="line">        self._lock = lock</span><br><span class="line">        <span class="comment"># Export the lock&#x27;s acquire() and release() methods</span></span><br><span class="line">        self.acquire = lock.acquire</span><br><span class="line">        self.release = lock.release</span><br><span class="line">        <span class="comment"># If the lock defines _release_save() and/or _acquire_restore(),</span></span><br><span class="line">        <span class="comment"># these override the default implementations (which just call</span></span><br><span class="line">        <span class="comment"># release() and acquire() on the lock).  Ditto for _is_owned().</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._release_save = lock._release_save</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._acquire_restore = lock._acquire_restore</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._is_owned = lock._is_owned</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        self._waiters = _deque()</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self, n=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Wake up one or more threads waiting on this condition, if any.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If the calling thread has not acquired the lock when this method is</span></span><br><span class="line"><span class="string">        called, a RuntimeError is raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method wakes up at most n of the threads waiting for the condition</span></span><br><span class="line"><span class="string">        variable; it is a no-op if no threads are waiting.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_owned():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;cannot notify on un-acquired lock&quot;</span>)</span><br><span class="line">        all_waiters = self._waiters</span><br><span class="line">        waiters_to_notify = _deque(_islice(all_waiters, n))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> waiters_to_notify:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> waiter <span class="keyword">in</span> waiters_to_notify:</span><br><span class="line">            waiter.release()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                all_waiters.remove(waiter)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">              </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">wait</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Wait until notified or until a timeout occurs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If the calling thread has not acquired the lock when this method is</span></span><br><span class="line"><span class="string">        called, a RuntimeError is raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method releases the underlying lock, and then blocks until it is</span></span><br><span class="line"><span class="string">        awakened by a notify() or notify_all() call for the same condition</span></span><br><span class="line"><span class="string">        variable in another thread, or until the optional timeout occurs. Once</span></span><br><span class="line"><span class="string">        awakened or timed out, it re-acquires the lock and returns.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        When the timeout argument is present and not None, it should be a</span></span><br><span class="line"><span class="string">        floating point number specifying a timeout for the operation in seconds</span></span><br><span class="line"><span class="string">        (or fractions thereof).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        When the underlying lock is an RLock, it is not released using its</span></span><br><span class="line"><span class="string">        release() method, since this may not actually unlock the lock when it</span></span><br><span class="line"><span class="string">        was acquired multiple times recursively. Instead, an internal interface</span></span><br><span class="line"><span class="string">        of the RLock class is used, which really unlocks it even when it has</span></span><br><span class="line"><span class="string">        been recursively acquired several times. Another internal interface is</span></span><br><span class="line"><span class="string">        then used to restore the recursion level when the lock is reacquired.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_owned():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;cannot wait on un-acquired lock&quot;</span>)</span><br><span class="line">        waiter = _allocate_lock()</span><br><span class="line">        waiter.acquire()</span><br><span class="line">        self._waiters.append(waiter)</span><br><span class="line">        saved_state = self._release_save()</span><br><span class="line">        gotit = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">try</span>:    <span class="comment"># restore state no matter what (e.g., KeyboardInterrupt)</span></span><br><span class="line">            <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                waiter.acquire()</span><br><span class="line">                gotit = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">                    gotit = waiter.acquire(<span class="literal">True</span>, timeout)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    gotit = waiter.acquire(<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">return</span> gotit</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._acquire_restore(saved_state)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> gotit:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self._waiters.remove(waiter)</span><br><span class="line">                <span class="keyword">except</span> ValueError:</span><br><span class="line">                    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>首先，我们来看一下 <code>__init__</code> 部分，这里其实也是用到了锁机制——<code>RLock()</code> ；</p>
<p>然后就是这里的 <code>self._waiters = _deque()</code> ，这里其实是借助了一个 collection 中的 双端队列，是可阻塞的；</p>
<p><strong>condition 实际上是有两层锁，一把底层锁（conditino._lock）会在线程调用了 wait 方法的时候释放，并且在每次调用 <code>wait()</code>时，会生成一把锁，然后放入 <code>self._waiters</code> 中等待被释放，当调用了 <code>notify</code> 方法时，就会获取队列中的锁，然后释放。</strong></p>
<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量-Semaphore"></a>信号量-Semaphore</h3><blockquote>
<p>在 Python 中的 threading 模块中，Semaphore（信号量）是一种用于线程同步的机制。<strong>它可以控制同时访问某个资源的线程数量</strong>。Semaphore 维护着一个内部计数器，可以通过 acquire() 和 release() 方法来增加或减少计数器的值。</p>
</blockquote>
<p>例如我现在有个爬虫脚本，我们知道，某些网站对于爬虫是有一些反爬机制的，避免一些异常流量，避免多个线程的爬虫导致的网站崩溃。那么我们要如何正确有效的进行资源的爬取呢？</p>
<p>答案是：通过 Semaphore 模块，控制线程的创建并设置一定时间间隔取爬取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlSpider</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url, sem</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;got html text success&quot;</span>)</span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlProducer</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sem</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_thread = HtmlSpider(<span class="string">&quot;https://www.baidu.com&quot;</span>, self.sem)</span><br><span class="line">            html_thread.start()</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sem = threading.Semaphore(<span class="number">3</span>)</span><br><span class="line">    url_producer = UrlProducer(sem)</span><br><span class="line">    url_producer.start()</span><br></pre></td></tr></table></figure>



<p>通过上述代码，在创建 20 个线程的过程中，就可以实现每次创建 3 个线程，而不是一次性创建 20 个了。</p>
<p>其实，Semaphore 也是基于 Condition 进行创建使用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;This class implements semaphore objects.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Semaphores manage a counter representing the number of release() calls minus</span></span><br><span class="line"><span class="string">    the number of acquire() calls, plus an initial value. The acquire() method</span></span><br><span class="line"><span class="string">    blocks if necessary until it can return without making the counter</span></span><br><span class="line"><span class="string">    negative. If not given, value defaults to 1.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># After Tim Peters&#x27; semaphore class, but not quite the same (no maximum)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;semaphore initial value must be &gt;= 0&quot;</span>)</span><br><span class="line">        self._cond = Condition(Lock())</span><br><span class="line">        self._value = value</span><br></pre></td></tr></table></figure>

<p>关于详细信息可参考源码</p>
<h3 id="TreadPoolExecutor-线程池"><a href="#TreadPoolExecutor-线程池" class="headerlink" title="TreadPoolExecutor 线程池"></a>TreadPoolExecutor 线程池</h3><p>为什么需要线程池？</p>
<blockquote>
<p>线程池是一种并发编程的技术，用于管理和复用线程。它由一组预先创建的线程组成，这些线程可以被重复使用来执行多个任务。线程池的主要目的是优化线程的创建和销毁过程，以提高程序的性能和资源利用率。</p>
<p>以下是一些使用线程池的好处：</p>
<ol>
<li>降低线程创建和销毁的开销：线程的创建和销毁是一项开销较高的操作，涉及到操作系统的调度和资源管理。通过使用线程池，可以预先创建一组线程，并重复使用它们来执行多个任务，避免了频繁的创建和销毁线程的开销。</li>
<li>提高系统的响应性：在多线程环境下，任务提交给线程池后可以立即开始执行，而不需要等待新线程的创建。这样可以大大减少任务的等待时间，提高系统的响应性和吞吐量。</li>
<li>控制并发数量：线程池可以通过设置最大线程数来限制并发执行的任务数量。这可以帮助我们控制系统资源的使用，避免过多的线程竞争和资源抢占导致的性能下降或系统崩溃。</li>
<li>提供任务排队和调度机制：线程池通常提供了任务队列，用于存储待执行的任务。当线程池中的线程空闲时，它们可以从任务队列中获取任务并执行。这种任务调度机制可以有效地平衡任务的执行，并确保任务按照预期的顺序和优先级进行处理。</li>
<li>资源管理和监控：线程池可以提供一些额外的功能，如线程超时管理、线程数动态调整、异常处理等。它们可以帮助我们更好地管理和监控线程的行为，提高程序的稳定性和可靠性。</li>
</ol>
<p>总之，线程池是一种有效管理线程的技术，它能够提高程序的性能、响应性和资源利用率。通过合理配置线程池的大小和参数，可以更好地控制线程的并发数量，避免资源竞争和性能问题，提供更好的用户体验和系统可靠性。</p>
</blockquote>
<p>简单使用</p>
<ul>
<li>ThreadPoolExecutor()  线程池对象</li>
<li>task.submit 注册函数到线程池中</li>
<li>task.cancel 取消 task 的运行</li>
<li>task.result 线程的运行结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"></span><br><span class="line"><span class="comment"># futures 可以让多进程和多线程编码接口一致</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">times</span>):</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;get page <span class="subst">&#123;times&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    executor = ThreadPoolExecutor(max_workers=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 通过 submit 函数提交执行的函数到线程池中，submit 是立即返回</span></span><br><span class="line">    <span class="comment"># task1 = executor.submit(get_html, (3,))</span></span><br><span class="line">    <span class="comment"># task2 = executor.submit(get_html, (2,))</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># print(task1.done())</span></span><br><span class="line">    <span class="comment"># print(task2.cancel())</span></span><br><span class="line">    <span class="comment"># time.sleep(3)</span></span><br><span class="line">    <span class="comment"># print(task1.done())</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取已经成功的 task 的返回</span></span><br><span class="line">    urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">    all_task = [executor.submit(get_html, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    <span class="comment"># wait 控制主线程的推出</span></span><br><span class="line">    wait(all_task, return_when=FIRST_COMPLETED)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">        data = future.result()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;get <span class="subst">&#123;data&#125;</span> page&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 通过 executor 的 map 获取已经完成的值</span></span><br><span class="line">    <span class="comment"># for data in executor.map(get_html, urls):</span></span><br><span class="line">    <span class="comment">#     print(f&quot;get &#123;data&#125; page&quot;)</span></span><br></pre></td></tr></table></figure>



<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span>(<span class="params">_base.Executor</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Used to assign unique thread names when thread_name_prefix is not supplied.</span></span><br><span class="line">    _counter = itertools.count().__next__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, max_workers=<span class="literal">None</span>, thread_name_prefix=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initializes a new ThreadPoolExecutor instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            max_workers: The maximum number of threads that can be used to</span></span><br><span class="line"><span class="string">                execute the given calls.</span></span><br><span class="line"><span class="string">            thread_name_prefix: An optional name prefix to give our threads.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> max_workers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Use this number because ThreadPoolExecutor is often</span></span><br><span class="line">            <span class="comment"># used to overlap I/O instead of CPU work.</span></span><br><span class="line">            max_workers = (os.cpu_count() <span class="keyword">or</span> <span class="number">1</span>) * <span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> max_workers &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;max_workers must be greater than 0&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self._max_workers = max_workers</span><br><span class="line">        self._work_queue = queue.Queue()</span><br><span class="line">        self._threads = <span class="built_in">set</span>()</span><br><span class="line">        self._shutdown = <span class="literal">False</span></span><br><span class="line">        self._shutdown_lock = threading.Lock()</span><br><span class="line">        self._thread_name_prefix = (thread_name_prefix <span class="keyword">or</span></span><br><span class="line">                                    (<span class="string">&quot;ThreadPoolExecutor-%d&quot;</span> % self._counter()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">submit</span>(<span class="params">self, fn, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">with</span> self._shutdown_lock:</span><br><span class="line">            <span class="keyword">if</span> self._shutdown:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;cannot schedule new futures after shutdown&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            f = _base.Future()</span><br><span class="line">            w = _WorkItem(f, fn, args, kwargs)</span><br><span class="line"></span><br><span class="line">            self._work_queue.put(w)</span><br><span class="line">            self._adjust_thread_count()</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line">    submit.__doc__ = _base.Executor.submit.__doc__</span><br></pre></td></tr></table></figure>

<p>在上述的源码中，我们通过 submit 函数模块可以比较清楚的看到一个 函数 是如何注册到 Future 中的</p>
<ul>
<li><p>创建一个锁 <code>Thread.Lock()</code> 保证线程安全</p>
</li>
<li><p>创建 Future() 实例 并将其作为参数传递到 work_item 中, 并 put 到 队列中</p>
<ul>
<li><strong>Future——未来对象，可以理解为 task 的容器对象，其中包含了 task 的执行情况，理解 Future 的设计理念是 Python 异步编程中的关键；</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Represents the result of an asynchronous computation.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initializes the future. Should not be called by clients.&quot;&quot;&quot;</span></span><br><span class="line">        self._condition = threading.Condition()</span><br><span class="line">        self._state = PENDING</span><br><span class="line">        self._result = <span class="literal">None</span></span><br><span class="line">        self._exception = <span class="literal">None</span></span><br><span class="line">        self._waiters = []</span><br><span class="line">        self._done_callbacks = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_invoke_callbacks</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> callback <span class="keyword">in</span> self._done_callbacks:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                callback(self)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                LOGGER.exception(<span class="string">&#x27;exception calling callback for %r&#x27;</span>, self)</span><br></pre></td></tr></table></figure>

<p>可以看到其中也使用了 <code>threading.Condition</code> 来控制线程的管理</p>
<ul>
<li>_workItem</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_WorkItem</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, future, fn, args, kwargs</span>):</span></span><br><span class="line">        self.future = future</span><br><span class="line">        self.fn = fn</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.future.set_running_or_notify_cancel():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = self.fn(*self.args, **self.kwargs)</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">            self.future.set_exception(exc)</span><br><span class="line">            <span class="comment"># Break a reference cycle with the exception &#x27;exc&#x27;</span></span><br><span class="line">            self = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.future.set_result(result)</span><br></pre></td></tr></table></figure>

<p>其中比较重要的代码为：<code>result = self.fn(*self.args, **self.kwargs)</code> &amp;&amp; <code>self.future.set_result(result)</code></p>
</li>
</ul>
<p>​        分别是 运行函数，并获取结果，以及将结果保存至 future 中</p>
<ul>
<li>_adjust_thread_count() 函数，控制线程池的大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_adjust_thread_count</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="comment"># When the executor gets lost, the weakref callback will wake up</span></span><br><span class="line">      <span class="comment"># the worker threads.</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">weakref_cb</span>(<span class="params">_, q=self._work_queue</span>):</span></span><br><span class="line">        q.put(<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># TODO(bquinlan): Should avoid creating new threads if there are more</span></span><br><span class="line">        <span class="comment"># idle threads than items in the work queue.</span></span><br><span class="line">        num_threads = <span class="built_in">len</span>(self._threads)</span><br><span class="line">        <span class="keyword">if</span> num_threads &lt; self._max_workers:</span><br><span class="line">          thread_name = <span class="string">&#x27;%s_%d&#x27;</span> % (self._thread_name_prefix <span class="keyword">or</span> self,</span><br><span class="line">                                   num_threads)</span><br><span class="line">          t = threading.Thread(name=thread_name, target=_worker,</span><br><span class="line">                               args=(weakref.ref(self, weakref_cb),</span><br><span class="line">                                     self._work_queue))</span><br><span class="line">          t.daemon = <span class="literal">True</span></span><br><span class="line">          t.start()</span><br><span class="line">          self._threads.add(t)</span><br><span class="line">          _threads_queues[t] = self._work_queue</span><br></pre></td></tr></table></figure>

<ul>
<li><p>target = _worker() 运行函数的主体对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_worker</span>(<span class="params">executor_reference, work_queue</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            work_item = work_queue.get(block=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">if</span> work_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                work_item.run()</span><br><span class="line">                <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">                <span class="keyword">del</span> work_item</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            executor = executor_reference()</span><br><span class="line">            <span class="comment"># Exit if:</span></span><br><span class="line">            <span class="comment">#   - The interpreter is shutting down OR</span></span><br><span class="line">            <span class="comment">#   - The executor that owns the worker has been collected OR</span></span><br><span class="line">            <span class="comment">#   - The executor that owns the worker has been shutdown.</span></span><br><span class="line">            <span class="keyword">if</span> _shutdown <span class="keyword">or</span> executor <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> executor._shutdown:</span><br><span class="line">                <span class="comment"># Notice other workers</span></span><br><span class="line">                work_queue.put(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">del</span> executor</span><br><span class="line">    <span class="keyword">except</span> BaseException:</span><br><span class="line">        _base.LOGGER.critical(<span class="string">&#x27;Exception in worker&#x27;</span>, exc_info=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这里不断从 wok_queue 中获取 work_item 实例，然后调用其 run 方法，然后销毁依赖；</p>
</li>
<li><p>_threads_queues 是继承自 MutableMapping 保存线程池中的队列对象</p>
</li>
</ul>
<p>以上就是多线程编程的全部内容</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际的开发工作中，对于 CPU 密集型的任务，可以考虑多进程编程；</p>
<p>对于 IO 密集型的任务，可以考虑多线程编程；</p>
<p>多线程的缺点就是 GIL  的存在以及锁会影响性能；</p>
<p>但是进程的创建和销毁会高于线程，所以要结合具体应用场景去使用哦</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程编程</title>
    <url>/posts/31a6b40/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>今天我们一起来学习多进程编程，在学习之前，首先介绍一下什么是进程：</p>
<p>进程是计算机中正在运行的<strong>程序实例</strong>。它包含程序的<strong>执行代码、数据和系统资源</strong>。每个进程都是在自己的虚拟空间中运行，使得它们<strong>相互隔离</strong>，不会直接干扰其他进程的执行。</p>
<p>它是操作系统进行进行调度的基本单位。</p>
<p>进程的状态：</p>
<ul>
<li>运行态（Running）: 当前正在 CPU 上执行的进程。</li>
<li>就绪态（Ready）: 等待分配 CPU 资源，一旦获得 CPU 时间片，即可切换到运行态。</li>
<li>阻塞态（Blocked）: 因为某些事件（input/output）而暂停运行，直到事件完成后进入就绪态</li>
</ul>
<p>进程间的通信（IPC）：由于进程之间是相互隔离的，如果需要进行进程间的数据传递或同步操作，就需要使用进程间的通信。常见的 IPC 的方式有：管道、消息队列、共享内存等</p>
<h2 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h2><p>本次学习使用 python 进行编程。我们知道在 python 中由于 GIL 锁的存在，每次只有一个线程在执行代码，这样的话，在耗 CPU 的情况下，就无法充分利用到计算机的多核，于是就需要使用 <strong>多进程编程</strong>。</p>
<p>通过一个例子我们来学习 python 中的多进程编程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sub_progress success&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    progress = multiprocessing.Process(target=get_html, args=(<span class="number">2</span>,))</span><br><span class="line">    progress.start() <span class="comment"># 执行</span></span><br><span class="line">    progress.join() <span class="comment"># 阻塞当前进程，直到主进程完成</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main progress end&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在 python 中多进程编程的模块是 <code>multiprocessing </code>, 具体操作的相关函数可以查阅</p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p>接下来，我们将一起学习进程池的使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool = multiprocessing.Pool(multiprocessing.cpu_count()) <span class="comment"># 创建进程池</span></span><br><span class="line">result = pool.apply_async(get_html, args=(<span class="number">3</span>,)) <span class="comment"># 提交单个任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有任务执行完成</span></span><br><span class="line"><span class="comment"># 关闭进程池</span></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"><span class="built_in">print</span>(result.get())</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="imap"><a href="#imap" class="headerlink" title="imap"></a>imap</h3><p>imap 方法的特点就是它可以将一个函数应用于一个可迭代对象的所有元素，并且在多个进程中并行执行这些函数。这意味着其可以高效地并行处理大量数据，从而加速任务的执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = pool.imap(get_html, [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>对于这个 result 中，其执行完成的顺序是谁先执行完成，就先输出。</p>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p>进程间的通信主要是通过以下几种方式进行：</p>
<ul>
<li>Queue</li>
<li>Pipe</li>
<li>Manager</li>
</ul>
<p><strong>对于共享全局变量而言是不可行的，因为当一个进程进行 fork 的时候，就会对父进程的全局变量数据进行复制。</strong></p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>首先我们来学习 Queue 队列，这里的 Queue 和多线程编程是不一样的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br></pre></td></tr></table></figure>

<p>以上的 Queue 只适用于多线程。而多进程间的通信则需要使用 <code>multiprocess.Queue</code>,后续文章中，我会对这二者的底层进行学习，然后对比学习，感兴趣的同学可以自行学习。</p>
<p>这里我使用一个生产者-消费者模型进行学习：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;receive data: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line">    p = multiprocessing.Process(target=producer, args=(queue,))</span><br><span class="line">    c = multiprocessing.Process(target=consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    p.start()</span><br><span class="line">    c.start()</span><br><span class="line"></span><br><span class="line">    p.join()</span><br><span class="line">    c.join()</span><br></pre></td></tr></table></figure>

<h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>进程间的通信还可以使用管道进行通信，使用方法和 queue 类似，但是注意 pipe 的初始化：<code>send_pipe, recv_pipe = Pipe()</code>, pipe 只适用于两个进程之间的通信。当只需要两个进程时，pipe 的性能高于 Queue.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    pipe.send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    data = pipe.recv()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;receive data: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    send_pipe, recv_pipe = Pipe()</span><br><span class="line"></span><br><span class="line">    p = multiprocessing.Process(target=producer, args=(send_pipe,))</span><br><span class="line">    c = multiprocessing.Process(target=consumer, args=(recv_pipe,))</span><br><span class="line"></span><br><span class="line">    p.start()</span><br><span class="line">    c.start()</span><br><span class="line"></span><br><span class="line">    p.join()</span><br><span class="line">    c.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h2><p><strong>在上文中，我们使用到了进程池 pool, 对于进程池而言， <code>multiprocessing.Queue()</code> 和 <code>multiprocessing.pipe()</code> 都是不可行的。而 Manager 模块的设计正是为了解决这一点。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue, Pipe, Manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;receive data: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Manager().Queue()</span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    p = pool.apply_async(producer, args=(queue,))</span><br><span class="line">    c = pool.apply_async(consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>



<p>在 manager 中有很多共享内存类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncManager</span>(<span class="params">BaseManager</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BoundedSemaphore</span>(<span class="params">self, value: <span class="type">Any</span> = ...</span>) -&gt; threading.BoundedSemaphore:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Condition</span>(<span class="params">self, lock: <span class="type">Any</span> = ...</span>) -&gt; threading.Condition:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Event</span>(<span class="params">self</span>) -&gt; threading.Event:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Lock</span>(<span class="params">self</span>) -&gt; threading.Lock:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Namespace</span>(<span class="params">self</span>) -&gt; _Namespace:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Queue</span>(<span class="params">self, maxsize: <span class="built_in">int</span> = ...</span>) -&gt; queue.Queue[<span class="type">Any</span>]:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">RLock</span>(<span class="params">self</span>) -&gt; threading.RLock:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Semaphore</span>(<span class="params">self, value: <span class="type">Any</span> = ...</span>) -&gt; threading.Semaphore:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Array</span>(<span class="params">self, typecode: <span class="type">Any</span>, sequence: <span class="type">Sequence</span>[_T]</span>) -&gt; <span class="type">Sequence</span>[_T]:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Value</span>(<span class="params">self, typecode: <span class="type">Any</span>, value: _T</span>) -&gt; ValueProxy[_T]:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dict</span>(<span class="params">self, sequence: Mapping[_KT, _VT] = ...</span>) -&gt; _dict[_KT, _VT]:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, sequence: <span class="type">Sequence</span>[_T] = ...</span>) -&gt; _list[_T]:</span> ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些都可以用于进程间的通信</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器和生成器的实现原理</title>
    <url>/posts/30d97d60/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="什么是迭代协议-？"><a href="#什么是迭代协议-？" class="headerlink" title="什么是迭代协议 ？"></a>什么是迭代协议 ？</h2><p>这里我们可以查看 <code>collections.abc</code> 中的两个对象：<code>Iterable</code> <code>Iterator</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@runtime_checkable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterable</span>(<span class="params">Protocol[_T_co]</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>) -&gt; Iterator[_T_co]:</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@runtime_checkable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>(<span class="params">Iterable[_T_co], Protocol[_T_co]</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>) -&gt; _T_co:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>) -&gt; Iterator[_T_co]:</span> ...</span><br></pre></td></tr></table></figure>

<p>这里我们来观察一下 list 是否是可迭代对象或者是一个迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator, Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, Iterable))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, Iterator))</span><br><span class="line">    <span class="comment"># output</span></span><br><span class="line">    <span class="literal">True</span></span><br><span class="line">		<span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道 list 只实现了一个 <code>__iter__</code> 方法，并未实现，所以 list 是一个可迭代对象而不是迭代器；</p>
<p>所以，实现了 <code>__iter__</code> 魔法方法的对象是一个可迭代对象，实现了 <code>__iter__</code> &amp;&amp; <code>__next__</code> 方法的是一个迭代器。</p>
<h2 id="如何将一个可迭代对象转换为迭代器"><a href="#如何将一个可迭代对象转换为迭代器" class="headerlink" title="如何将一个可迭代对象转换为迭代器"></a>如何将一个可迭代对象转换为迭代器</h2><p>答案是 python 内置的 <code>iter()</code></p>
<p>这里只需要使用 iter() 就可以将 a 转换为一个迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    a = <span class="built_in">iter</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, Iterable))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, Iterator))</span><br><span class="line">		<span class="comment"># output</span></span><br><span class="line">    <span class="literal">True</span></span><br><span class="line">    <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, employee_list</span>):</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __iter__(self):</span></span><br><span class="line">    <span class="comment">#     return self.employee</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.employee[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.employee)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = Company([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>在这个类中 ，我们并未实现 <code>__iter__</code> 函数，而是实现了 <code>__getitem__</code> 函数，并且也能使用 for 循环，这是为什么呢？</p>
<p>实际上，for 循环时，会自动去调用 <code>iter()</code>，然后去查找魔法方法 <code>__iter__</code> ，如果没有就会去查找 <code>__getitem__</code> 方法。</p>
<p>为了更好地理解这些逻辑，我们将模仿 iter() 实现一个迭代器，将上述的 company 变为一个可迭代对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, employee_list</span>):</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> MyIter(self.employee)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __getitem__(self, item):</span></span><br><span class="line">    <span class="comment">#     return self.employee[item]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.employee)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, employee_list</span>):</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.employee[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = Company([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># output: 1 2 3</span></span><br></pre></td></tr></table></figure>



<p>实际上将 <code>__next__</code> 类定义在 Company 也可以，但是基于迭代器的设计模式，对于另外的属性，例如 self.index 会污染 Company 类属性。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p><strong>函数中只要有 yield 关键字，就是一个生成器函数</strong></p>
<blockquote>
<p> python 编译字节码的时候就生成了一个生成器对象</p>
</blockquote>
<p>先来看一段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gen = gen_func() <span class="comment"># 返回一个 generator 对象</span></span><br><span class="line">    fun = func()     <span class="comment"># 返回 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># output 1, 2, 3</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们将 yield 关键字和 return 关键字进行了比较，可以看到，其两个函数返回的对象是不一致的，gen 返回了一个生成器对象，而 fun 返回了一个 int 类型的值。并且 gen 是可以被迭代的。</p>
<p>这是为什么呢？这是因为 在 python 解释器编译字节码时，遇到 yield 关键字时，自动将其转换为了一个 生成器对象，且生成器也是实现了迭代器协议的。</p>
<p>为了更好地解释 yield 关键字的用途，这里采用<strong>斐波拉契函数</strong>来进一步理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt; index &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(index-<span class="number">1</span>) + fib(index-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span>(<span class="params">index</span>):</span></span><br><span class="line">  re_list = []</span><br><span class="line">  n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> n &lt; index:</span><br><span class="line">    re_list.append(b)</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">    n = n+<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> re_list</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(fib(<span class="number">10</span>))</span><br><span class="line">   <span class="comment"># output 55</span></span><br></pre></td></tr></table></figure>

<p><strong>在上述的代码中，fib2 还原了斐波拉契的生成过程，记录了每次的值，但是当数据量非常大时，例如几千万上亿时，那么这个数据是非常大的，就会特别消耗内存。而 yield 关键字刚好能解决这个问题：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span>(<span class="params">index</span>):</span></span><br><span class="line">  n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> n &lt; index:</span><br><span class="line">		<span class="keyword">yield</span> b</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">    n = n+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> fib2(<span class="number">10</span>):</span><br><span class="line">      <span class="built_in">print</span>(i)</span><br><span class="line">   <span class="comment"># output</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    8</span></span><br><span class="line"><span class="string">    13</span></span><br><span class="line"><span class="string">    21</span></span><br><span class="line"><span class="string">    34</span></span><br><span class="line"><span class="string">    55</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这样改动下来，yield 只会占用一点点内存，且在 for 循环时，会记录每次的生成值，刚好解决了这个问题。</strong></p>
<h2 id="生成器原理"><a href="#生成器原理" class="headerlink" title="生成器原理"></a>生成器原理</h2><h3 id="python-中函数的工作原理"><a href="#python-中函数的工作原理" class="headerlink" title="python 中函数的工作原理"></a>python 中函数的工作原理</h3><p>先了解一个 python 中函数的调用原理：</p>
<blockquote>
<p>在Python中，栈帧（stack frame）是独立存在的。每当一个函数被调用时，Python会在调用栈中创建一个栈帧来保存该函数的局部变量、参数、返回地址等信息。</p>
<p>栈帧是函数调用的上下文，它包含了函数执行过程中的相关信息。每个栈帧都是独立的，包含了函数的局部状态，并且按照调用的顺序进行组织。当函数执行结束后，对应的栈帧会被弹出栈，从而回到上一个函数的执行环境。</p>
<p>每个栈帧都包含以下几个重要的组成部分：</p>
<ol>
<li>局部变量：栈帧中保存了函数的局部变量，包括函数参数和在函数内部定义的变量。</li>
<li>返回地址：栈帧中保存了函数执行结束后的返回地址，用于指示程序继续执行的位置。</li>
<li>异常处理信息：栈帧中保存了与异常处理相关的信息，用于捕获和处理异常。</li>
</ol>
<p>由于栈帧是独立的，每个栈帧都可以保持自己的状态，并且可以同时存在多个栈帧。这使得Python可以实现递归调用和函数的嵌套调用。</p>
<p>总结：在Python中，栈帧是独立存在的，它保存了函数调用的上下文信息，包括局部变量、返回地址和异常处理信息。每个函数调用都会创建一个新的栈帧，并按照调用顺序组织在调用栈中。栈帧的独立存在使得Python能够支持递归调用和函数的嵌套调用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    bar()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis <span class="comment"># 字节码库</span></span><br><span class="line">    <span class="built_in">print</span>(dis.dis(foo)) <span class="comment">#字节码执行过程</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      9       0 LOAD_GLOBAL              0 (bar)</span></span><br><span class="line"><span class="string">              2 CALL_FUNCTION            0</span></span><br><span class="line"><span class="string">              4 POP_TOP</span></span><br><span class="line"><span class="string">              6 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">              8 RETURN_VALUE</span></span><br><span class="line"><span class="string">	   None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<p>从上述的代码中，我们可以看到，对于 foo 函数而言，python 解释器会创建一个栈祯来保存该函数的相关信息</p>
<p><strong>所有的栈祯都是分配在堆内存上，这就决定了栈祯可以独立于调用者存在</strong></p>
<p>用一段代码来解释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">frame = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    bar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="keyword">global</span> frame</span><br><span class="line">    frame = inspect.currentframe()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    foo()</span><br><span class="line">    <span class="built_in">print</span>(frame.f_code.co_name)</span><br><span class="line">    caller_frame = frame.f_back</span><br><span class="line">    <span class="built_in">print</span>(caller_frame.f_code.co_name)</span><br><span class="line"><span class="comment"># bar</span></span><br><span class="line"><span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们引入了 inspect 包来查看 栈祯保存的一些信息，</p>
<p>通过 <code>frame = inspect.currentframe()</code> 来保存当前函数 bar 的栈祯。可以看到，通过 <code>frame.f_code.co_name</code> 打印的是 <code>bar</code>, 而且还可以通过 <code>frame.f_back </code> 还可以查看上一个栈祯的信息即 foo。</p>
<p>通过这段代码，<strong>我们就能更加理解 python 解释器在运行一个 函数时的操作了，让我们明白对于递归调用而言，函数的调用是可控的，可溯源的，这也是 python 生成器的前提</strong></p>
<p>![image-20230702003450166](/Users/tyronemaxi/Library/Application Support/typora-user-images/image-20230702003450166.png)</p>
<p>![image-20230702003852334](/Users/tyronemaxi/Library/Application Support/typora-user-images/image-20230702003852334.png)</p>
<p>用一段代码解释生成器的运行原理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    name = <span class="string">&quot;bobby&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    age = <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;imooc&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    <span class="built_in">print</span>(dis.dis(gen))</span><br><span class="line">    <span class="built_in">print</span>(gen.gi_frame.f_lasti)</span><br><span class="line">    <span class="built_in">print</span>(gen.gi_frame.f_locals)</span><br><span class="line">    <span class="built_in">next</span>(gen)</span><br><span class="line">    <span class="built_in">print</span>(gen.gi_frame.f_lasti)</span><br><span class="line">    <span class="built_in">print</span>(gen.gi_frame.f_locals)</span><br><span class="line">    <span class="built_in">next</span>(gen)</span><br><span class="line">    <span class="built_in">print</span>(gen.gi_frame.f_lasti)</span><br><span class="line">    <span class="built_in">print</span>(gen.gi_frame.f_locals)</span><br><span class="line">    <span class="built_in">next</span>(gen)</span><br><span class="line">    <span class="built_in">print</span>(gen.gi_frame.f_lasti)</span><br><span class="line">    <span class="built_in">print</span>(gen.gi_frame.f_locals)</span><br></pre></td></tr></table></figure>

<p>打印信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  9           0 LOAD_CONST               1 (&#x27;哈哈&#x27;)</span><br><span class="line">              2 YIELD_VALUE</span><br><span class="line">              4 POP_TOP</span><br><span class="line"></span><br><span class="line"> 10           6 LOAD_CONST               2 (&#x27;bobby&#x27;)</span><br><span class="line">              8 STORE_FAST               0 (name)</span><br><span class="line"></span><br><span class="line"> 11          10 LOAD_CONST               3 (&#x27;嘻嘻&#x27;)</span><br><span class="line">             12 YIELD_VALUE</span><br><span class="line">             14 POP_TOP</span><br><span class="line"></span><br><span class="line"> 12          16 LOAD_CONST               4 (30)</span><br><span class="line">             18 STORE_FAST               1 (age)</span><br><span class="line"></span><br><span class="line"> 13          20 LOAD_CONST               5 (&#x27;imooc&#x27;)</span><br><span class="line">             22 RETURN_VALUE</span><br><span class="line">None</span><br><span class="line">-1</span><br><span class="line">&#123;&#125;</span><br><span class="line">2</span><br><span class="line">&#123;&#125;</span><br><span class="line">12</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;bobby&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析一下打印信息：</p>
<p>首先，我们使用 dis 模块 <code>print(dis.dis(gen))</code> 打印栈祯的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  9           0 LOAD_CONST               1 (&#x27;哈哈&#x27;)</span><br><span class="line">              2 YIELD_VALUE</span><br><span class="line">              4 POP_TOP</span><br><span class="line"></span><br><span class="line"> 10           6 LOAD_CONST               2 (&#x27;bobby&#x27;)</span><br><span class="line">              8 STORE_FAST               0 (name)</span><br><span class="line"></span><br><span class="line"> 11          10 LOAD_CONST               3 (&#x27;嘻嘻&#x27;)</span><br><span class="line">             12 YIELD_VALUE</span><br><span class="line">             14 POP_TOP</span><br><span class="line"></span><br><span class="line"> 12          16 LOAD_CONST               4 (30)</span><br><span class="line">             18 STORE_FAST               1 (age)</span><br><span class="line"></span><br><span class="line"> 13          20 LOAD_CONST               5 (&#x27;imooc&#x27;)</span><br><span class="line">             22 RETURN_VALUE</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<p>我们可以看到对于 <code>gen_func</code> 的每一行代码而言，都保存了相关信息；</p>
<p>其中 <code>YIELD_VALUE</code> 就是对应 yield 关键字</p>
<p><strong>通过 <code>gen.gi_frame</code> 打印 PyGenObject 中的 <code>f_lasti</code> <code>f_locals</code></strong></p>
<ul>
<li><strong>f_lasti 当前祯的最后指令的索引</strong></li>
<li><strong>f_locals 当前祯的局部变量字典</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(gen.gi_frame.f_lasti)</span><br><span class="line"><span class="built_in">print</span>(gen.gi_frame.f_locals)</span><br></pre></td></tr></table></figure>

<h2 id="生成器如何读取一个大文件"><a href="#生成器如何读取一个大文件" class="headerlink" title="生成器如何读取一个大文件"></a>生成器如何读取一个大文件</h2><p>例如现在有一个巨大的文件 500G 左右，没有换行符，且只有一行数据，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python is the best language in world | xi xi xi|xxxxxx| hahaha ....</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_big_file</span>(<span class="params">f, sep_str</span>):</span></span><br><span class="line">    buf = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> sep_str <span class="keyword">in</span> buf:</span><br><span class="line">            pos = buf.index(sep_str)  <span class="comment"># 每次只读取一个分隔符内容部分</span></span><br><span class="line">            <span class="keyword">yield</span> buf[:pos]</span><br><span class="line">            buf = buf[pos + <span class="built_in">len</span>(sep_str):]</span><br><span class="line"></span><br><span class="line">        chunk = f.read(<span class="number">4096</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">            <span class="comment"># 已经读到了文件结尾</span></span><br><span class="line">            <span class="keyword">yield</span> buf</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        buf += chunk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> read_big_file(f, <span class="string">&quot;|&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>

<p>常规分块读取文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file_in_chunks</span>(<span class="params">file_path, chunk_size</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = file.read(chunk_size)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&#x27;path/to/file.txt&#x27;</span></span><br><span class="line">chunk_size = <span class="number">1024</span>  <span class="comment"># 每次读取的块大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> read_file_in_chunks(file_path, chunk_size):</span><br><span class="line">    <span class="comment"># 处理每个块的数据</span></span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="协程应用"><a href="#协程应用" class="headerlink" title="协程应用"></a>协程应用</h2><h3 id="C-10M-问题"><a href="#C-10M-问题" class="headerlink" title="C 10M 问题"></a>C 10M 问题</h3><p>如何利用 8 核 CPU , 64 G内存，在 10 g bps 的网络上保持 1000 万的并发连接；</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 常用的魔法方法</title>
    <url>/posts/c0462762/</url>
    <content><![CDATA[<h2 id="Python-常用魔法方法"><a href="#Python-常用魔法方法" class="headerlink" title="Python 常用魔法方法"></a>Python 常用魔法方法</h2><p><a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id2">https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id2</a></p>
<blockquote>
<p>为了实现更好的可扩展性，Python 语言提供了大量的特殊方法，它们大致可分为以下几类：</p>
<ul>
<li><p>特性访问（Attribute Access）这类特殊方法实现了对象的特性访问，使用方法为 <code>object.attribute</code> ，既可以用来赋值，也可以在 del 语句中执行删除操作。</p>
</li>
<li><p>可调用对象（Callables）: 这个方法的适用对象为参数，就像 Python 内部的 len() 函数</p>
</li>
<li><p>集合（Collections）这类方法提供了很多集合操作的功能。类似这类方法的使用有 sequence[index]、mapping[key] 和 some_set | another_set</p>
</li>
<li><p>数字（Numbers）: 这类方法提供了大量的数学运算符和比较运算符。</p>
</li>
<li><p>上下文(Context)：这类函数通常使用 with 语句来实现上下文的管理</p>
</li>
<li><p>迭代器(Iterator)：可以使用这类方法定义迭代器</p>
</li>
</ul>
</blockquote>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h3><p>在我们调用 <code>x=SomeClass()</code> 的时候，<code>__init__</code> 并不是第一个被调用的方法，事实上，第一个被调用的是 <code>__new__</code> ，这个方法才真正地创建了实例。当这个对象的生命周期结束的时候，<code>__del__</code> 会被调用。</p>
<ul>
<li><p><code>__new__(cls, [...])</code></p>
<p><code>__new__</code> 是对象实例化时第一个调用的方法，它只取下 <code>cls</code> 参数，并将其它参数传给 <code>__init__</code> 。<code>__init__</code> 很少使用，但是它也有它合适的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。但是其并不是很有用。</p>
</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h3><ul>
<li><p>对象的初始化</p>
</li>
<li><p><code>__init__</code> 方法的参数可以多种形式来完成赋值</p>
</li>
</ul>
<blockquote>
<p>object 类是所有类的基类，对于任何自定义类，都会隐式继承 object。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">X.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">type</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">X</span>.<span class="title">__class__</span>.<span class="title">__base__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>对于每个 <code>__init__</code>方法，都应当显式地指定要初始化的变量。</strong></p>
<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><p><code>__new__</code> 和 <code>__init__</code> 是对象的构造器，<code>__del__</code>是对象的销毁器。它并非实现了语句 del x</p>
<p>而是定义了当对象被垃圾回收时的行为。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># __new__ 方法实现单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    init_flag = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> SingleNode.init_flag:</span><br><span class="line">            self.do_something()</span><br><span class="line">            SingleNode.init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;do something...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    single = SingleNode()</span><br><span class="line">    <span class="built_in">print</span>(single, <span class="built_in">id</span>(single))</span><br><span class="line">    single2 = SingleNode()</span><br><span class="line">    <span class="built_in">print</span>(single2, <span class="built_in">id</span>(single))</span><br></pre></td></tr></table></figure>

<h2 id="集合、序列相关"><a href="#集合、序列相关" class="headerlink" title="集合、序列相关"></a>集合、序列相关</h2><p>有许多办法可以让你的 Python 类表现得像是内建序列类型（字典，元组，列表，字符串等）</p>
<p>在 Python 中，协议完全是非正式的，也不需要显式的声明，事实上，它们更像是一种参考标准。</p>
<p>在 Python 中实现自定义容器类型需要用到一些协议。首先，不可变容器类型有如下协议：想实现一个不可变容器，你需要定义<code>__len__</code> 和 <code>__getitem__</code> 。可变容器的协议除了上面提到的两个方法之外，还需要定义 <code>__setitem__</code> 和 <code>__delitem__</code> 。最后，如果你想让你的对象可迭代，你需要定义<code>__iter__</code>,这个方法返回一个迭代器。迭代器必须遵守迭代器协议，需要定义 <code>__iter__</code> 和 next 方法。</p>
<ul>
<li><p><code>__len__(self)</code></p>
<p>返回容器的长度，可变和不可变类型都需要实现</p>
</li>
<li><p><code>__getitem__(self, key)</code></p>
<p>定义对容器中某一项使用 <code>self[key]</code> 的方式读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误时产生 TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常</p>
</li>
<li><p><code>__setitem__(self, key)</code></p>
<p>定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 KeyError 和 TypeError 异常</p>
</li>
<li><p><code>__reversed__(self)</code></p>
<p>定义了对容器使用 <code>reversed()</code> 内建函数时的行为。它应该返回一个反转之后的序列。</p>
</li>
<li><p><code>__contains__(self, item)</code> </p>
<p>定义了使用 in 和 not in 进行成员测试时的行为。</p>
</li>
<li><p><code>__missing__(self, key)</code> </p>
<p><code>__missing__</code> 在字典的子类中使用，它定义了当试图访问一个字典中不存在的键的行为。例如 d[“george”] 中不存在 george key 时，就会调用 <code>d.__missing__</code></p>
</li>
</ul>
<h3 id="迭代相关"><a href="#迭代相关" class="headerlink" title="迭代相关"></a>迭代相关</h3><ul>
<li><p><code>__iter__</code></p>
<p>它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用 </p>
<p><code>iter()</code> 函数调用，以及在类似 for x in container 的循环中被调用。</p>
</li>
<li><p><code>__next__</code><br>这个方法每次返回迭代的值，在没有可迭代元素的时候，抛出 <code>StopIteration</code> 异常<br>实现迭代器协议的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A 实现了迭代器协议 它的实例就是一个迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.idx = <span class="number">0</span></span><br><span class="line">        self.n = n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__iter__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.idx &lt; self.n:</span><br><span class="line">            val = self.idx</span><br><span class="line">            self.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br></pre></td></tr></table></figure>
<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2></li>
</ul>
<h2 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h2><p>使用 Python 魔法方法的一个巨大优势就是可以构建一个拥有 Python 内置类型行为的对象。这意味着你可以避免使用非标准的、丑陋的方式来表达简单的操作。</p>
<ul>
<li><code>__cmp__</code>是所有比较魔法方法中最基础的一个，它实际上定义了所有比较操作符的行为（&lt;, ==, != 等等）</li>
<li><code>__lt__</code> <code>__le__()</code> <code>__eq__</code> <code>__ne__</code> <code>__gt__()</code> <code>__get__</code></li>
</ul>
<h2 id="访问控制-amp-amp-属性相关"><a href="#访问控制-amp-amp-属性相关" class="headerlink" title="访问控制 &amp;&amp; 属性相关"></a>访问控制 &amp;&amp; 属性相关</h2><blockquote>
<p>Python 不是通过显式定义的字段和方法修改器，而是通过魔法方法实现了一系列的封装</p>
</blockquote>
<ul>
<li><p><code>_getattr__(self, name)</code></p>
<p>当用户试图访问一个根本不存在的属性时，你可以通过这个魔法方法来定义类的行为。这个可以用于捕捉错误的拼写并且给出指引。只有当试图访问不存在的属性时它才会被调用。</p>
</li>
<li><p><code>__setattr__(self, name, value)</code></p>
<p>它可以用于真正意义上的封装。允许你自定义某个属性的赋值行为，不管这个属性存在与否，也就是说你可以对任意属性的任何变化都定义自己的规则。</p>
</li>
<li><p><code>__delattr__(self, name)</code></p>
<p>用于处理删除属性时的行为。和 <code>__setattr__</code>一样，使用它时也需要多加小心，防止产生无限递归</p>
</li>
<li><p><code>__getattribute__</code>看起来和上面那些方法很合得来，但是最好不要使用它。</p>
<p>允许你自定义属性被访问时的行为，它也同样可能遇到无限递归问题。<code>__getattribute__</code>基本上可以替代<code>__getattr__</code> 只有当它被使用，并且显式地被调用，或者产生 AttributeError 时它才被调用。不推荐被使用</p>
</li>
</ul>
<h2 id="与-Python-无缝集成——基本特殊方法"><a href="#与-Python-无缝集成——基本特殊方法" class="headerlink" title="与 Python 无缝集成——基本特殊方法"></a>与 Python 无缝集成——基本特殊方法</h2><blockquote>
<p>Python 中有一些特殊方法，它们允许我们的类和 Python 更好地集成。在标准库参考中，它们被称为<strong>基本特殊方法</strong>，是与 Python 的其他特性无缝集成的基础</p>
<p>例如：</p>
<ul>
<li><code>__repr__</code> <code>__str__</code> 标准化表示对象的值</li>
<li><code>__hash__</code> <code>__bool__</code> <code>__byts__</code> 转换方法</li>
<li><code>__lt__</code> <code>__le__()</code> <code>__eq__</code> <code>__ne__</code> <code>__gt__()</code> <code>__get__</code></li>
<li><code>__new__</code> <code>__del__</code></li>
</ul>
</blockquote>
<h3 id="repr-amp-amp-str-方法"><a href="#repr-amp-amp-str-方法" class="headerlink" title="__repr__&amp;&amp; __str__ 方法"></a><code>__repr__</code>&amp;&amp; <code>__str__</code> 方法</h3><blockquote>
<p>对于一个对象，Python 提供了两种字符串表示方法。它们和内建函数 <code>repr()</code> <code>str()</code> <code>print</code> <code>string.format()</code> 功能是一致的</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr">https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr</a></p>
<ul>
<li><p>通常，<code>str()</code> 方法表示的对象<strong>对用户更加友好</strong>。这个方法是由对象的 <code>__str__</code> 方法实现的</p>
</li>
<li><p><code>repr()</code> 方法的表示通常<strong>会更加技术化</strong>，甚至有可能是一个完整的 Python 表达式</p>
</li>
<li><p>容器 <code>__str__</code> 使用包含的对象 <code>__repr__</code></p>
</li>
</ul>
<p>默认情况下，二者的行为一致</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import datetime</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; today = datetime.datetime.now()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; str(today)</span></span><br><span class="line">&#x27;2012-03-14 09:21:58.130922&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; repr(today)</span></span><br><span class="line">&#x27;datetime.datetime(2012, 3, 14, 9, 21, 58, 130922)&#x27;</span><br></pre></td></tr></table></figure>



<h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>上下文管理的概念在 Python 中并不是全新引入的（之前它作为标准库的一部分实现），直到 PEP 343 才被接受，它才成为一种一级的语言结构</p>
<p>类似：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>. <span class="built_in">open</span>(<span class="string">&quot;f.txt&quot;</span>) <span class="keyword">as</span> bar:</span><br><span class="line">  f.read()</span><br></pre></td></tr></table></figure>

<p>当对象使用 with 声明创建时，上下文管理器允许类做一些设置和清理工作。上下文管理器的行为由下面两个魔法方法所定义：</p>
<ul>
<li><p><code>__enter__</code></p>
<p>定义使用 with 声明创建的语句块最开始上下文管理器应该做些什么。<code>__enter__</code> 的返回值会赋给 with 声明的目标，也就是 as 之后的东西。</p>
</li>
<li><p><code>__exit__</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContext</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># __enter__的返回值被as后面的变量接收</span></span><br><span class="line">        self.name = <span class="string">f&#x27;Big <span class="subst">&#123;self.name&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">		<span class="comment"># __exit__在with中的语句结束之后立即执行</span></span><br><span class="line">		<span class="comment"># 假如with管辖的上下文内没有抛出任何异常，当解释器出发__exit__方法时，其三个参数都为None，如果有异常抛出则三个参数会有具体内容</span></span><br><span class="line">		<span class="comment"># exc_type：异常类型，exc_value：异常对象，traceback：错误的堆栈对象</span></span><br><span class="line">		<span class="comment"># __exit__返回值：True：异常被忽略， False：异常正常抛出</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Exiting MyContext&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> MyContext(<span class="string">&#x27;王大锤&#x27;</span>) <span class="keyword">as</span> me:</span><br><span class="line">        <span class="built_in">print</span>(me.name)</span><br></pre></td></tr></table></figure>



<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id5">https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id5</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的设计模式</title>
    <url>/posts/70c3aece/</url>
    <content><![CDATA[<h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p><strong>工厂模式属于创建者模式</strong></p>
<p>工厂模式：目的时提供方便快捷的对象创建方式，当对象的创建类型多样时，可以使用工厂方法；</p>
<p>当对象与对象关系较复杂时，且存在关联时，可构建抽象工厂方法；</p>
</blockquote>
<p>工厂模式属于创建型模式，<strong>目的是提供更好的创建对象的方式</strong></p>
<p>工厂模式通常有两种：</p>
<ul>
<li>工厂方法（Factory Method）—— 它是一个方法，对于<strong>不同的参数返回不同的对象</strong></li>
<li>抽象工厂，它是一组用于<strong>创建一系列相关事物对象</strong>的工厂方法，例如一辆车的各个部件</li>
</ul>
<p><strong>两种模式都可以用于以下场景：</strong></p>
<ul>
<li> <strong>想要追踪对象的创建时</strong></li>
<li><strong>想要将对象的创建与使用解耦时</strong></li>
<li><strong>想要优化性能和资源占用时</strong></li>
</ul>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>Django 框架中使用工厂方法模式来创建表单字段。Django 的 forms 模块支持不同类型的字段（CharField、EmailField）</p>
<blockquote>
<p><a href="https://github.com/django/django/blob/main/django/forms/fields.py">https://github.com/django/django/blob/main/django/forms/fields.py</a></p>
</blockquote>
<p>创建多个工厂方法也完全没有问题，实践中通常也这么做，对相似的对象创建进行逻辑分组，每个工厂负责一个组。</p>
<p>工厂犯法可以在必要时创建新的对象，从而提高性能和内存使用率。若直接实例化类来创建对象，那么需要分配额外的内存</p>
<p>例如：XML、Atom、YAML、JSON 解析器</p>
<p><strong>DEMO</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> etree</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonParser</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filepath: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filepath, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self._data = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLParser</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filepath: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self._tree = etree.parse(filepath)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parser_factory</span>(<span class="params">filepath: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> filepath.endswith(<span class="string">&#x27;json&#x27;</span>):</span><br><span class="line">        parser = JsonParser</span><br><span class="line">    <span class="keyword">elif</span> filepath.endswith(<span class="string">&#x27;xml&#x27;</span>):</span><br><span class="line">        parser = XMLParser</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;cannot found the parser of <span class="subst">&#123;filepath&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser(filepath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    json_factory = parser_factory(<span class="string">&quot;./test.json&quot;</span>)</span><br><span class="line">    j_data = json_factory.data</span><br><span class="line">    <span class="built_in">print</span>(j_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>一个抽象工厂是（逻辑上的）一组工厂方法，其中的每个工厂方法负责产生不同种类的对象</p>
<p>抽象工厂模式是工厂方法的一种泛化，所以它能提供相同的好处。</p>
<p><strong>我们怎么知道何时该使用工厂方法，何时又该使用抽象工厂？答案是，通常一开始时使用工厂方法，因为它更简单。如果后续发现应用需要许多工厂方法，那么将创建一系列对象的过程合并在一起更合理，从而最终引入抽象工厂。</strong></p>
<p><strong>DEMO</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类别：男巫</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wizard</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interact_with</span>(<span class="params">self, obstacle</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; the Wizard battles against &#123;&#125; and &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(self, obstacle, obstacle.action()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别二、兽人</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ork</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;an evil ork&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;kills it&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别二、工厂方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WizardWorld</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        self.player_name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\n\n\t------ Wizard World ———&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_character</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Wizard(self.player_name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_obstacle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Ork()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象工厂方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameEnvironment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, factory</span>):</span></span><br><span class="line">        self.hero = factory.make_character()</span><br><span class="line">        self.obstacle = factory.make_obstacle()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.hero.interact_with(self.obstacle)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 一堆参数设置</span></span><br><span class="line">    environment = GameEnvironment(game(name))</span><br><span class="line">    environment.play()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式允许我们将一个提供核心功能的对象和其他可以改变这个功能的对象”包裹”在一起。</p>
<p>装饰器模式主要有两种用途：</p>
<ul>
<li>增强一个组件向另一个组件发送数据时的响应能力</li>
<li>支持多种可选行为</li>
</ul>
<p><strong>闭包方式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_call</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;func.__name__&#125;</span> running...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log_call</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_example</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run_example()</span><br></pre></td></tr></table></figure>

<p><strong>对象方式</strong></p>
<p><code>__call__</code> 方法是实现对象方式的关键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, params</span>):</span></span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># do something</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>主要用<strong>处理一个系统中不同实体（比如类和对象）之间的关系，关注的是提供一种简单的对象组合方式来创造新的功能</strong></p>
<p><strong>适配器模式（Adapter pattern）的主要作用就是把原本不兼容的接口，通过适配修改做到统一。</strong></p>
<blockquote>
<p>如果我们希望把一个老组件用于一个新系统中，或者反过来，在一个新系统中兼容老的组件，这时就需要编写一个额外的代码层，该代码层包含让两个接口之间能够通信需要进行所有修改。</p>
</blockquote>
<p>例如：每个类都实现自己语言，使用适配器进行适配，使得每个实例发出声音</p>
<p><strong>DEMO</strong></p>
<p><code>__dict__</code> &amp;&amp; <code>__getattr__</code>是实现适配器的关键</p>
<blockquote>
<p><code>__getattr__</code>()是仅当属性不能在实例的<code>__dict__</code>或它的类(类的<code>__dict__</code>),或父类的<code>__dict__</code>中找到时，才被调用。一般在代码中包含一个对getattr()內建函数的调用</p>
<p>每一个类都会用一个字典，把它包含的属性放到自己的字典里。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Dog&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;woof!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Cat&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">meow</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;meow!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Human&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27;hello&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Car&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_noise</span>(<span class="params">self, octane_level</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;vroom%s&quot;</span> % (<span class="string">&quot;!&quot;</span> * octane_level)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj, adapted_methods</span>):</span></span><br><span class="line">        self.obj = obj</span><br><span class="line">        self.__dict__.update(adapted_methods)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.obj, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    objects = []</span><br><span class="line">    dog = Dog()</span><br><span class="line">    objects.append(Adapter(dog, <span class="built_in">dict</span>(make_noise=dog.bark)))</span><br><span class="line">    cat = Cat()</span><br><span class="line">    objects.append(Adapter(cat, <span class="built_in">dict</span>(make_noise=cat.meow)))</span><br><span class="line">    human = Human()</span><br><span class="line">    objects.append(Adapter(human, <span class="built_in">dict</span>(make_noise=human.speak)))</span><br><span class="line">    car = Car()</span><br><span class="line">    car_noise = <span class="keyword">lambda</span>: car.make_noise(<span class="number">3</span>)</span><br><span class="line">    objects.append(Adapter(car, <span class="built_in">dict</span>(make_noise=car_noise)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> objects:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>, obj.name, <span class="string">&quot;goes&quot;</span>, obj.make_noise())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p>外观模式在很多方面与适配器模式相同。主要的区别在于，外观模式试图从一个复杂的系统中抽象出一个简单的接口；而适配器只不过是将一个现有的接口匹配到另一个。</p>
</blockquote>
<p><strong>外观模式的目的是为拥有多个组件的复杂系统提供简单的接口。</strong>这个系统内的对象为了完成复杂的任务和交互需求会进行各种直接的交互。该系统通常存在某些典型的用途</p>
<blockquote>
<p>这里用一个<strong>自己泡茶</strong>和<strong>去茶馆喝茶</strong>的例子，自己泡茶的话，需要自行准备茶叶、茶具和开水，而自己去茶馆喝茶，最简单的方式就是和茶馆服务员说想要一杯什么茶，是铁观音、碧螺春还是西湖龙井。</p>
</blockquote>
<p>这里典型的茶的种类就是典型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright DataGrand Tech Inc. All Rights Reserved.</span></span><br><span class="line"><span class="string">Author: tianzhichao</span></span><br><span class="line"><span class="string">File: facade.py</span></span><br><span class="line"><span class="string">Time: 2023/2/20 10:27 PM</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Water</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_water</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hot water&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeaPot</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_teapot</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;get teapot&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">red_tea</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;red tea&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.water = Water()</span><br><span class="line">        self.teapot = TeaPot()</span><br><span class="line">        self.tea = Tea()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_red_tea</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.water.get_water()</span><br><span class="line">        self.teapot.get_teapot()</span><br><span class="line">        self.tea.red_tea()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tea_client</span>():</span></span><br><span class="line">    facade = Facade()</span><br><span class="line">    facade.get_red_tea()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tea_client()</span><br></pre></td></tr></table></figure>



<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式在撞见检测和事件处理等场景中时非常有用的。</p>
<p>这种模式确保一个 核心 对象可以由一组未知并可能正在扩展的 观察者 对象来监控。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inventory</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._product = <span class="literal">None</span></span><br><span class="line">        self._quality = <span class="number">0</span></span><br><span class="line">        self.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._product</span><br><span class="line"></span><br><span class="line"><span class="meta">    @product.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._product = value</span><br><span class="line">        self._update_observer()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_observer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            observer()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleObserver</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inventory</span>):</span></span><br><span class="line">        self._inventory = inventory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;the name of product: <span class="subst">&#123;self._inventory.product&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    i = Inventory()</span><br><span class="line">    c = ConsoleObserver(i)</span><br><span class="line">    i.attach(c)</span><br><span class="line"></span><br><span class="line">    i.product = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式是一种内存优化模式。由于对象创建的开销，面向对象的系统可能会面临性能问题。</p>
<p>当我们创建一个新对象时，需要分配额外内存</p>
<p>享元设计模式通过为相似对象引入数据共享来最小化内存使用，提升性能。</p>
<p>一个享元（Flyweight）就是一个包含状态独立的不可变（又称固有的）数据的共享对象。依赖状态的可变（又称非固有的）数据不应是享元的一部分，因为每个对象的这种信息都不同，无法共享。若享元需要非固有的数据，应该由客户端代码显式地提供。</p>
<p>享元模式使用的几个条件</p>
<ul>
<li>应用需要大量的对象</li>
<li>对象太多，存储/渲染它们的代价太大。一旦移除对象中的可变状态（因为在需要之时，应该由客户端代码显式地传递给享元），多组不同的对象可被相对更少的共享对象所替代。</li>
<li>对象 ID 对于应用不重要。对象共享会造成 ID 比较的失败，所以不能依赖对象 ID </li>
</ul>
<p><strong>DEMO</strong></p>
<p>例如在一个游戏中，需要很多树对象，不变的是树对象的样子，变化的地方是树的年纪和坐标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">TreeType = Enum(<span class="string">&#x27;TreeType&#x27;</span>, <span class="string">&#x27;apple_tree cherry_tree peach_tree&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tree</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    tree_pool = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, tree_type</span>):</span></span><br><span class="line">        <span class="comment"># 判断树的类型</span></span><br><span class="line">        obj = cls.tree_pool.get(tree_type, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj:</span><br><span class="line">            obj = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">            cls.tree_pool[tree_type] = obj</span><br><span class="line">            obj.tree_type = tree_type</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 位置坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span>(<span class="params">self, age, x, y</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;render a tree of type <span class="subst">&#123;self.tree_type&#125;</span> and age <span class="subst">&#123;age&#125;</span> at (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 以下仅分配了 3 课树的内存</span></span><br><span class="line">    age_min, age_max = <span class="number">1</span>, <span class="number">30</span></span><br><span class="line">    min_point, max_point = <span class="number">0</span>, <span class="number">100</span></span><br><span class="line">    tree_counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        t1 = Tree(TreeType.apple_tree)</span><br><span class="line">        t1.render(random.randint(age_min, age_max),</span><br><span class="line">                  random.randint(min_point, max_point),</span><br><span class="line">                  random.randint(min_point, max_point)</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">        tree_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t2 = Tree(TreeType.cherry_tree)</span><br><span class="line">        t2.render(random.randint(age_min, age_max),</span><br><span class="line">                  random.randint(min_point, max_point),</span><br><span class="line">                  random.randint(min_point, max_point)</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">        tree_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t3 = Tree(TreeType.peach_tree)</span><br><span class="line">        t3.render(random.randint(age_min, age_max),</span><br><span class="line">                  random.randint(min_point, max_point),</span><br><span class="line">                  random.randint(min_point, max_point)</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">        tree_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;trees rendered: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(tree_counter))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;trees actually created: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(Tree.tree_pool)))</span><br><span class="line"></span><br><span class="line">    t4 = Tree(TreeType.cherry_tree)</span><br><span class="line">    t5 = Tree(TreeType.cherry_tree)</span><br><span class="line">    t6 = Tree(TreeType.apple_tree)</span><br><span class="line">    t7 = Tree(TreeType.peach_tree)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(Tree.tree_pool)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; == &#123;&#125;? &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(t4), <span class="built_in">id</span>(t5), <span class="built_in">id</span>(t4) == <span class="built_in">id</span>(t5)))    <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; == &#123;&#125;? &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(t5), <span class="built_in">id</span>(t6), <span class="built_in">id</span>(t5) == <span class="built_in">id</span>(t6)))    <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令设计模式帮助我们将一个操作（撤销、重做、复制、粘贴）封装成一个对象。</p>
<p>这意味着创建一个类，包含实现该操作所需要的所有逻辑和方法。这样做的优势如下：</p>
<ul>
<li>我们并不需要直接执行一个命令。命令可以按照希望执行</li>
<li>调用命令的对象与指导如何执行命令的对象解耦。调用者无需知道命令的实现细节。</li>
<li>如果有意义，可以将多个命令组织起来，这样调用者能够按顺序执行它们，例如，在实现一个多层撤销命令时，这是很有用的。</li>
</ul>
<h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><ul>
<li>GUI 按钮和菜单项：PyQt 例子使用命令模式来实现按钮和菜单项上的的动作</li>
<li>其他操作：除了撤销，命令模式可以实现任何操作。其中一些例子包括剪切、复制、粘贴、重做，文本大写</li>
<li>事务性行为和日志记录：事务型行为和日志记录对于为变更记录一份持久化日志是很重要的。操作系统用他来从系统奔溃中恢复，关系型数据库用它来实现事务，文件系统用它来实现 snapshot，而安装程序（向导程序）用它来恢复取消的安装</li>
<li>宏：在这里，宏是指一个动作序列，可在任意时间点按要求进行录制和执行。流行的编辑器（比如 Emacs 和 Vim）都支持宏。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现最基本的文件操作工具</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright DataGrand Tech Inc. All Rights Reserved.</span></span><br><span class="line"><span class="string">Author: tianzhichao</span></span><br><span class="line"><span class="string">File: command.py</span></span><br><span class="line"><span class="string">Time: 2023/2/21 11:20 PM</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line">verbose = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenameFile</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    重命名文件，包含撤销操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateFile</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建文件，包含撤销操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path, txt=<span class="string">&quot;hello world\n&quot;</span></span>):</span></span><br><span class="line">        self.path = path</span><br><span class="line">        self.txt = txt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadFile</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteFile</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h1><p>领域驱动设计：<a href="https://book.douban.com/subject/26819666/">https://book.douban.com/subject/26819666/</a></p>
<p>软件设计：<a href="https://l1nwatch.gitbook.io/python-design-mode/">https://l1nwatch.gitbook.io/python-design-mode/</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则——面向对象的 SOLID 原则（python）</title>
    <url>/posts/d1e9fd6c/</url>
    <content><![CDATA[<h1 id="设计原则——面向对象的-SOLID-原则（python）"><a href="#设计原则——面向对象的-SOLID-原则（python）" class="headerlink" title="设计原则——面向对象的 SOLID 原则（python）"></a>设计原则——面向对象的 SOLID 原则（python）</h1><p>在软件开发中，如何做到代码的可读，可复用，可扩展，稳定是需要一些编程原则和编程思维。故开始对设计原则进行理解和学习，并结合具体案例分析。本文采用 python3 进行代码编写。</p>
<h2 id="职责单一原则-SRP"><a href="#职责单一原则-SRP" class="headerlink" title="职责单一原则- SRP"></a>职责单一原则- SRP</h2><blockquote>
<p> Single Responsibility Principle</p>
</blockquote>
<blockquote>
<p>A class or module should have a single responsibility </p>
</blockquote>
<blockquote>
<p>一个类或者模块只负责完成一个职责或者说功能</p>
</blockquote>
<p><strong>一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。</strong></p>
<p>在我的理解中，对于日常开发而言，对于一个产品可能有很多需求原型，有很多模块和零散的模块。对于每个模块的功能点，可以进行归纳总结，业务抽象，具体到设计类和方法。</p>
<p><strong>那么问题来了？如何判断该是否需要用到职责单一的原则？</strong></p>
<p>我这里举个例子：用户模块和订单模块就是两个独立的模块。这里只举例用户模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户模块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserMeta</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用户信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, user_id: <span class="built_in">str</span>, name: <span class="built_in">str</span>, age: <span class="built_in">str</span>, address: <span class="built_in">str</span>, cellphone: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self.user_id = user_id</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.address = address</span><br><span class="line">        self.cellphone = cellphone</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span>    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCtrl</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用户操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_user_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>在上述的代码中，我们创建了一个用户模块，其中包含 <code>UserMeta</code> 用户信息类和 <code>UserCtrl</code>用户操作类。这种类设计的模式在 MVC 架构的设计中很常见。</p>
<p>当然，随着业务的变化和公司产品的升级，需要不断的扩展和设计类，那么就需要结合实际的情况来进行扩展了。</p>
<p>例如，当公司的社交产品比较多的时候，需要一个统一的用户登陆认证中心，那么就需要从顶层开始设计登陆模块，这个时候就不单单是代码的重构，可能也包含服务的重构，对于多来源，多用户，需要对认证相关的信息（例如邮件、手机号、用户名）拆分开来。</p>
<p>以下是我的理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAuthMeta</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用户认证信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, user_id, name, password, cellphone, email, third_id, login_type</span>):</span></span><br><span class="line">        self.user_id = user_id</span><br><span class="line">        self.name = name</span><br><span class="line">        self.password = password</span><br><span class="line">        self.cellphone = cellphone</span><br><span class="line">        self.email = email</span><br><span class="line">        self.third_id = third_id</span><br><span class="line">        self.login_type = login_type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginInterface</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, userinfo: <span class="built_in">dict</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CellphoneLogin</span>(<span class="params">LoginInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, userinfo: <span class="built_in">dict</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailLogin</span>(<span class="params">LoginInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, userinfo: <span class="built_in">dict</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WechatLogin</span>(<span class="params">LoginInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, userinfo: <span class="built_in">dict</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<p>在上述代码中，我从顶层抽象了一个登陆功能的接口，然后支持不同方式的登陆，对于用户认证，每种方式需要有不同的处理逻辑，故封装了 login 方法来处理。</p>
<p><strong>综上，在实际的代码开发中，一个业务总是从简单到复杂，那么对业务的发展也非常考验开发人员的重构能力，并没有一个非常明确的、可以量化的标准。我们也没有必要过度设计，需要结合场景具体分析。在设计初期，可以先写一个粗粒度的类，拆分成几个更细粒度的类，然后随着业务的设计迭代不断重构。</strong></p>
<h2 id="对扩展开放、修改关闭-OCP"><a href="#对扩展开放、修改关闭-OCP" class="headerlink" title="对扩展开放、修改关闭 - OCP"></a>对扩展开放、修改关闭 - OCP</h2><blockquote>
<p>Open Closed Principle</p>
<p>software entities should be open for extension, but closed for modification.</p>
</blockquote>
<p><strong>简单表述一下就是，添加一个新的功能应该是，在已有代码的基础上扩展代码（新增模块、类、方法等），而非修改已有的代码（修改模块、类、方法）。</strong></p>
<p>对于这条原则，是一个难以应用和最有用的一个原则，这是因为，扩展性是代码质量最重要的衡量标准之一，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵循的设计原则就是开闭原则。</p>
<p>这里为了更好地理解这个原则，举一个 API 接口监控告警的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alert</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, alert_rule, notification</span>):</span></span><br><span class="line">        self.alert_rule = alert_rule</span><br><span class="line">        self.notification = notification</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, api, request_count, error_count, duration_of_seconds</span>):</span></span><br><span class="line">        tps = request_count / duration_of_seconds</span><br><span class="line">        <span class="keyword">if</span> tps &gt; self.alert_rule.get_matched_rule(api).get_max_tps:</span><br><span class="line">            self.notification.notify(notificationEmergencyLevel.URgency, <span class="string">&quot;...&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> error_count &gt; rule.get_matched_rule(api).get_max_errorcount():</span><br><span class="line">            notification.notify(notificationEmergencyLevel.URgency, <span class="string">&quot;...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，当接口的 TPS 超过某个预先设置的最大值时，以及当前接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。</p>
<p>现在有一个新的需求是：当接口的超时时间超过我们设计的阈值时，也要触发告警，应该如何设计？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alert</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, alert_rule, notification</span>):</span></span><br><span class="line">        self.alert_rule = alert_rule</span><br><span class="line">        self.notification = notification</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, api, request_count, error_count, duration_of_seconds, timeout_count</span>):</span></span><br><span class="line">        tps = request_count / duration_of_seconds</span><br><span class="line">        <span class="keyword">if</span> tps &gt; self.alert_rule.get_matched_rule(api).get_max_tps:</span><br><span class="line">            self.notification.notify(notificationEmergencyLevel.URgency, <span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> error_count &gt; rule.get_matched_rule(api).get_max_errorcount():</span><br><span class="line">            notification.notify(notificationEmergencyLevel.URgency, <span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout_count / duration_of_seconds) &gt; self.rule.get_matchedRule(api).get_max_tps():</span><br><span class="line">            notification.notify(notificationEmergencyLevel.URgency, <span class="string">&quot;...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>在上述的代码中，我们新增了 <code>timeout_count</code> 和 判断是否告警的逻辑，这样就违背了开闭原则</strong></p>
<p>那么应该如何设计呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIStatInfo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, api: <span class="built_in">str</span>, requestCount: <span class="built_in">int</span>, errorCount: <span class="built_in">int</span>, durationOfSeconds: <span class="built_in">int</span>, timeout_count</span>):</span></span><br><span class="line">        self.api = api</span><br><span class="line">        self.requestCount = requestCount</span><br><span class="line">        self.errorCount = errorCount</span><br><span class="line">        self.timeoutCount = timeout_count</span><br><span class="line">        self.durationOfSeconds = durationOfSeconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alert</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.handlers = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_handler</span>(<span class="params">self, handler</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, api_stat_info: APIStatInfo</span>):</span></span><br><span class="line">        <span class="keyword">for</span> handler <span class="keyword">in</span> self.handlers:</span><br><span class="line">            handler.check(api_stat_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rule, notification</span>):</span></span><br><span class="line">        self.rule = rule</span><br><span class="line">        self.notification = notification</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPSAlertHandler</span>(<span class="params">AlertHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rule, notification</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(rule, notification)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.rule &gt; <span class="string">&quot;设定的阈值&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;监控告警逻辑&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeoutAlertHandler</span>(<span class="params">AlertHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rule, notification</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(rule, notification)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.rule &gt; <span class="string">&quot;设定的阈值&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;监控告警逻辑&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我对原有的类进行了扩展，对于每个 API 的状态信息进行了封装：<code>APIStatInfo</code> 类，然后对于每种监控抽象出来了一个接口类用于扩展。</p>
<p>当新增一个 timeout 的需求时，我只需要在 <code>APIStatInfo</code> 类中添加 <code>timeout_count</code> 信息和扩展一个 <code>TimeoutAlertHandler</code> 类就可以做到满足开闭原则了。</p>
<p><strong>综上所述：在上述例子中，演示了如何设计一个可扩展的类，用于后续的扩展。那么有人就要问了，不是对修改关闭吗，为什么 <code>APIStatInfo</code> 中的代码修改了，对于修改这个词，我们要正确的认识，在本人的开发经历中，对于新需求的添加，很少有做到完全对原有代码不修改的，我们所谓的对修改关闭，实则是要做到让修改更集中，更少，更上层，尽量让最核心、最复杂的部分逻辑满足开闭原则。</strong></p>
<h2 id="里氏替换——LSP"><a href="#里氏替换——LSP" class="headerlink" title="里氏替换——LSP"></a>里氏替换——LSP</h2><blockquote>
<p>Liskov Substitution Principle, 缩写为 LSP。这个原则最早是在 1986 年由 Barbara Liskov 提出：</p>
<p>if S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</p>
<p>在 1996 年，Robert Martin 在他的 SOLID 原则中，重新描述了这个原则：</p>
<p>Functions that use pointers of references to base classes must be able to use objects of derived classes without konwing it。</p>
</blockquote>
<p>用中文结合描述就是：子类对象（object of subtype/derived class） 能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>
<p>具体定义可以分为：</p>
<ul>
<li>子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类覆盖或实现父类的方法时，方法的前置条件（方法的形参）要比父类的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件(即方法的返回值)要比父类更严格。</li>
</ul>
<p>我们用一个鸟类的继承来说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birds = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect_bird</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.birds.append(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swallow</span>(<span class="params">Bird</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子类必须实现父类的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;swallow flying&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子类不能覆盖父类的非抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect_bird</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子类可以实现自己的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;swallow singing&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>对于为什么子类必须实现父类的抽象方法，个人的理解是这样的，在面向对象中的继承中，父类的抽象方法对于子类而言是一种协议，是必须实现的，是用来约束的。</strong></p>
<p><strong>而对于父类中非抽象的方法，多数是一些常用方法，对于子类或者父类都是通用的逻辑，如果改变，将导致一些问题。</strong></p>
<h2 id="接口隔离原则——ISP"><a href="#接口隔离原则——ISP" class="headerlink" title="接口隔离原则——ISP"></a>接口隔离原则——ISP</h2><blockquote>
<p>Interface Segregation Principle, 缩写为 ISP. Robert Martin 在 SOLID 原则中是这样定义的： Client should not be forced to depend upon interfaces that they donot use.</p>
<p>即客户端不应该被强迫依赖它不需要的接口。</p>
</blockquote>
<p>对于接口隔离而言，首先我们需要理解接口二字，有以下常规理解：</p>
<ul>
<li>一组 API 接口集合</li>
<li>单个 API 接口或函数</li>
<li>OOP 中的接口概念</li>
</ul>
<p>这里结合一个例子来理解：在一个微服务用户中心中，有一组跟用户相关的 API 给其他系统使用，比如注册、登陆、获取用户信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_user_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>现在对于后台系统而言，对于一些违规用户，我们是需要对其进行拉黑处理或者封禁处理的。那么应该如何操作，常规的思路就是在该接口下定义一个 <code>unbidden()</code> 方法。但是这样设计的话，会有一些操作隐患，因为这个接口只限于后台管理系统，对于前端系统而言是不可调用的，如果不加限制的被其他业务系统调用，就会导致一些安全问题。</p>
<h3 id="一组-API-接口集合"><a href="#一组-API-接口集合" class="headerlink" title="一组 API 接口集合"></a>一组 API 接口集合</h3><p>最好的办法就是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。再者可以参考接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放置另外一个接口。</p>
<p>于是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_user_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictUserInterface</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unbidden_user</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnbiddenUser</span>(<span class="params">RestrictUserInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unbidden_user</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;限制用户的一些操作&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="接口理解为单个-API-或者函数"><a href="#接口理解为单个-API-或者函数" class="headerlink" title="接口理解为单个 API 或者函数"></a>接口理解为单个 API 或者函数</h3><p>在这部分我们可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Statistics</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">max</span>, <span class="built_in">min</span>, average, <span class="built_in">sum</span></span>):</span></span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line">        self.<span class="built_in">min</span> = <span class="built_in">min</span></span><br><span class="line">        self.average = average</span><br><span class="line">        self.<span class="built_in">sum</span> = <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">statistics</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;计算的具体逻辑&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>在上述的代码中，对于统计而言，有很多个统计项，按照接口隔离而言，应该将不同的统计拆分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>当然，在这方面，接口隔离和职责单一而言比较类似，但是单一职责针对的是模块、类、接口的设计。接口隔离更多指的是每种接口应该实现其特有的方法。</p>
<h3 id="将接口理解为-OOP-中的接口概念"><a href="#将接口理解为-OOP-中的接口概念" class="headerlink" title="将接口理解为 OOP 中的接口概念"></a>将接口理解为 OOP 中的接口概念</h3><p>这里是将接口理解为 <code>interface</code>，例如 go/java 中的 interface</p>
<p>例如在我们的项目中，有三个外部系统：<code>Redis</code>, <code>mysql</code>,  <code>kafka</code>。每个系统都对应一系列的配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，分别设计了三个 Config 类： RedisConfig, MysqlConfig, KafkaConfig.</p>
<p>like this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, configSource, address, timeout, maxTotal,</span>):</span></span><br><span class="line">        self.configSource = configSource</span><br><span class="line">        self.address = address</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.maxTotal = maxTotal</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 从 configsource 中加载配置</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;更新的具体逻辑&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>但是现在有一个需求，就是以固定时间的方式更新配置，且在不重启服务的情况下，这就是热更新；</p>
<p>为了实现这个需求，我们需要设计一个调度类<code>SchedulerUpdater</code> 来支持热更新， </p>
<p>于是，为了使得接口隔离，抽象出 <code>Updater</code> 与 <code>Viewer</code> 但是来实现，前者更新，后者显示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Updater</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Viewer</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span>(<span class="params">Updater</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, configSource, address, timeout, maxTotal,</span>):</span></span><br><span class="line">        self.configSource = configSource</span><br><span class="line">        self.address = address</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.maxTotal = maxTotal</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 从 configsource 中加载配置</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;更新的具体逻辑&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchedulerUpdater</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, schedulerservice, per_seconds, updater</span>):</span></span><br><span class="line">        self.scheulserservice = schedulerservice</span><br><span class="line">        self.per_seconds = per_seconds</span><br><span class="line">        self.updater = updater</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.scheulserservice(self.per_seconds, self.per_seconds)</span><br></pre></td></tr></table></figure>



<p>在这样的扩展下，就实现了接口隔离，每个接口对应不同的功能。</p>
<h2 id="依赖反转原则——DIP"><a href="#依赖反转原则——DIP" class="headerlink" title="依赖反转原则——DIP"></a>依赖反转原则——DIP</h2><blockquote>
<p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p>
<p>高层模块（high-level modules ）不要依赖底层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象不要依赖具体的实现细节，具体的实现细节依赖抽象。</p>
</blockquote>
<p><strong>所谓高层模块和低层模块，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。</strong></p>
<p><strong>在 python 中，实现依赖倒置原则通常使用接口抽象和依赖注入技术。具体来说，我们可以将代码组织为两个层次，即高层代码和低层模块。高层模块负责处理业务逻辑，低层模块负责提供基础服务。二者之间通过抽象接口进行通信，从而实现了解耦合。</strong></p>
<p><strong>同样，我们通过一个例子来学习：</strong></p>
<p><strong>当我们需要一份数据时，这份数据可能有很多个来源，例如文件或者数据库，当对文件进行解析时，需要用到不同的解析器，我们可以抽象出一个 <code>Reader</code> 接口管理低层解析类，在 <code>DataView</code> 使用时，不用关心 <code>reader</code> 的具体实现，只需要知道调用其中的 <code>read()</code> 方法即可，这样就可以满足 DIP 原则了。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileReader</span>(<span class="params">Reader</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Reading from file&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseReader</span>(<span class="params">Reader</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;reading from database&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高层模块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataView</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, reader</span>):</span></span><br><span class="line">        self.reader = reader</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.reader.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 低层模块</span></span><br><span class="line">    file_reader = FileReader()</span><br><span class="line">    database_reader = DatabaseReader()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 依赖注入</span></span><br><span class="line">    processor1 = DataView(file_reader)</span><br><span class="line">    processor2 = DataView(DatabaseReader)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用高层模块</span></span><br><span class="line">    processor1.show_data()</span><br><span class="line">    processor2.show_data()</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天总结学习了面向对象的五大原则：</p>
<ul>
<li>职责单一</li>
<li>开闭原则</li>
<li>接口隔离</li>
<li>里氏代换</li>
<li>依赖反转</li>
</ul>
<p>其中职责单一原则是为了对模块，类进行划分，每个类，每个模块都只做一件事。</p>
<p>开闭原则更多的是关注代码的可扩展性，在软件开发中，业务需求是不断迭代的，对于如何写出可扩展的代码，需要我们使用开闭原则进行规范，即对组合开放，对修改关闭。</p>
<p>接口隔离适用于比较复杂的业务场景，和职责单一原则息息相关，对于每种接口而言，是隔离的，这样在使用和扩展时，就会比较清晰。</p>
<p>里氏代换原则更多的考虑是代码的健壮性，即在继承和多态时，对于抽象方法和非抽象方法的约束，保证继承链条的健壮，保证调用时不会出错。</p>
<p>依赖反转描述的是高层和低层的关系，二者通过接口抽象协议进行通信，低层负责干活，高层只负责到指定的地方去拿数据，不需要考虑低层的实现方式，高层是不依赖于低层的具体实现的。</p>
<p><strong>以上就是全部内容了，上述原则都是为了写出可读，可扩展，可复用，稳定的代码。代码设计讲究均衡和适合，在了解这些原则的时候也要清楚一点，就是不要强搬硬套，避免过度设计</strong></p>
]]></content>
      <categories>
        <category>设计原则</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 进程、线程、协程</title>
    <url>/posts/76b43893/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>参考：<a href="https://www.cnblogs.com/panlq/p/13180589.html">https://www.cnblogs.com/panlq/p/13180589.html</a><br><strong>进程是系统进行资源分配和调度的独立单位，<code>程序段</code>、<code>数据段</code>、<code>PCB(进程控制模块)</code>三部分组成了<code>进程 实体(进程映像)</code>，PCB 是进程存在的唯一标准</strong></p>
<blockquote>
<p>操作系统为了管理进程设置的一个专门的<code>数据结构</code>，用它来记录进程的外部特征，描述进程的运动变化进程。系统利用 PCB 来控制和管理进程，所以 <strong>PCB 是系统感知进程存在的唯一标志</strong>。进程与 PCB 是一一对应的。<br>detail: <a href="http://www.haodaquan.com/159">http://www.haodaquan.com/159</a></p>
</blockquote>
<h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p><img src="../../images/threads/PCB.png" alt="direct"></p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul>
<li><strong>创建态</strong><br>操作系统为进程分配资源， 初始化 PCB</li>
<li><strong>就绪态</strong><br>运行资源等条件都满足，存储在就绪队列中，等待 CPU 调度</li>
<li><strong>运行态</strong><br>CPU 正在执行进程</li>
<li><strong>阻塞态</strong><br>等待某些条件满足，等待消息回复，等待同步锁，Sleep 等，阻塞队列</li>
<li><strong>终止态</strong><br>回收进程拥有的资源，撤销 PCB</li>
</ul>
<h2 id="进程之间的转换"><a href="#进程之间的转换" class="headerlink" title="进程之间的转换"></a>进程之间的转换</h2><p><img src="../../images/threads/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png" alt="img.png"></p>
<h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><blockquote>
<p>进程的调度、切换是有代价的</p>
</blockquote>
<ul>
<li><ol>
<li>对原来运行进程的各种数据的保存</li>
</ol>
</li>
<li><ol start="2">
<li>对新的进程各种数据恢复(程序计数器，程序状态字，各种数据寄存器的现场)<br>进程调度算法的相关参数：</li>
</ol>
</li>
<li>CPU 利用率：CPU 工作时间/作业完成的总时间</li>
<li>系统吞吐量: 单位时间内完成作业的数量</li>
<li>周转时间: 从作业被提交给系统开始，到作业完成为止的时间间隔 = 作业完成时间 - 作业提交时间</li>
<li>带权周转时间: (由于周转时间相同的情况下，可能实际作业的运行时间不一样，这样就会给用户带来不一样的感觉)<br>作业周转时间/作业实际运行时间，带权周转时间 &gt;= 1, 越小越好</li>
<li>平均带权周转时间: 各作业带权周转时间之和/作业数</li>
<li>等待时间</li>
<li>响应时间</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>算法思想？用于解决什么问题<br>算法规则，用于作业（PCB作业）调度还是进程调度<br>抢占式的还是非抢占式的？<br>优缺点？是否会导致饥饿？</p>
<h3 id="当前交互式系统常用调度算法"><a href="#当前交互式系统常用调度算法" class="headerlink" title="当前交互式系统常用调度算法"></a>当前交互式系统常用调度算法</h3><ul>
<li><strong>时间片轮转(Round-Robin)</strong><ul>
<li>算法思想: 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内可以得到响应</li>
<li>算法规则: 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(例如：100ms),若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</li>
<li>用于作业/进程调度: 用于进程的调度（只有作业放入内存）</li>
<li>是否可抢占？若进程未能在规定时间片内完成，将被强行剥夺处理机使用权，由时钟装置发出时钟终端信号来通知 CPU 时间片到达</li>
<li>优缺点: 适用于分时操作系统，由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</li>
<li>是否会导致饥饿：不会</li>
</ul>
</li>
<li><strong>优先级调度算法</strong><ul>
<li>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的进程程度决定处理顺序</li>
<li>算法规则: 每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li>用于作业/进程调度: 即可用于作业调度（处于外存后备队列中的作业调度进内存），也可用于进程调度(选择就绪队列中的进程，为其分配处理机)，甚至 I/O 调度</li>
<li>是否可抢占？具有可抢占版本，也有非抢占式的</li>
<li>优缺点: 适用于实时操作系统，用优先级区分紧急程度，可灵活地调整对各种作业/及进程的偏好程度。缺点：会导致饥饿</li>
<li>是否会导致饥饿：会</li>
</ul>
</li>
<li><strong>多级反馈队列调度算法</strong><br>维护了多个按照<strong>优先级从高到低</strong>的进程队列，且每个队列时间片不一致，采用抢占式算法调度。<ul>
<li>算法思想：综合 FCFS、SJF(SPF)、时间片轮转、优先级调度</li>
<li>算法规则：<ul>
<li><ol>
<li>设置多级别就绪队列，各级别队列优先级从高到低，时间片从小到大</li>
</ol>
</li>
<li><ol start="2">
<li>新进程到达时先进入第 1 级队列，按照 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾</li>
</ol>
</li>
<li><ol start="3">
<li>只有第 k 级别队列为空是，才会为 K+1 级对头的进程分配时间片</li>
</ol>
</li>
</ul>
</li>
<li>用于作业/进程调度：用于进程调度</li>
<li>是否可抢占？抢占式算法。在 k 级队列的进程运行过程中，若更上级别的队列（1-k-1级）中进入一个新进程，则由于新进程处于优先级高的队列中，因此新进程会抢占处理机，原本运行的进程放回 k 级别队列队尾。</li>
<li>优缺点：对各类的进程相对公平(FCFS 的有点)；每个新到达的进程都可以很快就得到响应（RR优点）；短进程只用较少的时间就可以完成（SPF）的优点；不必实现估计进程的运行时间；可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 形进程就可以保持较高优先级）</li>
<li>是否会导致饥饿感：会</li>
</ul>
</li>
</ul>
<p>相关知识：<a href="https://www.cnblogs.com/whu-2017/p/9477391.html">https://www.cnblogs.com/whu-2017/p/9477391.html</a><br>例题:<br><img src="../../images/threads/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95.png" alt="img.png"></p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>参考：<a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a><br>在计算机系统中，进程之间有时需要进行数据的通信，但是不同进程之间的数据存储是相互隔离的，每一个进程都只能访问自己占有的数据，这时我们就需要使用用于进程间的通信的机制了<br>不过，出来套接字外，进程间的通信的前提是两进程必须是父子进程关系，没有这种关系的进程间是不能直接进行通信，而是需要利用其共同的父进程进行信息的中转</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><blockquote>
<p>管道通信在系统中，是以文件的方式进行读写的，匿名管道在物理上由文件系统的高速缓冲区构成，而命名管道则可在系统的临时文件中找到具体的文件，相当于通过外部文件来交流信息。<br>父子进程间以比特流、字符流的方式传递信息。管道属于半双工通信，在父子进程中同时创建一对管道，然后利用其中一端(0端)来读数据，另一端来写数据。</p>
</blockquote>
<h4 id="python-实现匿名管道"><a href="#python-实现匿名管道" class="headerlink" title="python 实现匿名管道"></a>python 实现匿名管道</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span>(<span class="params">pipe0, pipe1</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[proc1] 发送：  &quot;</span>, i)</span><br><span class="line">        pipe0.send(i)</span><br><span class="line">        pipe1.send(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[proc1] proc2 接收:&#x27;</span>, pipe0.recv())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[proc1] proc3 接收:&#x27;</span>, pipe1.recv())</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = pipe.recv()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[proc2] proc2 接收:&#x27;</span>, msg)</span><br><span class="line">        pipe.send(<span class="string">&#x27;proc2收到数据：&#x27;</span> + <span class="built_in">str</span>(msg))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc3</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = pipe.recv()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[proc3] proc3 接收:&#x27;</span>, msg)</span><br><span class="line">        pipe.send(<span class="string">&#x27;proc3收到数据：&#x27;</span> + <span class="built_in">str</span>(msg))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build a pipe</span></span><br><span class="line">    pipe0 = multiprocessing.Pipe()</span><br><span class="line">    pipe1 = multiprocessing.Pipe()</span><br><span class="line">    <span class="built_in">print</span>(pipe0)</span><br><span class="line">    <span class="built_in">print</span>(pipe1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pass an end of the pipe to process 1</span></span><br><span class="line">    p1 = multiprocessing.Process(target=proc1, args=(pipe0[<span class="number">0</span>], pipe1[<span class="number">0</span>],))</span><br><span class="line">    <span class="comment"># Pass the other end of the pipe to process 2</span></span><br><span class="line">    p2 = multiprocessing.Process(target=proc2, args=(pipe0[<span class="number">1</span>],))</span><br><span class="line">    <span class="comment"># Pass the other end of the pipe to process 3</span></span><br><span class="line">    p3 = multiprocessing.Process(target=proc3, args=(pipe1[<span class="number">1</span>],))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br></pre></td></tr></table></figure>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>生产者进程生产产品，消费者进程消费产品</li>
<li>当生产者进程生产产品时，如果没有空缓冲区可用，那么生产者进程必须等待消费者进程释放出一个缓冲区</li>
<li>当消费者进程消费产品时，如果缓冲区中没有产品，那么消费者进程将被阻塞，直到新的产品被生产出来。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing.sharedctypes <span class="keyword">import</span> Array</span><br><span class="line"></span><br><span class="line">a = Array(<span class="string">&#x27;i&#x27;</span>, [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)])  <span class="comment"># 共享内存</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">semaphore_num = multiprocessing.Semaphore(<span class="number">0</span>)  <span class="comment"># 产品个数</span></span><br><span class="line">semaphore_empty = multiprocessing.Semaphore(<span class="number">20</span>)  <span class="comment"># 缓冲区空位个数n</span></span><br><span class="line">semaphore_mutex = multiprocessing.Semaphore(<span class="number">1</span>)  <span class="comment"># 对缓冲区进行操作的互斥信号量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">flag</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">global</span> no</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;消费者 &quot;</span> + <span class="built_in">str</span>(flag) + <span class="string">&quot; 等待中...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        item = random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(item):</span><br><span class="line">            semaphore_num.acquire()  <span class="comment"># 消费 -1</span></span><br><span class="line">            semaphore_mutex.acquire()  <span class="comment"># 加锁</span></span><br><span class="line">            no = a[<span class="number">0</span>]</span><br><span class="line">            num = a[<span class="number">1</span>]</span><br><span class="line">            num -= <span class="number">1</span></span><br><span class="line">            no += <span class="number">1</span></span><br><span class="line">            a[<span class="number">0</span>] = no</span><br><span class="line">            a[<span class="number">1</span>] = num</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(no) + <span class="string">&quot; [消费者 &quot;</span> + <span class="built_in">str</span>(flag) + <span class="string">&quot;] 消费产品 1. 剩余： &quot;</span> + <span class="built_in">str</span>(num))</span><br><span class="line">            semaphore_mutex.release()  <span class="comment"># 开锁</span></span><br><span class="line">            semaphore_empty.release()  <span class="comment"># 释放空位 +1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">global</span> no</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;生产者开始生产...&quot;</span>)</span><br><span class="line">        item = random.randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;生产个数：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(item))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(item):</span><br><span class="line">            semaphore_empty.acquire()  <span class="comment"># 占用空位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(item):</span><br><span class="line">            semaphore_mutex.acquire()  <span class="comment"># 加锁</span></span><br><span class="line">            no = a[<span class="number">0</span>]</span><br><span class="line">            num = a[<span class="number">1</span>]</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            no += <span class="number">1</span></span><br><span class="line">            a[<span class="number">0</span>] = no</span><br><span class="line">            a[<span class="number">1</span>] = num</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(no) + <span class="string">&quot; [生产者] 生产产品 1. 剩余： &quot;</span> + <span class="built_in">str</span>(num))</span><br><span class="line">            semaphore_mutex.release()  <span class="comment"># 开锁</span></span><br><span class="line">            semaphore_num.release()  <span class="comment"># 生产</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p1 = multiprocessing.Process(target=producer)</span><br><span class="line">    p2 = multiprocessing.Process(target=consumer, args=(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">    p3 = multiprocessing.Process(target=consumer, args=(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序结束&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">size = <span class="number">8</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro1</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro2</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[porc2] 写入：  &quot;</span>, i)</span><br><span class="line">        a[i] = i</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro3</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size):</span><br><span class="line">        msg = a[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[pro3] pro3 读出：&#x27;</span>, msg)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing.sharedctypes <span class="keyword">import</span> Array</span><br><span class="line"></span><br><span class="line">a = Array(<span class="string">&#x27;i&#x27;</span>, [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)])</span><br><span class="line"></span><br><span class="line">p1 = multiprocessing.Process(target=pro1, args=(a,))</span><br><span class="line">p2 = multiprocessing.Process(target=pro2, args=(a,))</span><br><span class="line">p3 = multiprocessing.Process(target=pro3, args=(a,))</span><br><span class="line"></span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p3.start()</span><br><span class="line"></span><br><span class="line">p1.join()</span><br><span class="line">p2.join()</span><br><span class="line">p3.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="socket-套接字"><a href="#socket-套接字" class="headerlink" title="socket 套接字"></a>socket 套接字</h3><blockquote>
<p>套接字是网络进程通信的机制，一般是用于位于不同机器上的进程间的通信。很多网络程序如即时通讯软件、游戏、浏览器<br>数据库等，都往往使用的这种机制。<br>参考：<a href="https://blog.ailemon.net/2018/01/21/python-implement-about-socket-connection/">https://blog.ailemon.net/2018/01/21/python-implement-about-socket-connection/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientProcess</span>(<span class="params">multiprocessing.Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,conn,addr</span>):</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.conn = conn</span><br><span class="line">        self.addr = addr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conn.sendall(<span class="built_in">bytes</span>(<span class="string">&quot;你好，我是AI柠檬~&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        ret_timeout = <span class="built_in">str</span>(self.conn.recv(<span class="number">1024</span>),encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        self.conn.settimeout(<span class="built_in">int</span>(ret_timeout))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ret = <span class="built_in">str</span>(self.conn.recv(<span class="number">1024</span>),encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                self.conn.sendall(<span class="built_in">bytes</span>(<span class="string">&quot;我收到了你的信息：&quot;</span>+ret,encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">                <span class="keyword">if</span>(ret==<span class="string">&quot;:q&quot;</span>):</span><br><span class="line">                    self.conn.close()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">                self.conn.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    inp_addr = <span class="built_in">input</span>(<span class="string">&quot;Please input this server&#x27;s ip address:\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    inp_port = <span class="built_in">input</span>(<span class="string">&quot;Please input this server&#x27;s port:\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    s.bind((inp_addr,<span class="built_in">int</span>(inp_port)))</span><br><span class="line">    s.listen()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器已开启&quot;</span>)</span><br><span class="line">    users = []</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        conn,addr=s.accept()</span><br><span class="line">        </span><br><span class="line">        p = ClientProcess(conn,addr)</span><br><span class="line">        p.start()</span><br><span class="line">        users.append(p)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;有一个新用户连接，进程号pid:&quot;</span>, p.pid)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        tmp_users=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(users)):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(users[i].is_alive()==<span class="literal">True</span>):</span><br><span class="line">                tmp_users.append(users[i])</span><br><span class="line">            </span><br><span class="line">        users = tmp_users</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前用户数：&quot;</span>, <span class="built_in">len</span>(users))</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">obj = socket.socket()</span><br><span class="line"></span><br><span class="line">inp_addr = <span class="built_in">input</span>(<span class="string">&quot;Please input server&#x27;s ip address:\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">inp_port = <span class="built_in">input</span>(<span class="string">&quot;Please input server&#x27;s port:\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">obj.connect((inp_addr,<span class="built_in">int</span>(inp_port)))</span><br><span class="line"></span><br><span class="line">inp_timeout = <span class="built_in">input</span>(<span class="string">&quot;Please input timeout(s):\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">obj.sendall(<span class="built_in">bytes</span>(inp_timeout,encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">obj.settimeout(<span class="built_in">int</span>(inp_timeout))</span><br><span class="line"></span><br><span class="line">msg = <span class="built_in">str</span>(obj.recv(<span class="number">1024</span>),encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    inp = <span class="built_in">input</span>(<span class="string">&quot;Please(:q\退出):\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(inp!=<span class="string">&quot;&quot;</span>):</span><br><span class="line">        obj.sendall(<span class="built_in">bytes</span>(inp,encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span>(inp == <span class="string">&quot;:q&quot;</span>):</span><br><span class="line">        obj.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = <span class="built_in">str</span>(obj.recv(<span class="number">1024</span>),encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[Error]Network Connection Time Out!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[Error]Unknown Network Connection Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>线程是 CPU 进行调度的基本单位</strong><br><img src="../../images/threads/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="img.png"><br>类比：<br>去图书馆看书。<br>切换进程运行环境：有一个不认识的人要用桌子，你需要把你的书收走，他把自己的书放到桌子上<br>同一进程内的线程切换=你的舍友要用这张书桌，可以不把桌子上的书收走</p>
<h2 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h2><ul>
<li>线程是处理机调度的单位</li>
<li>多 CPU 计算机中，各个线程可占用不同的 CPU</li>
<li>每个线程都有一个线程 ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，开销很大</li>
</ul>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><ul>
<li><strong>用户级线程(User-Level Thread)</strong>, <strong>用户级线程是由应用程序通过线程库实现</strong>，如 python(thread), 线程的管理由应用程序负责</li>
<li><strong>内核级线程(kernel-Level Thread)</strong>, <strong>内核级线程的管理工作由操作系统内核完成，线程调度，切换等工作都由内核负责</strong>，因此内核级线程的切换必然需要在核心态下才能完成</li>
</ul>
<p>进程和线程关系：一条线程指的是<strong>进程中一个单一顺序的控制流</strong>，一个进程中可以并发多个线程，每条线程并行执行不同的任务。CPU 的最小调度单元是线程。</p>
<h2 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h2><ul>
<li>新建（New）: 线程在进程内派生出来，它即可由进程派生，也可由线程派生</li>
<li>阻塞（blocked）: 线程运行过程中，可能由于各种进入阻塞状态<ul>
<li>通过 sleep 方法进入睡眠状态</li>
<li>线程调用一个在 I/O 阻塞的操作，即该操作在输入输出操作完成之前不会返回它的调用者</li>
<li>试图得到一个锁，而该锁被其他线程持有</li>
<li>等待某个触发条件</li>
</ul>
</li>
<li>就绪（ready）：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的 start()方法。<br>当线程对象调用 start()方法返回后，线程就处于就绪状态。处于就绪状态的线程并不一定运行 run()方法，线程还必须同其他线程竞争 CPU 时间，只有获得 CPU 时间才可以运行线程</li>
<li>运行(running): 线程后的 CPU 时间后，进入运行状态真正开始执行 run() 方法</li>
<li>死亡(dead): 线程退出自然死亡，或者异常终止导致线程猝死<br><img src="../../images/threads/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="img.png"></li>
</ul>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="用户级线程模型（一对多模型）"><a href="#用户级线程模型（一对多模型）" class="headerlink" title="用户级线程模型（一对多模型）"></a>用户级线程模型（一对多模型）</h3><p><img src="../../images/threads/thread_1.png" alt="img.png"><br><strong>多个用户态的线程对应着一个内核线程，程序的创建、终止、切换或者同步等线程工作必须自身来完成</strong>。python 就是这种。虽然可以实现异步，但是不能有效利用多核（GIL）</p>
<h3 id="内核级别线程模型（一对一）"><a href="#内核级别线程模型（一对一）" class="headerlink" title="内核级别线程模型（一对一）"></a>内核级别线程模型（一对一）</h3><p><img src="../../images/threads/thread_2.png" alt="img.png"><br>这种模型直接<strong>调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成</strong>。C++ 就是这种</p>
<h3 id="两级线程模型-M-N"><a href="#两级线程模型-M-N" class="headerlink" title="两级线程模型(M:N)"></a>两级线程模型(M:N)</h3><p><img src="../../images/threads/thread_3.png" alt="img.png"><br>这种线程模型会<strong>先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程</strong>，自身的用户级线程需要本身程度去调度，内核级的线程交给操作系统内核去调度。<br>GO 语言就是这种</p>
<h3 id="线程总结"><a href="#线程总结" class="headerlink" title="线程总结"></a>线程总结</h3><p>python 中的多线程因为 GIL 的存在，并不能利用多核CPU优势，但是在阻塞的系统调用中，如 sock.connect(),<br>sock.recv() 等耗时的 I/O 操作，当前的线程会释放 GIL,让出处理器。但是单个线程内，阻塞调用上还是阻塞的。除了 GIL 之外，所有的多线程还有通病，它们的调度策略是抢占式的，以保证同等优先级的线程都有机执行，带来的问题就是：<br>并不知道下一刻执行那个线程，也不知道正在执行什么代码，会存在<strong>竞态条件</strong></p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在 IO 上的性能瓶颈。</p>
<h2 id="python-协程"><a href="#python-协程" class="headerlink" title="python 协程"></a>python 协程</h2><p><strong>eventloop 协程模型</strong><br>python 的协程源于 yield 指令</p>
<ul>
<li>yield item 用于产出一个值，反馈给 next() 的调用方法</li>
<li>让出处理机，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用 next()</li>
</ul>
<p>协程式对线程的调度，yield 类似惰性求职方式可以视为一种流程控制工具，实现协作式多任务，python3.5引入了 async/await 表达式，使得协程证实在语言层面得到支持和优化，大大简化之前的 yield 写法。<br>python 中的协程的调度是非抢占式的，也就是说一个协程必须主动让出执行机会，其他协程才有机会运行。让出执行的关键字 await,如果一个协程阻塞了，持续不让出 CPU 处理机，那么整个线程就卡住了，没有任何并发。</p>
<h2 id="go-协程"><a href="#go-协程" class="headerlink" title="go 协程"></a>go 协程</h2><p>go - <strong>GMP模型</strong><br>go 语言使用 go 关键字，goroutine 之间使用 channel 通信</p>
<p>go 实现了两种并发形式：</p>
<ul>
<li>多线程共享内存：如 Java 或者 C++ 在多线程中共享数据的时候，通过锁来访问</li>
<li>Go 语言特有的，也是 Go 语言推荐的 <strong>CSP （communicating sequential processes）并发模型</strong></li>
</ul>
<p><strong>协程本质上来说是一种用户态的线程，不需要系统来执行抢占式调度，而是在语言层面实现线程的调度。</strong></p>
<p>go 协程是<strong>轻量级</strong>的，栈初始为 2KB(os 操作系统的线程一般都是固有的栈内存 2M)，调度不涉及系统调用，用户函数调用前会检查栈空间是否充足，不够的话，会进行栈扩容，栈大小限制可以达到 1GB。</p>
<p>Go 语言相比起其他语言的优势在于 OS 线程是由 OS 内核来调度的，<strong>goroutine 则是由 Go 运行时（runtime）自己的调度器调度的</strong>，这个调度器使用一个称为 m:n 调度的技术。<br>其一大特点是 goroutine 的调度是在用户态下完成的，不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，不直接调用系统的 malloc 函数，成本比调度 OS 线程低很多。<br>另外一方面<strong>充分利用了多核的硬件资源，近似的把若干 goroutine 均分在物理线程上。</strong></p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法一览</title>
    <url>/posts/2c2cd033/</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>是否基于比较</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡、插入、选择</td>
<td>O(n**2)</td>
<td>支持</td>
<td>冒泡、插入、选择排序都有一个共同点，将待排序数列分为已排序和未排序两部分。在未排序的部分中查找一个最值，放到已排序数列的恰当位置。 具体到代码层面，外层循环的变量用于分割已排序和未排序数，内层循环的变量用于在未排序数中查找。从思路上看，这三种算法其实是一样的，所以时间复杂度也相同。</td>
</tr>
<tr>
<td>快排、归并</td>
<td>O(nlog(n))</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>桶、计数、基数</td>
<td></td>
<td></td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="如何分析一个排序算法？"><a href="#如何分析一个排序算法？" class="headerlink" title="如何分析一个排序算法？"></a>如何分析一个排序算法？</h2><ul>
<li><p>算法的执行效率</p>
<ul>
<li>最好、最坏、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数、低阶</li>
<li>比较次数和交换次数</li>
</ul>
</li>
<li><p>排序算法的内存消耗</p>
<ul>
<li>算法的内存消耗可以通过空间复杂度来衡量</li>
</ul>
</li>
<li><p>排序算法的稳定性</p>
<ul>
<li>稳定的排序算法(原有排序不变)</li>
<li>不稳定的排序算法(原有排序改变)</li>
</ul>
</li>
</ul>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><blockquote>
<p>冒泡排序: 比较相邻的两个元素，经过一次排序后，最大的数会冒泡到最后。</p>
<p>时间复杂度：O（n**2）</p>
<p>空间复杂度：O（1）</p>
<p>是否稳定：是</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    冒泡排序</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote>
<p>插入排序，取未排序区间中的元素，在已排序区间中找到合适的插入为止将其插入，并保证已排序区间一直有序，重复这个过程，直到未排序空间中的元素为空</p>
<p>有序空间左边肯定最小的，只需要每次比较未排序空间的第一个；</p>
<p>满有序度：n*(n-1)/2=15</p>
<p>时间复杂度：O(n**2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：是</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        value = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; value:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[i]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        arr[j] = value</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote>
<p>选择排序是一种简单的排序算法，其基本思想是每次从待排序的元素中选择最小的元素，将其放到已排序的序列的末尾，从而得到一个新的有序序列；</p>
<p>时间复杂度：O(n**2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：不稳定</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line"></span><br><span class="line">        arr[i], arr[min_index] = arr[min_index], arr[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>归并排序，使用了分治思想，将一个数组分开为左小右大的无数个数组，然后合并；</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(n)</p>
<p>是否稳定：是</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    middle = math.floor(<span class="built_in">len</span>(arr)/<span class="number">2</span>)</span><br><span class="line">    left, right = arr[<span class="number">0</span>:middle], arr[middle:]</span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(left), merge_sort(right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]:</span><br><span class="line">            result.append(left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> left:</span><br><span class="line">        result.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> right:</span><br><span class="line">        result.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>
<p>空间复杂度：O(n)</p>
<p>时间复杂度：O(log(n))</p>
<p>是否稳定：否</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arr:<span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快速排序</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    privot = arr[<span class="number">0</span>]</span><br><span class="line">    less = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= privot]</span><br><span class="line">    greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; privot]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick_sort(less) + [privot] + quick_sort(greater)</span><br></pre></td></tr></table></figure>



<p>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p>
<h2 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h2><p>时间复杂度为 O(n) 的排序算法：桶排序、计数排序、基数排序。这三种排序算法的时间复杂度是线性的。</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote>
<p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内的数据排序完之后，再把每个桶内的数据按照顺序依次取出，组成的序列就是有序的</p>
</blockquote>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><blockquote>
<p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
</blockquote>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><blockquote>
<p>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>三种排序算法的时间复杂度均为 O(n</strong>2)，空间复杂度为 O(1), 除选择排序均为稳定的算法；</p>
<p>三者排序思想都是将元素分为已排序空间和未排序空间，<strong>冒泡排序的思想是在未排序的空间中，找到最大的数放置最未排序空间的末端；</strong></p>
<p><strong>选择排序是在未排序空间中，找到最小的数，放置到最左端；插入排序的思想则是如何将一个数插入到已排序空间中并保持有序；</strong></p>
<p><strong>而为何大多使用插入排序，主要原因是插入排序中的赋值语句较为简单， 较少的数据交换</strong></p>
<hr>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么使用链表&amp;&amp;实现</title>
    <url>/posts/2c2cd033/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>从一个经典的<strong>链表</strong>应用场景：<strong>LRU 缓存淘汰算法</strong>说开去。</p>
</blockquote>
<blockquote>
<p><strong>缓存</strong>是为了解决高低速存储之间的差距而引入的技术。</p>
</blockquote>
<p>链表和数组对比：</p>
<p><img src="https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg" alt="img"></p>
<p>缓存的大小有限，当缓存被打满的时候，就需要<strong>清理或者保留某些数据</strong>，这一部分就需要缓存淘汰策略来决定。</p>
<p><strong>常见的策略有三种:</strong></p>
<ul>
<li><strong>先进先出策略 FIFO (First In, First Out)</strong></li>
<li><strong>最少使用策略（Least Frequently Used）</strong></li>
<li><strong>最近最少使用策略（Least Recently Used）</strong></li>
</ul>
<p>这些策略就和我们清理房间采取的策略一致</p>
<p>那么如何采用 <strong>链表</strong>，来实现 <strong>LRU缓存淘汰策略</strong>呢 ？</p>
<h2 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h2><p>首先解释一个 <strong>链表</strong> 的数据结构</p>
<blockquote>
<p>与数组结构不同的是，<strong>链表不需要连续的内存空间来存储</strong>，<strong>它是通过<code>指针</code>将一组零散的内存块串联起来使用</strong>。</p>
</blockquote>
<p>用一张图直观的解释：</p>
<p><img src="https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg" alt="img"></p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img"></p>
<p><strong>单链表</strong>是通过一个个<strong>节点（Node）</strong>组成的，每个节点包含了两个部分：</p>
<ul>
<li>存储数据的 <code>data</code></li>
<li>存储指针的<code>next</code>, 用于指向下一个 node</li>
</ul>
<p>特点：</p>
<ul>
<li>数据的<strong>插入</strong>和<strong>删除</strong>非常迅速（无序）—— 时间复杂度 O(1)</li>
<li>数据的<strong>查找</strong>时间复杂度是 O(n)</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg" alt="img"></p>
<h3 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h3><ul>
<li>查找 - find()</li>
<li>删除 - remove()</li>
<li>链表元素添加<ul>
<li>头部添加元素 - add</li>
<li>尾部添加元素 - append</li>
<li>插入某个元素 - insert</li>
</ul>
</li>
<li>链表元素展示 - traverse()</li>
<li>链表长度 - <code> __len__</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单链表的实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            cur_data = cur.data</span><br><span class="line">            <span class="keyword">if</span> cur_data == data:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                <span class="keyword">if</span> cur == self.head:</span><br><span class="line">                    self.head = self.head.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.add(data)</span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.__len__():</span><br><span class="line">            self.append(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index -<span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            node = Node(data)</span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.data, end=<span class="string">&#x27;-***-&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    chain = LinkedList()</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> items:</span><br><span class="line">        node = Node(value)</span><br><span class="line">        chain.append(value)</span><br><span class="line"></span><br><span class="line">    chain.traverse()</span><br><span class="line"></span><br><span class="line">    chain.append(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    chain.traverse()</span><br><span class="line"></span><br><span class="line">    chain.remove(<span class="number">3</span>)</span><br><span class="line">    chain.remove(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    chain.traverse()</span><br><span class="line">    chain.insert(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    chain.traverse()</span><br><span class="line">    <span class="built_in">print</span>(chain.find(<span class="number">5</span>), chain.find(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(chain))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote>
<p><strong>循环链表是一种特殊的单链表。它和单链表的唯一区别就是在尾节点</strong>。<br><strong>循环链表的尾结点指针指向链表的头节点。</strong></p>
</blockquote>
<p><img src="/images/linknode.png" alt="direct"><br>这种数据结构比较适合处理具有环形结构特点的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleLink</span>(<span class="params">SingleChain</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CircleLink, self).__init__()</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = node</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">            self._head = node</span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-**&#123;&#125;&quot;</span>.<span class="built_in">format</span>(cur.data), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-**&#123;&#125;&quot;</span>.<span class="built_in">format</span>(cur.data), end=<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 由于是 cur.next 判断的，故 cur 指向最后一个节点</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        cur = self._head</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur.data == data:  <span class="comment"># 最后一个</span></span><br><span class="line">            <span class="keyword">return</span> self.__len__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span> == self._head:</span><br><span class="line">            self._head = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 退出循环, cur指向尾结点</span></span><br><span class="line">        <span class="keyword">if</span> cur.data == data:</span><br><span class="line">            <span class="comment"># 链表中只有一个结点</span></span><br><span class="line">            pre.<span class="built_in">next</span> = self._head</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span>  <span class="comment"># 未计算最后一个 Node</span></span><br></pre></td></tr></table></figure>


<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><blockquote>
<p>双向链表，顾名思义，它支持两个方向，每个节点分为三个部分：</p>
<ul>
<li>prev</li>
<li>data</li>
<li>next</li>
</ul>
<p>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱节点，双向链表在某些情况下的 插入、删除等操作都要比单链表简单、高效。</p>
</blockquote>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li><p>删除节点中“值等于某个给定值” 的节点</p>
<p>对于这种情况，不管是单链表还是双链表，为了查找到值等于给定值的节点，都需要从头节点开始一个个依次遍历对比，找到后删除，时间复杂度为 O(n)</p>
</li>
<li><p>删除给定指针指向的节点</p>
<p>对于单链表来说，删除指定的节点时，还需要知道前驱节点，那么就会存在遍历的操作，时间复杂度为 O(n)。</p>
<p>对于双向链表来说，是存在 prev 指针的，那么时间复杂度相对于是 O(1)</p>
</li>
</ul>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ul>
<li>对于在某个节点前插入指定节点，时间复杂度是 O(1)</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>对于一个有序链表来说，双向链表可以通过记录上次查找的位置 pos，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，平均时间复杂度为 O(log(n))</p>
<p><img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img"></p>
<h3 id="双向链表实现"><a href="#双向链表实现" class="headerlink" title="双向链表实现"></a>双向链表实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chain.single_chain <span class="keyword">import</span> SingleChain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双向链表</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Author: tyrone</span></span><br><span class="line"><span class="string">File: 双向链表.py</span></span><br><span class="line"><span class="string">Time: 2023/3/20</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyChain</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line">        self.history = (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># append</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        node = Node(value)</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 找到最后一个节点</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># add</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        node = Node(value)</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head.prev = node</span><br><span class="line">            self.head = node</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># insert</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(value)</span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.length - <span class="number">1</span>:</span><br><span class="line">            self.append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; index:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            node = Node(value)</span><br><span class="line">            <span class="comment"># 标记上一个</span></span><br><span class="line">            prev = cur.prev</span><br><span class="line">            <span class="comment"># node.next = cur</span></span><br><span class="line">            <span class="comment"># node.prev = cur.prev</span></span><br><span class="line">            <span class="comment"># cur.prev.next = node</span></span><br><span class="line">            <span class="comment"># cur.prev = node</span></span><br><span class="line"></span><br><span class="line">            prev = cur.prev</span><br><span class="line">            prev.<span class="built_in">next</span> = node</span><br><span class="line">            node.prev = prev</span><br><span class="line">            node.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># find</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur.value == value:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">print</span>(cur.value)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    double_chain = DoublyChain()</span><br><span class="line">    double_chain.append(<span class="number">1</span>)</span><br><span class="line">    double_chain.append(<span class="number">2</span>)</span><br><span class="line">    double_chain.append(<span class="number">3</span>)</span><br><span class="line">    double_chain.insert(-<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    double_chain.insert(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">    double_chain.insert(<span class="number">2</span>, <span class="number">20000</span>)</span><br><span class="line">    double_chain.insert(<span class="number">4</span>, <span class="number">40000</span>)</span><br><span class="line"></span><br><span class="line">    cur = double_chain.head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(cur.value)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(double_chain.find(<span class="number">40000</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表包括：</p>
<ul>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ul>
<p>和数组相比，<strong>链表存储的数据是不连续的存储空间，数据之间采用指针引用方式连接。</strong><br>链表各适合插入、删除操作频繁的场景，查询的时间复杂度较高。</p>
<h3 id="链表实现注意点"><a href="#链表实现注意点" class="headerlink" title="链表实现注意点"></a>链表实现注意点</h3><ul>
<li><p>理解指针或引用含义</p>
<blockquote>
<p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量</p>
</blockquote>
</li>
<li><p>警惕指针丢失和内存泄露<br>在插入指针的时候，注意操作的顺序，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.<span class="built_in">next</span> = x</span><br><span class="line">x.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>上面的语句出现了自己指向自己的情况，交换两行就可以了<br>删除链表节点的时候，也一定要记得手动释放内存空间。</p>
</li>
<li><p>利用哨兵简化实现难度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur = self.head</span><br></pre></td></tr></table></figure></li>
<li><p>重点留意边界条件处理</p>
</li>
</ul>
<ol>
<li>链表为空的时候</li>
<li>链表只包含一个节点的情况</li>
<li>链表只包含头尾节点</li>
</ol>
<ul>
<li>举例绘图，辅助思考<br><img src="/images/link_node_exaples.png" alt="direct"></li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>LRU 的实现？</p>
<p>字符串是通过单链表来存储的，那如何判断一个回文字符呢？</p>
<p>解决思路：</p>
<p>法一：</p>
<p>使用快慢指针找到中点，然后将后半链表 reversed，然后一个指针在头部，一个指针在中部，逐个比较。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">head</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    slow = reverse_node(find_middle_node(head))</span><br><span class="line">    traverse(slow)</span><br><span class="line">    traverse(head)</span><br><span class="line">    <span class="keyword">while</span> slow:</span><br><span class="line">        <span class="keyword">if</span> head.data != slow.data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_middle_node</span>(<span class="params">head</span>):</span></span><br><span class="line">    fast, slow = head, head</span><br><span class="line">    <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_node</span>(<span class="params">head</span>):</span></span><br><span class="line">    p, rev = head, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        rev, rev.<span class="built_in">next</span>, p = p, rev, p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">    cur = node</span><br><span class="line">    <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(cur.data, end=<span class="string">&#x27;-***-&#x27;</span>)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_str = <span class="string">&quot;1012101&quot;</span></span><br><span class="line">    c = Chain()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> my_str:</span><br><span class="line">        c.append(v)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(is_palindrome(c.head))</span><br></pre></td></tr></table></figure>

<h2 id="链表练习题目"><a href="#链表练习题目" class="headerlink" title="链表练习题目"></a>链表练习题目</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>206 - <a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
<p>解题思路：<br>p = p.next 循环， 将 head.next 的引用指向前一个节点即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        res, p = <span class="literal">None</span>, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            res, res.<span class="built_in">next</span>, p = p, res, p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="环状链表判断"><a href="#环状链表判断" class="headerlink" title="环状链表判断"></a>环状链表判断</h3><p>解题思路：使用快慢指针，如果两个指针相遇了说明是环状链表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        i = head</span><br><span class="line">        j = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j != <span class="literal">None</span> <span class="keyword">and</span> j.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            i = i.<span class="built_in">next</span></span><br><span class="line">            j = j.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>21 - <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">            <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">                <span class="keyword">if</span> l1.val &gt; l2.val: l1, l2 = l2, l1</span><br><span class="line">                l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br></pre></td></tr></table></figure>

<h3 id="删除链表的到处第-N-个节点"><a href="#删除链表的到处第-N-个节点" class="headerlink" title="删除链表的到处第 N 个节点"></a>删除链表的到处第 N 个节点</h3><p>19 - <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">head: ListNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">    length = getLength(head)</span><br><span class="line">    cur = dummy</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length - n + <span class="number">1</span>):</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>876 - <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        </span><br><span class="line">        n, cur = <span class="number">0</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        k, cur = <span class="number">0</span>, head</span><br><span class="line">        <span class="keyword">while</span> k &lt; n // <span class="number">2</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h1 id="链表实现源码"><a href="#链表实现源码" class="headerlink" title="链表实现源码"></a>链表实现源码</h1><p><a href="https://github.com/tyronemaxi/algorithm/tree/main/chain">https://github.com/tyronemaxi/algorithm/tree/main/chain</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是栈、栈的使用场景？</title>
    <url>/posts/da81f8d9/</url>
    <content><![CDATA[<h1 id="如何理解栈？"><a href="#如何理解栈？" class="headerlink" title="如何理解栈？"></a>如何理解栈？</h1><blockquote>
<p>关于”栈”，就像是一摞叠在一起的书籍。当我们放书籍的时候，都是一本本书的摞起来；当我们需要取书籍的时候，也是需要从上到下<br>一个个的依次的取。</p>
</blockquote>
<p>所谓的<strong>栈</strong>：就是<strong>后进者先出，先进者后出，这就是典型的 栈 的结构</strong>。</p>
<p>从栈的操作特性上来看，<strong>栈是一种”操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p>
<p>从功能上来说，数组和链表确实可以替代栈，但是特定的数据结构是对特定场景的抽象，而且，数组或者链表暴露了太多的操作接口，操作上的灵活，<br>在使用时也就会变得不可控，自然也就更容易出错。</p>
<p><strong>当某个数据集合只涉及在一端插入和删除数据的时候，并且满足后进先出、先进先出的特性，这时我们就应该首选”栈”这种数据结构</strong></p>
<h1 id="如何实现一个”栈”？"><a href="#如何实现一个”栈”？" class="headerlink" title="如何实现一个”栈”？"></a>如何实现一个”栈”？</h1><p>栈可以使用数组来实现，也可以使用链表来实现；<br>这里我使用数组来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._stack.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._stack)</span><br></pre></td></tr></table></figure>
<p>先说结论：<br>栈的空间复杂度为 O(1), 时间复杂度为 O(1)。<br>这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。我们在判断一个空间复杂度的时候，是指除了原本的数据存储空间外，<br>算法运行还需要额外的存储空间。</p>
<p>对于时间复杂度来说，入栈和出栈都是 O(1)</p>
<h1 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h1><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>栈作为一个比较基础的数据结构，比较经典的应用场景就是<code>函数调用栈</code>。</p>
<p>操作系统给每个线程分配了一块<code>独立的内存空间</code>，这块内存被组织成<code>栈</code>这种数据结构，用来存储函数调用时的临时变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    a,b, c = <span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    _res = add(a,b)</span><br><span class="line">    res = _res + c</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(a,b)</span><br></pre></td></tr></table></figure>

<p>调用顺序：main() –&gt; add()<br><img src="../../images/algorithm/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.png" alt="direct"></p>
<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><p>四则运算的实现<br>例如：16+26*36-2/2</p>
<p>实现思路：</p>
<ol>
<li>维护一个栈，然后<br><img src="../../images/algorithm/%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E6%A0%88%E5%AE%9E%E7%8E%B0.png" alt="img_2.png"></li>
</ol>
<p>实际上，编译器就是通过两个栈来实现的。其中一个来保存操作数的栈，另一个保存运算符的栈。</p>
<h3 id="基本运算器实现"><a href="#基本运算器实现" class="headerlink" title="基本运算器实现"></a>基本运算器实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    stack = []</span><br><span class="line">    preSign = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(num)</span><br><span class="line">        <span class="keyword">if</span> i == n - <span class="number">1</span> <span class="keyword">or</span> s[i] <span class="keyword">in</span> <span class="string">&#x27;+-*/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> preSign == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">elif</span> preSign == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stack.append(-num)</span><br><span class="line">            <span class="keyword">elif</span> preSign == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                stack.append(stack.pop() * num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(stack.pop() / num))</span><br><span class="line">            preSign = s[i]</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<h2 id="浏览器前进和后退功能实现"><a href="#浏览器前进和后退功能实现" class="headerlink" title="浏览器前进和后退功能实现"></a>浏览器前进和后退功能实现</h2><p>解题思路：使用两个栈，A 和 B，将访问的页面一次压入栈 A 中，当点击后退按钮时，再依次从栈 A 中出栈，并将出栈的数据依次放入栈 B 中。点击前进按钮时，依次从栈 B<br>中取出数据，放入到 A 中。当栈 A 中没有数据时，那就是说明没有页面可以继续后退浏览了。当栈 B 中没有数据的时候，那就说明没有页面可以点击前进按钮浏览了。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._stack.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._stack == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brower</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__forward_stack = Stack()</span><br><span class="line">        self.__back_stack = Stack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">surf</span>(<span class="params">self, web_site_url</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;surf the website:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(web_site_url))</span><br><span class="line">        self.__forward_stack.push(web_site_url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__back_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        top = self.__back_stack.pull()</span><br><span class="line">        self.__forward_stack.push(top)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;forward to the website: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(top))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__forward_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        top = self.__forward_stack.pull()</span><br><span class="line">        self.__back_stack.push(top)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;back to the website: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(top))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    brower = Brower()</span><br><span class="line">    brower.surf(<span class="string">&#x27;www.1.com&#x27;</span>)</span><br><span class="line">    brower.surf(<span class="string">&#x27;www.2.com&#x27;</span>)</span><br><span class="line">    brower.surf(<span class="string">&#x27;www.3.com&#x27;</span>)</span><br><span class="line">    brower.surf(<span class="string">&#x27;www.4.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    brower.forward()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.forward()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>栈是一种<strong>操作受限</strong>的数据结构，只支持<code>入栈</code>和<code>出栈</code>操作。<br>可以通过<code>数组</code>或者<code>链表</code>来实现。<br>入栈、出栈的时间复杂度都是 O(1)。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="为什么函数调用要用栈来保存临时变量呢？"><a href="#为什么函数调用要用栈来保存临时变量呢？" class="headerlink" title="为什么函数调用要用栈来保存临时变量呢？"></a>为什么函数调用要用<strong>栈</strong>来保存临时变量呢？</h2><p>函数调用时，符合<code>后进先出</code>的特性，用栈这种数据结构来实现，是最符合的。</p>
<p>从调用函数进入被调用函数，比如：main –&gt; add –&gt; res 。变化的是<code>作用域</code>。所以从根本上，只要保证每进入一个新的函数，都是一个新的作用域都可以。<br>而要实现这个，用栈会非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>
<h2 id="在-JVM-内存管理中有个堆栈的概念-？"><a href="#在-JVM-内存管理中有个堆栈的概念-？" class="headerlink" title="在 JVM 内存管理中有个堆栈的概念 ？"></a>在 JVM 内存管理中有个<code>堆栈</code>的概念 ？</h2><p>内存中的堆栈和数据结构堆栈不是同一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>内存空间在逻辑上分为三部分：</p>
<ul>
<li>代码区</li>
<li>静态数据区</li>
<li>动态数据区<ul>
<li>栈区</li>
<li>堆区</li>
</ul>
</li>
</ul>
<p>代码区：<code>存储方法体的二进制代码</code>。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：<code>存储全局变量</code>、<code>静态变量</code>、<code>常量</code>、常量包括 final 修饰的常量和 String 常量。系统自动分配和回收。</p>
<p>栈区：<strong>存储运行方法的形参、局部变量、返回值。由系统自动分配和回收</strong><br>堆区：<strong>new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</strong></p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>20 - <a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a><br>解题思路：</p>
<ul>
<li><ol>
<li>括号是成对出现的，则判断字符串 s 是否为偶数，否则返回 False;</li>
</ol>
</li>
<li><ol start="2">
<li>遍历字符串，先将 左括号压入栈，匹配到右括号时，则判断栈顶是否匹配到，否则返回 False;  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid_bracket</span>(<span class="params">brackets: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(brackets) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    pairs = &#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack = Stack()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> brackets:</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.top() != pairs[ch]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.pull()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.push(ch)</span><br><span class="line">    <span class="keyword">return</span> stack.is_empty()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(isValid_bracket(<span class="string">&#x27;([&#123;&#125;])&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2>解题思路：维护一个辅助栈，在入栈的时候，依次与辅助栈中的数据比较，采用 <code>min(val, min_stack[-1])</code> 的方式入栈。pop 时，min_stack 也会 pop<br>155 - <a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stack = []</span><br><span class="line">        self.min_stack = [math.inf] <span class="comment"># 存储正无穷大</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._stack.append(val)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(val, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2>232 - <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">https://leetcode-cn.com/problems/implement-queue-using-stacks/</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.s1 = []</span><br><span class="line">        self.s2 = []</span><br><span class="line">        self.front = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s1:</span><br><span class="line">            self.front = x</span><br><span class="line">        self.s1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2:</span><br><span class="line">            <span class="keyword">while</span> self.s1:</span><br><span class="line">                self.s2.append(self.s1.pop())</span><br><span class="line">            self.front = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.s2:</span><br><span class="line">            <span class="keyword">return</span> self.s2[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> self.front</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s1 <span class="keyword">and</span> <span class="keyword">not</span> self.s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h2>844 - <a href="https://leetcode-cn.com/problems/backspace-string-compare/">https://leetcode-cn.com/problems/backspace-string-compare/</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> value != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    ret.append(value)</span><br><span class="line">                <span class="keyword">elif</span> ret:</span><br><span class="line">                    ret.pop()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ret)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> judge(s) == judge(t)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="基本计算器实现"><a href="#基本计算器实现" class="headerlink" title="基本计算器实现"></a>基本计算器实现</h2><p>224 - <a href="https://leetcode-cn.com/problems/basic-calculator/">https://leetcode-cn.com/problems/basic-calculator/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">s</span>):</span></span><br><span class="line">    res, num, sign = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> ch.isdigit():</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">int</span>(ch)</span><br><span class="line">        <span class="keyword">elif</span> ch == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            res += sign * num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span> <span class="keyword">if</span> ch == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> ch == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.append(res)</span><br><span class="line">            stack.append(sign)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> ch == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            res += sign * num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            res *= stack.pop()</span><br><span class="line">            res += stack.pop()</span><br><span class="line">    res += sign * num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(calculate(<span class="string">&#x27;1+(1+2)-(1-1)+1&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="基本运算器-3"><a href="#基本运算器-3" class="headerlink" title="基本运算器 3"></a>基本运算器 3</h2><p><a href="https://leetcode-cn.com/problems/basic-calculator-iii/">https://leetcode-cn.com/problems/basic-calculator-iii/</a><br>基本运算元素：</p>
<ul>
<li><code>(</code></li>
<li><code>)</code></li>
<li><code>-</code></li>
<li><code>+</code></li>
<li><code>*</code></li>
<li><code>/</code></li>
</ul>
<p>运算符优先级：</p>
<ul>
<li>2<ul>
<li><code>/ *</code></li>
</ul>
</li>
<li>1<ul>
<li><code>+ -</code></li>
</ul>
</li>
<li>0<ul>
<li><code>( )</code></li>
</ul>
</li>
</ul>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>双栈法</p>
<ul>
<li>stack_num 存储<strong>数字</strong></li>
<li>stack_opt 存储<strong>运算符</strong></li>
</ul>
<p>最小原子计算：</p>
<ol>
<li>stack_num 中 pop 出两个数 A, B</li>
<li>stack_opt 中 pop 出一个操作符 opt</li>
<li>计算结果：res = B opt A</li>
<li>存储运算结果：stack_num.append(res)</li>
</ol>
<p>字符串枚举：</p>
<ol>
<li><code>空格</code>，continue 下一个循环</li>
<li><code>数字</code></li>
</ol>
<ul>
<li>单个数字<br><code>stack_num.append()</code></li>
<li>多位数字<br>解析多位数字，<code>append</code></li>
<li>‘(‘<br>直接进入 stack_opt 栈</li>
<li>‘)’<br>重复最小原子计算，直到 <code>stack_opt</code> 栈顶为 <code>(</code>。然后 stack_opt 栈 pop</li>
<li>操作符(+,-,*,/)<br>比较<code>当前操作符</code>与 <code>栈顶操作符</code>优先级，若前者大于后者，则进行最小原子计算操作。<br>反之，则压入 <code>stack_opt</code> 栈中。</li>
</ul>
<p>3.遍历完所有字符串后，判断 <code>stack_opt</code> 是否为空，重复执行最基本计算操作，直到为空。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本运算器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小原子计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">self, A, B, opt</span>):</span></span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(A) + <span class="built_in">int</span>(B)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(B) - <span class="built_in">int</span>(A)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(B) * <span class="built_in">int</span>(A)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(B) / <span class="built_in">int</span>(A)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">basic_cal</span>(<span class="params">self, stack_num, stack_opt</span>):</span></span><br><span class="line">        opt = stack_opt.pop()</span><br><span class="line">        A = stack_num.pop()</span><br><span class="line">        B = stack_num.pop()</span><br><span class="line">        res = self.cal(A, B, opt)</span><br><span class="line">        stack_num.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s:<span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># stack_num &amp;&amp; stack_opt</span></span><br><span class="line">        stack_num, stack_opt = [], []</span><br><span class="line">        priority = &#123;</span><br><span class="line">            <span class="string">&#x27;(&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;)&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;+&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;-&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;*&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="string">&#x27;/&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot; &quot;</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                start = i</span><br><span class="line">                <span class="keyword">while</span> i+<span class="number">1</span> &lt; length <span class="keyword">and</span> <span class="string">&#x27;0&#x27;</span> &lt;= s[i+<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                    i = i+<span class="number">1</span></span><br><span class="line">                num = <span class="built_in">int</span>(s[start: i+<span class="number">1</span>])</span><br><span class="line">                stack_num.append(num)</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack_opt.append(s[i])</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> stack_opt[-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    self.basic_cal(stack_num, stack_opt)</span><br><span class="line">                stack_opt.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack_opt <span class="keyword">and</span> priority[s[i]] &lt;= priority[stack_opt[-<span class="number">1</span>]]:</span><br><span class="line">                    self.basic_cal(stack_num, stack_opt)</span><br><span class="line">                stack_opt.append(s[i])</span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行全部计算</span></span><br><span class="line">        <span class="keyword">while</span> stack_opt:</span><br><span class="line">            self.basic_cal(stack_num, stack_opt)</span><br><span class="line">        val = stack_num[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是队列&amp;&amp;队列的使用场景</title>
    <url>/posts/d18c7429/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>对于一台机器来说，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能的下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置。<br>当我们向一个固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池会如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么事先的呢？</p>
</blockquote>
<h1 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a>什么是队列？</h1><blockquote>
<p><code>队列</code>这个概念非常好理解。当你在食堂排队买饭时，先来的先买，后来的排队等待。<strong>先进先出</strong>，这就是<strong>队列</strong>。</p>
</blockquote>
<p>与栈一样，队列最基本的操作也是两个：<code>入队 enqueue()</code>和<code>出队 dequeue</code></p>
<p>队列和栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p>
<p>队列作为一种非常基础的数据结构，队列的应用也非常广泛：</p>
<ul>
<li>循环队列</li>
<li>阻塞队列</li>
<li>并发队列</li>
</ul>
<h1 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h1><h2 id="数组实现顺序队列"><a href="#数组实现顺序队列" class="headerlink" title="数组实现顺序队列"></a>数组实现顺序队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.queue = []</span><br><span class="line">        self.capacity = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.size() &gt; self.capacity:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;queue is full&quot;</span>)</span><br><span class="line">        self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.size() &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">        queue.enqueue(i)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(queue.first(), queue.end())</span><br><span class="line">    queue.enqueue(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><p><img src="../../images/algorithm/%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97.png" alt="direct"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pointer</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pointer = Pointer()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = ListNode(data)</span><br><span class="line">        _p = self.pointer</span><br><span class="line">        <span class="keyword">if</span> _p.head:</span><br><span class="line">            <span class="comment"># 队列中有元素</span></span><br><span class="line">            tmp = _p.tail</span><br><span class="line">            _p.tail = node</span><br><span class="line">            tmp.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 队列中没有元素, 插入第一个元素</span></span><br><span class="line">            _p.head, _p.tail = node, node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        _p = self.pointer</span><br><span class="line">        <span class="keyword">if</span> _p.head <span class="keyword">and</span> (_p.head == _p.tail):</span><br><span class="line">            <span class="comment"># 队列中有一个元素</span></span><br><span class="line">            tmp = _p.head</span><br><span class="line">            _p.head = _p.tail = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> tmp.data</span><br><span class="line">        <span class="keyword">elif</span> _p.head <span class="keyword">and</span> (_p.head != _p.tail):</span><br><span class="line">            <span class="comment"># 队列中不止一个元素</span></span><br><span class="line">            tmp = _p.head</span><br><span class="line">            _p.head = tmp.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> tmp.data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 队列中没有元素</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;queue is empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.pointer.head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.pointer.head:</span><br><span class="line">            <span class="keyword">return</span> self.pointer.head.data</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">&quot;queue is empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        _p = self.pointer</span><br><span class="line">        tmp = _p.head</span><br><span class="line">        <span class="keyword">while</span> tmp != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;--&gt;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(tmp.data), sep=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            tmp = tmp.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    q.enqueue(<span class="number">1</span>)</span><br><span class="line">    q.enqueue(<span class="number">2</span>)</span><br><span class="line">    q.enqueue(<span class="number">3</span>)</span><br><span class="line">    q.enqueue(<span class="number">4</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    q.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line"></span><br><span class="line">    q.travel()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(q.top())</span><br></pre></td></tr></table></figure>
<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p><img src="../../images/algorithm/img_2.png" alt="direct"></p>
<p>循环队列，顾名思义，它像一个环，在实现过程中，最关键的是<strong>确定好队空和队满的判定条件</strong></p>
<p><img src="../../images/algorithm/img_2.png" alt="direct"></p>
<p>总结如下：</p>
<ul>
<li><strong>队列为空的判断条件：</strong></li>
</ul>
<p><strong>head == tail</strong></p>
<ul>
<li><p><strong>队列为满的情况</strong><br><code>(tail + 1) % cap == head</code></p>
</li>
<li><p><strong>队列长度的计算公式：</strong><br><code>(tail - head + cap)%cap == length</code></p>
</li>
<li><p><strong>尾指针计算</strong><br><code>tail = (tail + 1) % cap</code></p>
</li>
<li><p><strong>头指针计算</strong><br><code>head = (head + 1) % cap</code></p>
</li>
<li><p><strong>队列为满时，图中的 tail 指向的位置实际上没有存储数据。</strong></p>
</li>
</ul>
<h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self._queue = [<span class="literal">None</span>] * (k+<span class="number">1</span>)</span><br><span class="line">        self.cap = k+<span class="number">1</span></span><br><span class="line">        self.front = <span class="number">0</span></span><br><span class="line">        self.rear = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self._queue[self.rear] = value</span><br><span class="line">        self.rear = (self.rear + <span class="number">1</span>) % self.cap</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        data = self._queue[self.front]</span><br><span class="line">        self._queue[self.front] = <span class="literal">None</span></span><br><span class="line">        self.front = (self.front + <span class="number">1</span>) % self.cap</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        data = self._queue[self.front]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        data = self._queue[self.rear - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.front == self.rear</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.front == (self.rear + <span class="number">1</span>) % self.cap</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列实则就是在队列的基础上增加了阻塞操作。</p>
<ul>
<li>队列为空的时候，从队头取数据就会被阻塞</li>
<li>队列满的时候，插入数据就会被阻塞</li>
</ul>
<p><img src="../../images/algorithm/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="img_2.png"></p>
<h2 id="python-阻塞队列实现的生产者-消费者模型"><a href="#python-阻塞队列实现的生产者-消费者模型" class="headerlink" title="python 阻塞队列实现的生产者-消费者模型"></a>python 阻塞队列实现的生产者-消费者模型</h2><p>在 python 中，queue 模块中实现了一个线程安全的队列，<strong>并发队列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">5</span>)  <span class="comment"># 生成一个队列，用来保存“包子”，最大数量为10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productor</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="comment"># 厨师不停地每2秒做一个包子</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q.put(<span class="string">&quot;厨师 %s 做的包子！&quot;</span> % i)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">j</span>):</span></span><br><span class="line">    <span class="comment"># 顾客不停地每秒吃一个包子</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;顾客 %s 吃了一个 %s&quot;</span> % (j, q.get()))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化了3个生产者（厨师）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=productor, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="comment"># 实例化了10个消费者（顾客）</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        v = threading.Thread(target=consumer, args=(j,))</span><br><span class="line">        v.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="线程池没有空闲线程时，新任务请求线程资源时，线程池该如何处理？"><a href="#线程池没有空闲线程时，新任务请求线程资源时，线程池该如何处理？" class="headerlink" title="线程池没有空闲线程时，新任务请求线程资源时，线程池该如何处理？"></a>线程池没有空闲线程时，新任务请求线程资源时，线程池该如何处理？</h2><p>一般有两种处理策略：</p>
<ul>
<li>非阻塞的处理方式<br>直接拒绝任务请求</li>
<li>阻塞方式<br>将请求排队，等到有空闲线程时，取出排队的请求继续处理</li>
</ul>
<p><strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过</strong>队列<strong>这种资源来实现请求排队。</strong></p>
<h2 id="队列总结"><a href="#队列总结" class="headerlink" title="队列总结"></a>队列总结</h2><p>队列的最大特点就是：<strong>先进先出</strong>，主要的两个操作是<strong>入队和出队</strong>。</p>
<ul>
<li>利用数组实现的叫顺序队列</li>
<li>利用链表实现叫链式队列</li>
</ul>
<h2 id="CAS-实现无锁队列"><a href="#CAS-实现无锁队列" class="headerlink" title="CAS 实现无锁队列"></a>CAS 实现无锁队列</h2><p>参考：<a href="https://coolshell.cn/articles/8239.html">https://coolshell.cn/articles/8239.html</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基本的数据结构和算法</title>
    <url>/posts/d92d1b7b/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;出栈&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    s.push(<span class="number">1</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.stack)</span><br><span class="line"></span><br><span class="line">    s.pull()</span><br><span class="line">    <span class="built_in">print</span>(s.stack)</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chain</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.data, end=<span class="string">&#x27;-***-&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,index,data</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.add(data)</span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.length() -<span class="number">1</span>:</span><br><span class="line">            self.append(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            node = Node(data)</span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                <span class="keyword">if</span> cur == self.head:</span><br><span class="line">                    self.head = self.head.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span> <span class="comment">#前节点等于后节点</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;数据%f存在于链表中&quot;</span> % cur.data)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据不存在于链表中&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>递归就是不断调用函数本身</p>
</blockquote>
<h3 id="阶乘-1-2-3-N"><a href="#阶乘-1-2-3-N" class="headerlink" title="阶乘 1 * 2 * 3....*N"></a>阶乘 <code>1 * 2 * 3....*N</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rescuvie</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * rescuvie(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>递归使用了运算符，每次重复的调用都使得运算的链条不断加长，系统不得不使用栈进行数据保存和恢复<br>如果每次递归都要对越来越长的链条进行运算，那速度极慢，并且可能栈溢出，导致程序崩溃</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><blockquote>
<p>尾部递归是指递归函数在调用自身后直接传回其值，而不对其再加运算，效率将会极大的提高。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rescurieTail</span>(<span class="params">n, a</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> rescurieTail(n-<span class="number">1</span>, a*n)</span><br></pre></td></tr></table></figure>


<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><a href="https://blog.csdn.net/weixin_42702038/article/details/106744386">https://blog.csdn.net/weixin_42702038/article/details/106744386</a></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p>首先在未排序的序列中找到最小（大）元素，存放在排序序列的起始位置，然后在剩余的列表中查找，依次放入到新列表中。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出最小元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_smallest_item</span>(<span class="params">arr</span>):</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    new_arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        smallest_index = find_smallest_item(arr)</span><br><span class="line">        new_arr.append(arr.pop(smallest_index))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(select_sort([<span class="number">4</span>, <span class="number">324</span>, <span class="number">42</span>, <span class="number">45</span>, <span class="number">2435</span>, <span class="number">2</span>, <span class="number">2</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>分而治之的思想</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="comment"># 基准的选择</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        less_arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater_arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick_sort(less_arr) + [pivot] + quick_sort(greater_arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(quick_sort([<span class="number">2</span>, <span class="number">3</span>, <span class="number">49</span>, <span class="number">10</span>, <span class="number">24</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote>
<p>冒泡排序思想：遍历整个数据列表，在一组数据中，每遍历比较一次数据，最大的数便会”冒泡”到数据列表右端</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaray_search</span>(<span class="params">li, item</span>):</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(li) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:  <span class="comment"># 确定范围</span></span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        guess = li[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == item:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> guess &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(binaray_search([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">6</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析</title>
    <url>/posts/a1a87ec3/</url>
    <content><![CDATA[<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>复杂度分析是整个算法学习的基础和重点，当开发人员在编写代码时，可以粗略地估算代码的执行效率是非常重要的；</p>
<p>所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比，用公式可以表示为：</p>
<p>​        <strong>T(n) = O(f(n))</strong></p>
<p>所以我们一般使用 大 O 时间复杂度表示法来表示时间复杂度；</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>这里将使用网上找的几个例子来学习时间复杂度的计算：</p>
<p>例子一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;哈哈&quot;</span>); # <span class="number">1</span> 次</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> # <span class="number">1</span> 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) # <span class="number">1</span> + n+<span class="number">1</span> + n </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;哈哈哈哈哈&quot;</span>); <span class="meta"># n</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; # <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个例子中，分别计算的次数为：</p>
<ul>
<li>2</li>
<li>3n+3</li>
</ul>
<h3 id="常见的时间复杂度分析"><a href="#常见的时间复杂度分析" class="headerlink" title="常见的时间复杂度分析"></a>常见的时间复杂度分析</h3><ul>
<li><p><strong>O(1)</strong></p>
<p>在上述例一中的时间复杂度就是 O（1）—— <strong>表示常量级时间复杂度</strong>；</p>
<p><strong>一般情况下，只要算法中不存在循环语句，递归语句，即使有成千上万行代码，其时间复杂度也是 O(1);</strong></p>
</li>
<li><p><strong>O(logn) &amp;&amp; O(nlogn)</strong></p>
<p>对数时间复杂度非常常见，同时也是比较难分析的一种时间复杂度</p>
<p>我们来用一个例子来详细还原一个这种时间复杂度的计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xi xi xixixi&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，当 n = 8：</p>
<ul>
<li>i = 1 时 -&gt;  判断 1 &lt; 8  成立；i = 1 * 2 = 2，打印文本  </li>
<li>i = 2 时 -&gt; 2 &lt; 8 成立；i = 2*2  = 4，打印文本</li>
<li>i = 4 时 -&gt; 4 &lt; 8 成立；i = 4 * 2 = 8，打印文本</li>
<li>i = 8 时 -&gt; 8 &lt; 8 不成立；程序结束</li>
</ul>
<p>于是，其执行时间 <strong>T(8) = 3（for 循环）<del>+ 3（printf）+ (3+1)(i&lt;n) + 1(int i = 1)</del> -&gt; 3 * (3) +2</strong></p>
<p>因为对这个代码的时间复杂度的影响最大的就是 i&lt; n &amp;&amp; i <em>=2 ；*<em>于是我们可以简化为：T(8) = 3, 只关注 for 循环语句；</em></em></p>
<p>于是，得出规律：</p>
<p>2^3 = 8;</p>
<p>2^4 = 16;</p>
<p>…</p>
<p>2^T(n) = 3</p>
<p>我们知道，对于对数而言，不论是以 2，3，10 为低，都是可以互相转换的，于是可以统一采用 logn 来表示</p>
<p><strong>从而推出：T(n) = 3log2n +2 = O(logn)</strong></p>
</li>
<li><p>O(n^2)</p>
</li>
</ul>
<p>​    n 方的复杂度也十分常见，在代码中常表示为 for 嵌套或者 while 循环；</p>
<p>​    这里也是用一个例子来进行学习：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)&#123; <span class="meta"># n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; ++j) &#123; <span class="meta"># n</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;hahahahah&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里嵌套了两层 for 循环，可以很明显的看出其时间复杂度为 O(n^2)</p>
<p>当然，如果是 n 层嵌套，那么其时间复杂度为：O(n^n)</p>
<h2 id="时间复杂度对比"><a href="#时间复杂度对比" class="headerlink" title="时间复杂度对比"></a>时间复杂度对比</h2><table>
<thead>
<tr>
<th>名称</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>常数时间</td>
<td>O(1)</td>
</tr>
<tr>
<td>对数时间</td>
<td>O(logn)</td>
</tr>
<tr>
<td>线性时间</td>
<td>O(n)</td>
</tr>
<tr>
<td>线性对数时间</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>二次时间</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>三次时间</td>
<td>O(n^3)</td>
</tr>
<tr>
<td>指数时间</td>
<td>O(2^n)</td>
</tr>
</tbody></table>
<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>空间复杂度全称就是<strong>渐进空间复杂度</strong>，表示算法的存储空间与数据规模之间的增长关系</p>
<p>这段代码仅用于举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们申请了一个大小为 n 的数组，于是其空间复杂度为 O(n);</p>
<p>常见的空间复杂度就是 O(1), O(n), O(n^2)，类似对数的复杂度都用不到</p>
<h2 id="最好、最坏、平均、均摊时间复杂度"><a href="#最好、最坏、平均、均摊时间复杂度" class="headerlink" title="最好、最坏、平均、均摊时间复杂度"></a>最好、最坏、平均、均摊时间复杂度</h2><h3 id="最好、最坏时间复杂度"><a href="#最好、最坏时间复杂度" class="headerlink" title="最好、最坏时间复杂度"></a>最好、最坏时间复杂度</h3><p>上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照时间复杂度分析，这段代码的时间复杂度为 O(n)</p>
<p>但是在实际情况中，当我们在一个数组中查找某个数据，并不一定需要将整个数组遍历一遍；</p>
<p>可能会出现比较极端的情况，例如 一次 就查找到了数据或者最后才查找到数据；</p>
<h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><p>平均时间复杂度应该如何分析呢？</p>
<p>要查找的变量 x 在数组中的位置，有 n+1 种情况；<strong>在数组的 0～n-1 的位置中</strong>和<strong>不在数组中</strong>，将每种情况下，需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值：</p>
<p>1+2+3+…+n+n/n+1 = 1/2 n = O(n)</p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>均摊时间复杂度，以及它对应的分析方法，摊还分析（或者叫做平摊分析）</p>
<p>借助一段代码来学习：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// array表示一个长度为n的数组</span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n</span></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) &#123;</span><br><span class="line">         sum = sum + <span class="built_in">array</span>[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">array</span>[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我先来解释一下这段代码。这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<ul>
<li>最理想的情况下，是该数组一直有空闲空间，只需要插入数据即可，时间复杂度为 O(1)</li>
<li>最坏情况下，是插入数据时，数据已满，时间复杂度为 O(n)</li>
</ul>
<p><strong>那么平均时间复杂度为多少呢？</strong></p>
<p><strong>答案是 O(1)</strong></p>
<p><strong>因为对于每个数据的插入而言，其数组满的情况都被分解为每次插入了，例如已经插入了 9 次数据时，第十次插入时发生了 for 循环，那么这一次的复杂度也被均摊到前 9 次了。</strong></p>
<p>这也就是<strong>均摊时间复杂度</strong>的由来了</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>video: <a href="https://www.bilibili.com/video/BV1nE411x7qP/?from=search&amp;seid=3250974645541167987&amp;spm_id_from=333.337.0.0&amp;vd_source=67c3c7f430d599a6b5dacd9127487fc7">https://www.bilibili.com/video/BV1nE411x7qP/?from=search&amp;seid=3250974645541167987&amp;spm_id_from=333.337.0.0&amp;vd_source=67c3c7f430d599a6b5dacd9127487fc7</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何玩转二分法查找？</title>
    <url>/posts/975ea5bf/</url>
    <content><![CDATA[<h1 id="什么是二分查找？"><a href="#什么是二分查找？" class="headerlink" title="什么是二分查找？"></a>什么是二分查找？</h1><p>二分查找（Binary Search）算法，也叫做<strong>折半查找算法</strong></p>
<h1 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h1><p>典型的猜数游戏，随机在 0-99 中选中一个数让人去猜，猜的过程中，每猜一次，就会告诉对方大了还是小了，直到猜中为止。<br><img src="../../images/algorithm/guessNum.png" alt="direct"><br>在这个游戏中，7 次就猜出来了。<br>如果是 0 - 999 的数字，最多也就要 10 次就能猜中。</p>
<p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0</strong></p>
<h1 id="二分查找的时间复杂度"><a href="#二分查找的时间复杂度" class="headerlink" title="二分查找的时间复杂度"></a>二分查找的时间复杂度</h1><p>二分查找是一种非常高效的查找算法，**时间复杂度为 O(logn)。<br>被查找区间的大小变化为：n, n/2, n/4, n/8, ……, n/2^k ……<br>已知通过 <code>n/2^k=1</code> 得到 k=log2n。所以时间复杂度就为：<code>O(logn)</code></p>
<p>logn 是一个非常恐怖的数量级，即便 n 非常非常大，对应的 logn 也很小。2^32 次大约是 42 亿，但是利用二分查找，最多需要比较 32 次。</p>
<h1 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h1><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">arr: <span class="built_in">list</span>, guess: <span class="built_in">int</span></span>):</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &lt; guess:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; guess:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    index = binary_search(arr, <span class="number">9</span>)</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>三个注意点：</p>
<ul>
<li>循环退出条件<br>low &lt;= high，而不是 low &lt; high</li>
<li>mid 取值<br>实际上，<code>mid=(low+high)/2</code> 的写法是有问题的。如果 low 和 high 比较大的话，两者之和就会溢出。<br>改进的方法是将 mid 的计算方式写成 low+(high-low)/2。<br>性能优化到极致的话，可以改写成位运算<code>low+((high-low)&gt;&gt;1)</code>。</li>
<li>low 和 high 的更新<br><code>low=mid+1</code> 和 <code>high=mid-1</code>。如果直接写成 low=mid 或者 high=mid，就可能发生死循环。</li>
</ul>
<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">half_search</span>(<span class="params">arr, key, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &gt; right:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key == arr[mid]:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">elif</span> key &gt; arr[mid]:</span><br><span class="line">        <span class="keyword">return</span> half_search(arr, key, mid + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> half_search(arr, key, left, mid - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><p>在以上的分析中，二分查找的时间复杂度为 <code>O(logn)</code>，查找数据的效率非常高。</p>
<ul>
<li><strong>二分查找依赖的是顺序表结构，简单点说就是数组</strong></li>
<li><strong>二分查找针对的是有序数组</strong></li>
<li><strong>数据量过小或者过大也不适合二分查找</strong></li>
</ul>
<h1 id="二分查找的变形问题"><a href="#二分查找的变形问题" class="headerlink" title="二分查找的变形问题"></a>二分查找的变形问题</h1><h2 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找第一个给定值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_search</span>(<span class="params">arr, value</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; value:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; value:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arr[mid-<span class="number">1</span>] != value:  <span class="comment"># 若为 arr 的第一个元素或者前一个数不是 value</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 前移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>以上的代码中还是分为三种情况，即<code>=,&gt;,&lt;</code>,但是当 = 的时候，为了找到是列表中第一个找到的元素，需要向前比较，当前一个数不等于目标值时，则为第一个</strong></p>
<h2 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">final_search</span>(<span class="params">arr, value</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; value:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; value:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">or</span> arr[mid+<span class="number">1</span>] != value:  <span class="comment"># 若为 arr 的最后一个元素或者后一个数不是 value</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 后移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_greater_search</span>(<span class="params">arr, value</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= value:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arr[mid - <span class="number">1</span>] &lt; value:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果 a[mid] 小于我们要查找的值 value, 那要查找的值肯定在 [mid+1, right] 之间，所以 left = mid + 1<br>对于 a[mid] 大于等于给定着 value 的情况，判断是否是第一个大于等于给定值的情况：mid=0 或者 前一个数小于要查找的值。</p>
<h2 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_greater_search</span>(<span class="params">arr, value</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; value:</span><br><span class="line">            right = mid - <span class="number">1</span>     </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">or</span> arr[mid + <span class="number">1</span>] &gt; value:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>如何在 1000 W 个整数中快速查找某个整数？</p>
<p>如果我们内存限制是 100 MB,每个数据的大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80 MB,符合内存的限制。<br>可以先对这 1000 W 的数据从小到大排序，然后再利用二分查找随发，就可以快速地查找想要的数据了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——冒泡、插入、选择排序</title>
    <url>/posts/7b385955/</url>
    <content><![CDATA[<h1 id="常用的排序算法"><a href="#常用的排序算法" class="headerlink" title="常用的排序算法"></a>常用的排序算法</h1><p>参考：<a href="https://blog.csdn.net/weixin_42702038/article/details/106744386">https://blog.csdn.net/weixin_42702038/article/details/106744386</a></p>
<p><img src="../../images/algorithm/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="direct"></p>
<p><strong>问题带入：在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法？</strong></p>
<h1 id="排序算法分析"><a href="#排序算法分析" class="headerlink" title="排序算法分析"></a>排序算法分析</h1><ul>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数、低阶<br>时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系统、常数、低阶。</li>
<li>比较次数和交换（或移动）次数</li>
<li>排序算法的内存消耗<br>冒泡、选择、插入 排序算法都是<strong>原地排序算法</strong></li>
<li>排序算法的稳定性<br>若待排序的序列中存在值相等的元素，经过排序之后相等元素之间原有的先后顺序不变，就是稳定的排序算法</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><img src="../../images/algorithm/bubble_sort_flow.png" alt="direct"></p>
<ul>
<li>空间复杂度为 O(1), 是一个<strong>原地排序算法</strong></li>
<li>相邻的两个元素相等时，不会交换顺序，是<strong>稳定的排序算法</strong></li>
<li>最好时间复杂度为 O(n),最坏时间复杂度为 O(n^2)<br><img src="../../images/algorithm/bubble_sort_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="direct"></li>
</ul>
<h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> li:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    length = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    li = [<span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(bubble_sort(li))</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序思想：插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序序列，在已排序的序列中从后向前扫描，找当相应的位置并插入。</p>
<p><img src="../../images/algorithm/insert_sort_flow.png" alt="direct"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        arr[j + <span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序类似于插入排序，区分已排序区间和未排序区间。但是选择排序每次都会从未排序区间找到最小的元素，将其放到队首</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">                arr[i], arr[min_index] = arr[min_index], arr[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="../../images/algorithm/%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.png" alt="direct"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现一个工业级的散列表</title>
    <url>/posts/da7213b0/</url>
    <content><![CDATA[<p>如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</p>
<p>在了解到的 「 散列表 」中，我们了解散列表的查询效率并不能笼统的说成 O(1)，其依赖三个部分：</p>
<ul>
<li>散列函数</li>
<li>装载因子</li>
<li>散列冲突</li>
</ul>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><blockquote>
<p>如何设计一个又好又快的散列表</p>
</blockquote>
<ul>
<li><p><strong>散列函数的设计不能太复杂</strong>，过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能</p>
</li>
<li><p><strong>散列函数生成的值要尽可能随机平均分布，最小化避免散列冲突</strong></p>
</li>
</ul>
<p>我理解为：<strong>简单且迅速且平均分布</strong></p>
<p>常见的一些散列思想为：</p>
<ul>
<li>数据分析法</li>
<li>直接寻址法</li>
<li>平方取中法</li>
<li>折叠法</li>
<li>随机数法</li>
</ul>
<p>我这里介绍一下 <strong>数据分析法</strong>，比较好理解。</p>
<h3 id="数据分析法"><a href="#数据分析法" class="headerlink" title="数据分析法"></a>数据分析法</h3><ol>
<li>对于我们而言，在校园中，工作中，社会中，都会有自己的 ID 标识，这里用学号举例子：</li>
</ol>
<ul>
<li>2023011002</li>
</ul>
<p>2023 级 大一 10 班 02 号</p>
<p>对于每一个学生的身份信息都可以使用这个 id 来存储：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;2023011002&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Hash(2023011002) == 011002 % 100000</p>
<hr>
<ol start="2">
<li>还有就是 word 单词拼写检查功能。</li>
</ol>
<p>对于词库的存储，其每个单词都可以通过  ASCII 码 进位相加，然后再和散列表的大小取余、取模，作为散列值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hash</span>(<span class="string">&quot;nice&quot;</span>)=((<span class="string">&quot;n&quot;</span> - <span class="string">&quot;a&quot;</span>) * <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">&quot;i&quot;</span> - <span class="string">&quot;a&quot;</span>)*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">&quot;c&quot;</span> - <span class="string">&quot;a&quot;</span>)*<span class="number">26</span>+ (<span class="string">&quot;e&quot;</span>-<span class="string">&quot;a&quot;</span>)) / <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>当然，这种方法都只是一种分析方法，捉襟见肘</p>
<h2 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h2><p>装载因子描述的是散列表中元素的个数大小情况，成正比。</p>
<p><strong>对于动态散列表而言，数据集合是频繁变动的，我们无法准确的预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。这个时候动态扩容就变得很重要了</strong></p>
<p>对于数组的扩容策略而言，<strong>只需要空间申请&amp;&amp;数据搬移即可</strong>，但是散列表的数据搬移就会显得比较复杂：<strong>当散列表的大小变化后，数据存储的位置也会发生变化</strong>，这是因为空间是新申请的，即使哈希值没有变化，但是空间地址已经发生了变化。</p>
<p>例如：原本的 21 的 index == 0，但是经过扩容后，index == 7</p>
<img src="https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg?wh=1142*756" alt="img" style="zoom:67%;" />

<h3 id="高效的扩容"><a href="#高效的扩容" class="headerlink" title="高效的扩容"></a>高效的扩容</h3><p>装载因子阈值的设置要权衡时间、空间复杂度。</p>
<p>对于动态扩容而言，当采用单纯的设置阈值的方式进行扩容，会发生比较极端的情况。例如：当阈值设置为 1GB 时，那就需要对 1GB 的数据进行 hash ，然后进行数据搬移，此时就会比较耗时，如果涉及到用户操作，那么可能发生阻塞。</p>
<p>于是，采用分而治的思想，我们可以在每次插入的时候进行扩容，分批完成。<strong>当装载因子触及阈值时，我们只申请新空间，但是不将老的数据插入。当有新的数据插入的时候，我们将新数据插入到新申请的空间中，然后将老的数据搬移，经过多次插入操作后，就完成了动态搬移。</strong></p>
<p><strong>其实上述的思想就是渐进式 rehash，其本质是空间换时间。</strong></p>
<blockquote>
<p>渐进式 Rehash 这一实现的/类似的思想，本质是空间换时间。 1. Redis 的全局哈希表就是这么做的。具体可以看 <a href="https://time.geekbang.org/column/article/268253">https://time.geekbang.org/column/article/268253</a> 2. 在 RocksDB 中也有体现。利用两个相同的内存空间 Memtable1 和 Memtable2，一个用来接收正在写入的数据，一个备着。当 Memtable1 写满了数据，再去刷盘，然后 Memtable2 来写入数据，这个是可以限流的。轮换着写入数据 -&gt; 刷盘。具体的可以看 <a href="https://time.geekbang.org/column/article/298205">https://time.geekbang.org/column/article/298205</a> 3. JVM 复制清除算法也是这么做的。</p>
</blockquote>
<p><strong>那么问题来了，查询操作如何执行呢？</strong><br><strong>为了兼容新、老数据，我们先从新的散列表中查找，如果没有找到，再去老的散列表中查找。</strong></p>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法可以有效地利用 CPU 缓存加快查询速度，这种方式实现的散列表比较好序列化。</p>
<p><strong>当数据量较小，装载因子小的时候，适合采用开放寻址法。这也是 Java 中的 ThreadLocalMap 使用开放寻址法解决冲突的原因。</strong></p>
<h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>基于链表的散列冲突的处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，例如用红黑树代替链表。</p>
<p><strong>链表法对内存的利用率比开放寻址法要高。</strong></p>
<p>链表中的数据都是通过指针进行索引的，对于小对象而言，一个指针（4/8 bytes）可能会消耗更多，而对于大对象则可忽略。</p>
<p>实际上，链表法也是可以改造的，可以实现一个更加高效的散列表。那就是使用其他数据结构，例如跳表或着红黑树。</p>
<img src="https://static001.geekbang.org/resource/image/10/29/103b84d7173277c5565607b413c40129.jpg?wh=1142*593" alt="img" style="zoom:67%;" />



<h2 id="工业散列表"><a href="#工业散列表" class="headerlink" title="工业散列表"></a>工业散列表</h2><h3 id="Java-HashMap"><a href="#Java-HashMap" class="headerlink" title="Java HashMap"></a>Java HashMap</h3><h4 id="1-初始大小"><a href="#1-初始大小" class="headerlink" title="1. 初始大小"></a>1. 初始大小</h4><p>Java HashMap 的默认初始大小是 16，可以配置修改；</p>
<h4 id="2-装载因子和动态扩容"><a href="#2-装载因子和动态扩容" class="headerlink" title="2. 装载因子和动态扩容"></a>2. 装载因子和动态扩容</h4><p>最大的装载因子默认是 0.75，当 HashMap 中的元素个数超过 0.75 * capacity (capacity 表示散列表的容量)的时候，就会自动扩容，每次扩容都会扩容为原来的两倍大小。</p>
<h4 id="3-散列冲突解决办法"><a href="#3-散列冲突解决办法" class="headerlink" title="3. 散列冲突解决办法"></a>3. 散列冲突解决办法</h4><p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p>
<p>于是在 JDK 1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。当链表长度太长（默认超过 8 ）时，链表就转换为红黑树。我们可以使用红黑树快速增删改查的特定，提升 HashMap 的性能。当红黑树节点少于 8 时，又会将红黑树转化为链表。</p>
<h4 id="4-散列函数"><a href="#4-散列函数" class="headerlink" title="4. 散列函数"></a>4. 散列函数</h4><p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。</p>
<p>以下是 java 的 hash 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">hash</span>(Object key) &#123;</span><br><span class="line">    <span class="built_in">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capicity -<span class="number">1</span>); //capicity表示散列表的大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">  <span class="built_in">int</span> var1 = this.<span class="built_in">hash</span>;</span><br><span class="line">  <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; this.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    char[] var2 = this.value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> var3 = <span class="number">0</span>; var3 &lt; this.value.length; ++var3) &#123;</span><br><span class="line">      var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    this.<span class="built_in">hash</span> = var1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Python-dictobject"><a href="#Python-dictobject" class="headerlink" title="Python dictobject"></a>Python dictobject</h3><p>python 字典</p>
<h4 id="1-初始大小-1"><a href="#1-初始大小-1" class="headerlink" title="1. 初始大小"></a>1. 初始大小</h4><p>dict 的初始大小是 8 个存储桶。</p>
<p>其中桶是一种特殊的数据结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value;</span><br><span class="line">&#125; PyDictEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-装载因子和动态扩容-1"><a href="#2-装载因子和动态扩容-1" class="headerlink" title="2. 装载因子和动态扩容"></a>2. 装载因子和动态扩容</h4><p>在 CPython 中，装载因子的阈值通常是 2/3。当字典中的键值对数量超过当前存储桶的 2/3 时，就会触发动态扩容。</p>
<ul>
<li><p>下面是动态扩容的大致步骤：</p>
<ol>
<li>当字典的装载因子超过阈值时，触发动态扩容操作。</li>
<li>计算新的存储桶数量，通常是当前存储桶数量的两倍。</li>
<li>分配一个新的存储桶数组，并进行初始化。</li>
<li>遍历原存储桶数组中的键值对。</li>
<li>对于每个键值对，根据键的哈希值和新的存储桶数量，计算键在新存储桶数组中的位置。</li>
<li>将键值对插入新的存储桶数组中的对应位置。</li>
<li>释放原存储桶数组的内存。</li>
<li>更新字典的元数据，包括存储桶数量和已使用的存储桶数量。</li>
</ol>
<p>这样的动态扩容操作确保了字典可以适应更多的键值对，并且保持较高的查找效率。在扩容期间，字典仍然保持可用，但插入操作可能会稍微慢一些。</p>
<p>请注意，动态扩容过程中并不会同时维护两个哈希表，而是在新的存储桶数组中重新哈希所有的键值对。这样确保了字典的一致性和正确性。</p>
</li>
</ul>
<h4 id="3-散列冲突解决办法-1"><a href="#3-散列冲突解决办法-1" class="headerlink" title="3. 散列冲突解决办法"></a>3. 散列冲突解决办法</h4><p><strong>CPython使用开放寻址法来解决哈希冲突，具体而言是线性探测法。</strong></p>
<p>当发生哈希冲突时，CPython会按照以下步骤解决冲突：</p>
<ol>
<li>根据键的哈希值计算存储桶的初始位置。</li>
<li>如果该位置的存储桶为空（未被占用），则将键值对插入该位置。</li>
<li>如果该位置的存储桶已经被占用，则继续线性探测，即依次检查下一个存储桶，直到找到一个空槽或者完全遍历整个存储桶数组。</li>
<li>当找到一个空槽时，将键值对插入该位置。</li>
<li>如果遍历整个存储桶数组都没有找到空槽，即所有的存储桶都被占用了，那么会触发动态扩容，重新分配更大的存储桶数组，并重新哈希键值对。</li>
</ol>
<p>通过线性探测，CPython尝试在哈希冲突的情况下找到下一个可用的存储桶。这样，具有相同哈希值的键值对可以在存储桶数组中找到不同的位置。</p>
<p><strong>需要注意的是，线性探测法可能会导致聚集（clustering）现象，即连续的键值对被插入到相邻的存储桶中，造成查找和插入操作的性能下降。为了缓解这个问题，CPython还使用了二次探测（quadratic probing）和双重散列（double hashing）等技术来处理冲突，以提高字典的性能。</strong></p>
<p>总结起来，CPython中字典解决哈希冲突的方法是使用开放定址法，具体而言是线性探测法。在冲突发生时，它会线性探测存储桶数组，直到找到一个空槽或者触发动态扩容操作。这样保证了具有相同哈希值的键值对能够被正确插入到字典中。</p>
<h4 id="4-散列函数-1"><a href="#4-散列函数-1" class="headerlink" title="4. 散列函数"></a>4. 散列函数</h4><p>自从CPython 3.4版本开始，它使用了一种称为”SipHash”的哈希算法。SipHash是一种快速且安全的哈希算法，适用于哈希表等数据结构。它被设计为具有较低的碰撞概率和高度的安全性。</p>
<p>CPython使用SipHash算法计算散列值，以保证字典的安全性和效率。这是CPython中哈希函数的默认实现。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>经典排序算法-冒泡/插入/选择排序</title>
    <url>/posts/a90fa35e/</url>
    <content><![CDATA[<h1 id="经典排序算法——冒泡、选择、插入"><a href="#经典排序算法——冒泡、选择、插入" class="headerlink" title="经典排序算法——冒泡、选择、插入"></a>经典排序算法——冒泡、选择、插入</h1><p>今天我们一起来回顾三种排序算法，这三种排序算法的平均时间复杂度都是 <code>O(n^2)</code>，都是属于原地排序的算法。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>首先学习的是冒泡排序算法，我们还是使用 3W 方法来学习，What? Why? How?</p>
<p>什么是冒泡排序？</p>
<p><strong>冒泡排序指的是对于一组数据，只会操作相邻的两个数据，对其进行比较，判断是否满足大小关系，如果不满足则互换位置，一次冒泡至少会让一个数据移动到其该有的位置。</strong></p>
<p>为什么要使用冒泡排序？</p>
<p>对于一种排序算法，其需要从实现复杂度，空间复杂度，时间复杂度上来理解，对于冒泡排序而言，其时间复杂度为 <code>O（n^2）</code>，空间复杂度为 O(1)，且为原地的排序算法。</p>
<p>如何实现冒泡排序？</p>
<p>首先，我们可以通过一个例子来观察冒泡排序的具体细节。</p>
<p>这是一组未排序的数据：<code>[9, 10, 2, 0, 2, 3, 0]</code></p>
<table>
<thead>
<tr>
<th>冒泡次数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>第一次</td>
<td>[9,  2,  0,  2,  3,  0, 10]</td>
</tr>
<tr>
<td>第二次</td>
<td>[2,  0,  2,  3,  0,  9, 10]</td>
</tr>
<tr>
<td>第三次</td>
<td>[2,  0,  2,  0,  3,  9, 10]</td>
</tr>
<tr>
<td>第四次</td>
<td>[0,  2,  0,  2,  3,  9, 10]</td>
</tr>
<tr>
<td>第五次</td>
<td>[0,  0,  2,  2,  3,  9, 10]</td>
</tr>
<tr>
<td>第六次</td>
<td>[0,  0,  2,  2,  3,  9, 10]</td>
</tr>
<tr>
<td>第七次</td>
<td>[0,  0,  2,  2,  3,  9, 10]</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>以上就是冒泡排序的详细细节。</p>
<p>从每次的排序过程中，我们可以看到，对于这组数组而言，其实是在构建有序范围和无序范围。例如，第一次冒泡，有序空间为：<code>arr[6:6]</code>, 无序空间为：<code>arr[0:6]</code></p>
<p>现在：我们可以基于以上的结论实现冒泡排序了，本次使用的是 Python 编程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  冒泡排序</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  n = <span class="built_in">len</span>(arr)</span><br><span class="line">  <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i-<span class="number">1</span>):</span><br><span class="line">      <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">        arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<p>然后在 5，6， 7 次排序的过程中，我们发现数据已经在第 5 次排序完成了。</p>
<p>此时，我们可以进一步优化, 在一次冒泡中是否发生数据交换标识位来判断是否已经排序完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  冒泡排序</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  n = <span class="built_in">len</span>(arr)</span><br><span class="line">  <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    exchange = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i-<span class="number">1</span>):</span><br><span class="line">      <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">        arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">        exchange = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<p>以上就是冒泡排序的总结了</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>在学习完冒泡排序后，我们接下来学习插入排序。</p>
<p>什么是插入排序呢？</p>
<p><strong>我们通过一个问题来学习插入排序，一个有序的数组，如何插入一个数据，使得其仍然有序？插入排序便是这样的思想，在每次排序时，构建有序空间，将无序空间中的数据放置在有序空间中该有的位置（满足大小关系）。</strong></p>
<p>同样，插入排序的时间复杂度为 <code>o(n^2)</code>, 空间复杂度为 <code>O（1）</code>实现复杂度较于冒泡排序而言难度高一些。</p>
<p>我们还是通过一个例子来学习插入排序。</p>
<p>现在有一组未排序的数组 <code>[9, 10, 2, 0, 2, 3, 0]</code>。</p>
<p>这里也是通过一个例子来看一下插入排序的详细过程。</p>
<img src="/Users/tyronemaxi/Downloads/3031690552330_.pic_hd_副本.jpg" alt="3031690552330_.pic_hd_副本" style="zoom:10%;" />

<p>现在使用 python 进行编程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    插入排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        flag = arr[i]</span><br><span class="line">        j = i-<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> flag &lt; arr[j]:</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = flag</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>接下来，我们学习最后一个排序算法是选择排序。</p>
<p>那么什么是选择排序呢？</p>
<p>选择排序的实现原理和插入排序较为类似，也分为有序区间和无序区间，但是每次选择排序都是找到未排序中最小的元素，将其放置已排序空间末尾。</p>
<p>其时间复杂度为 <code>O(n^2)</code>, 空间复杂度为 <code>O(1)</code>, 个人觉得实现复杂度较选择排序而言相对简单一些。</p>
<p>同样，我们还是使用一个例子，观察其排序细节来进行学习。</p>
<img src="/Users/tyronemaxi/Library/Application Support/typora-user-images/image-20230728233635871.png" alt="image-20230728233635871" style="zoom:30%;" />

<p>在上面的例子中，我们可以看到，每次都查找未排序数组最小的值和有序数组末尾+1 的值进行交换，从而进行排序。</p>
<p>现在，我们使用 python 来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  选择排序</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        min_value = arr[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; min_value:</span><br><span class="line">                min_index = j</span><br><span class="line">                min_value = arr[j]</span><br><span class="line"></span><br><span class="line">        arr[i], arr[min_index] = arr[min_index], arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<p>今天学习的三种排序算法，在实际应用中较少，但是对于小规模的数据，用起来非常高效。但是插入排序还是挺有用的。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>IO 多路复用原理及实现</title>
    <url>/posts/99dcd5a7/</url>
    <content><![CDATA[<h1 id="IO-多路复用原理及实现"><a href="#IO-多路复用原理及实现" class="headerlink" title="IO 多路复用原理及实现"></a>IO 多路复用原理及实现</h1><blockquote>
<p>IO 多路复用是一种用于提高程序性能的网络编程技术。它通过在一个线程内同时监听多个输入输出流（通常是网络套接字），实现了在单个线程中处理多个并发的 IO 操作。这样可以避免创建大量的线程或进程，从而减少资源消耗和提高程序的并发处理能力。</p>
</blockquote>
<p><strong>今天我们一起学习 IO 多路复用的网络模型。在学习之前，请允许我介绍一下什么是 IO 多路复用模型？以及为什么要用到它？</strong></p>
<p>在传统的阻塞 IO 模型中，当一个线程处理一个 IO 操作时，如果 IO 操作未完成，线程会被阻塞，无法处理其他的 IO 操作，这会导致效率低下。当然在非阻塞式的 IO 模型中，可以通过轮询的方式去获取任务是否处理完成，适用于不同类型任务的机制，但是这样也会特别消耗 cpu 资源，增加代码的复杂度。</p>
<p>IO 多路复用则是很好的避免了这些，其是基于 select/pool/epool 系统函数来监听多个 IO 的状态，当某个 IO 的状态发生改变时，调用回调函数，从而实现在单个线程中处理多个 IO 任务的能力，提高并发。</p>
<p>其中有 Nginx, Tornado, netty 等开源框架，都使用了 IO 多路复用模型，被广泛使用。</p>
<p>关于 unix io 模型的种类，这篇文章有详细介绍：<a href="http://localhost:4000/posts/baf320b1/">http://localhost:4000/posts/baf320b1/</a></p>
<h2 id="select-amp-amp-poll-amp-amp-epoll"><a href="#select-amp-amp-poll-amp-amp-epoll" class="headerlink" title="select &amp;&amp; poll &amp;&amp; epoll"></a>select &amp;&amp; poll &amp;&amp; epoll</h2><p>在介绍 IO 多路复用之前，先介绍一下这三个系统调用函数，其在不同的操作系统中提供了类似的功能，运行程序同时监听多个 IO 对象的状态。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 是最古老和最常见的 IO 多路复用机制之一，<strong>它使用三个文件描述符集合（读、写、异常）来检查多个 IO 对象的状态</strong>，然后其会阻塞等待，直到其中至少一个 IO 对象就绪或达到超时时间。然后其就会返回就绪的 IO 对象，应用程序可以对其进行相应的操作。</p>
<p><strong>但是 select 每次在调用时都会重新构建文件的描述符集合，效率较低。</strong></p>
<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p>pool 相对于 select 而言，<strong>是更加现代化和高效的 IO 多路复用机制</strong>。<strong>pool 使用一个文件描述符组来检查多个 IO 对象的状态</strong>。与 select 不同的是，pool 不需要重新构建文件描述符集合，可以直接使用数组，从而提高了效率。<strong>它也能处理更大的文件描述符数量。</strong></p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 是在 linux 系统中提供的高效的 IO 多路复用机制。它引入了 三个重要的概念：<code>epoll_create</code>，<code>epoll_ctl</code> 和 <code>epoll_wait </code>。epoll_create 用于创建一个 epoll 对象，epoll_ctl 用于向 epoll 对象注册或者删除 IO 对象，epoll_wait 用于等待 IO 对象就绪。<strong>与 select 和 poll 不同的是，epoll 使用了事件驱动的方式，只通知就绪的 IO 对象，从而避免了遍历整个 IO 对象集合的开销</strong>，提高了性能和可扩展性。其还支持边缘触发和水平触发两种模式。</p>
<p>对比：对于 select 和 poll 而言，进程需要不断轮询每个文件描述符状态，以确定哪些描述符已经就绪，这种方式叫做轮询式（polling）。这样的轮询机制在文件描述符较小的情况下还可以接受，但是随着文件描述符数量的增多，效率会明显降低，因为大部分时间都在空转浪费 CPU 资源。</p>
<p>epoll 通过时间驱动的方式解决了这个问题。在使用 epoll 的时候，进程首先会注册一组文件描述符到 Epoll 实例中，然后调用 Epoll 等待函数，例如 <code>epoll_wait()</code> 。epoll 等待函数会将进程置于阻塞的状态，直到以下三种事件之一发生：</p>
<ul>
<li> 文件描述符变为可读状态（有数据可以从该文件描述符读取）</li>
<li>文件描述符可写（可以向该文件描述符写入数据）</li>
<li>文件描述符异常（例如关闭）</li>
</ul>
<p>一旦有任何一个就绪事件发生，Epoll 等待函数就会立即返回，并且告知进程哪些文件描述符已经就绪。这样，进程就只需要处理那些真正需要处理的就绪事件，而不需要遍历所有的文件描述符，进而减少了不必要的 CPU 开销。</p>
<p>通过事件驱动的方式，Epoll 在高并发环境中具有更好的性能，因为它避免了不必要的轮询，并且只关注真正需要处理的事件。这使得 Epoll 成为在 Linux 系统上进行高性能网络编程的首选技术之一。</p>
<h2 id="IO-多路复用的实现"><a href="#IO-多路复用的实现" class="headerlink" title="IO 多路复用的实现"></a>IO 多路复用的实现</h2><p>为了更好的介绍 IO 多路复用网络模型，我们先说结论：</p>
<p><strong>IO 多路复用实则是 回调+事件循环+ select(poll, epoll) 完成的， 通过在一个线程中监听多个网络套接字完成高并发。</strong></p>
<p>首先，我先介绍一下 python 中的 select 函数，用于监听文件描述符的状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br></pre></td></tr></table></figure>

<p>selectors 是一个高级 I/O 复用库。它建立在 select 模块原型的基础上， 其定义了一个 BaseSelector 抽象基类，以及多个实际的实现（KqueueSelector, EpollSelector），它们可被用于在多个文件对象上等待 I/O 就绪通知。</p>
<p>详情可见：<a href="https://docs.python.org/zh-cn/3/library/selectors.html">https://docs.python.org/zh-cn/3/library/selectors.html</a></p>
<p>好的，基本的准备工作已经介绍完了，接下来，我们将使用以上的知识实现一个 爬虫的工作，对一系列网页进行爬取工作。</p>
<p>首先定义一个 <code>Fetcher</code> 类，用于完成 socket client 的封装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Author: tyrone</span></span><br><span class="line"><span class="string">File: select_test.py</span></span><br><span class="line"><span class="string">Time: 2023/7/8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 通过非阻塞io实现http请求</span></span><br><span class="line"><span class="comment"># select + 回调 + 事件循环</span></span><br><span class="line"><span class="comment">#  并发性高</span></span><br><span class="line"><span class="comment"># 使用单线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br><span class="line"></span><br><span class="line">selector = DefaultSelector()</span><br><span class="line"><span class="comment"># 使用select完成http请求</span></span><br><span class="line">urls = []</span><br><span class="line">stop = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        selector.unregister(key.fd)</span><br><span class="line">        self.client.send(</span><br><span class="line">            <span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(self.path, self.host).encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">        selector.register(self.client.fileno(), EVENT_READ, self.readable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readable</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        d = self.client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            self.data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            selector.unregister(key.fd)</span><br><span class="line">            data = self.data.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">            html_data = data.split(<span class="string">&quot;\r\n\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(html_data)</span><br><span class="line">            self.client.close()</span><br><span class="line">            urls.remove(self.spider_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> urls:  <span class="comment"># 判断是否已抓取完成</span></span><br><span class="line">                <span class="keyword">global</span> stop</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        self.spider_url = url</span><br><span class="line">        url = urlparse(url)</span><br><span class="line">        self.host = url.netloc</span><br><span class="line">        self.path = url.path</span><br><span class="line">        self.data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            self.path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立socket连接</span></span><br><span class="line">        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.client.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.client.connect((self.host, <span class="number">80</span>))  <span class="comment"># 阻塞不会消耗cpu</span></span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注册</span></span><br><span class="line">        selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span>():</span></span><br><span class="line">    <span class="comment"># 事件循环，不停的请求socket的状态并调用对应的回调函数</span></span><br><span class="line">    <span class="comment"># 1. select本身是不支持register模式</span></span><br><span class="line">    <span class="comment"># 2. socket状态变化以后的回调是由程序员完成的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop:</span><br><span class="line">        ready = selector.select()</span><br><span class="line">        <span class="keyword">for</span> key, mask <span class="keyword">in</span> ready:</span><br><span class="line">            call_back = key.data</span><br><span class="line">            call_back(key)</span><br><span class="line">    <span class="comment"># 回调+事件循环+select(poll\epoll)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    fetcher = Fetcher()</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">&quot;http://shop.projectsedu.com/goods/&#123;&#125;/&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">        urls.append(url)</span><br><span class="line">        fetcher = Fetcher()</span><br><span class="line">        fetcher.get_url(url)</span><br><span class="line">    loop()</span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure>



<p>在上述的代码中，其中比较重要的概念是：</p>
<ul>
<li>回调，即当文件描述符的状态发生变化时，应该回调什么函数去处理：<code>selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</code> &amp;&amp; <code>selector.register(self.client.fileno(), EVENT_READ, self.readable)</code></li>
<li>事件循环函数，控制整个进程的循环回调</li>
<li>回调结束标志位的结束</li>
</ul>
<p>于是，我们就实现了一个 IO 多路复用的模型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了一个 IO  多路复用模型的 python 代码实现，主要目的是介绍什么是 IO 多路复用模型，为什么要用到 IO 多路复用网络模型，以及其重要组成。</p>
<p>其实 IO 多路复用的设计理念是协程设计的基础，协程也是基于 select(poll, epoll) + 回调 + 事件循环实现的。</p>
]]></content>
      <categories>
        <category>IO 多路复用原理及实现</category>
      </categories>
      <tags>
        <tag>IO 多路复用原理及实现</tag>
      </tags>
  </entry>
  <entry>
    <title>unix 中的五种 IO 模型</title>
    <url>/posts/baf320b1/</url>
    <content><![CDATA[<h2 id="unix-中的五种-IO-模型"><a href="#unix-中的五种-IO-模型" class="headerlink" title="unix 中的五种 IO 模型"></a>unix 中的五种 IO 模型</h2><ul>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 多路复用</li>
<li>信号驱动式 I/O</li>
<li>异步 I/O （POSIX 的 aio_系列函数）</li>
</ul>
<h4 id="阻塞式-I-O"><a href="#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a>阻塞式 I/O</h4><img src="/images/unix_io_module/image-20230708100402340.png" alt="image-20230708100402340" style="zoom:50%;" />

<p>当采用阻塞式时，必须等待任务处理完成才能继续。<strong>其整体的逻辑是链式的</strong></p>
<h4 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h4><img src="/images/unix_io_module/image-20230708101215320.png" alt="image-20230708101215320" style="zoom:50%;" />

<p>当采用非阻塞时，需要消耗 CPU 去做轮询的工作来得知任务是否处理完成，适用于多个不同类型任务的机制，但是采用 recvfrom 轮询的方式，不但消耗了 cpu 资源，也会增加代码的复杂度。</p>
<h4 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h4><p>I/O 多路复用应用非常广泛，这里重点介绍一下：</p>
<p>IO 多路复用是一种高效的编程模型<strong>，用于同时监控多个 IO 的可读，可写或异常状态，从而实现在单个线程中处理多个 IO 任务的能力</strong>。它通常用于网络编程中，以提高程序的并发性和性能。</p>
<img src="/images/unix_io_module/image-20230708102943500.png" alt="image-20230708102943500" style="zoom:50%;" />

<p>select 是阻塞的，可以监听多个文件句柄，当某一个文件句柄的状态发生变化时，会立即返回。</p>
<h4 id="信号驱动式-IO"><a href="#信号驱动式-IO" class="headerlink" title="信号驱动式 IO"></a>信号驱动式 IO</h4><img src="/images/unix_io_module/image-20230708103516479.png" alt="image-20230708103516479" style="zoom:50%;" />



<h4 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h4><img src="/images/unix_io_module/image-20230708104117935.png" alt="image-20230708104117935" style="zoom:50%;" />



<p>其相对于 IO 多路复用而言，少了将数据从内核复制到用户空间的步骤，节省了时间</p>
<h4 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select\poll\epoll"></a>select\poll\epoll</h4><blockquote>
<p><code>select</code>、<code>poll</code>和<code>epoll</code>是用于<strong>实现IO多路复用的系统调用或函数。它们在不同的操作系统中提供了类似的功能，允许程序同时监视多个IO对象的状态。</strong></p>
<p>这些IO多路复用机制在网络编程中经常使用，特别是在服务器端的开发中，以处理大量并发的IO操作。它们允许程序同时监听多个套接字的可读、可写或异常状态，并在其中至少有一个套接字就绪时通知应用程序进行相应的处理。</p>
<p>下面是对<code>select</code>、<code>poll</code>和<code>epoll</code>的简要解释：</p>
<ol>
<li><code>select</code>：<code>select</code>是最古老和最常见的IO多路复用机制之一。它使用三个文件描述符集合（读、写和异常）来检查多个IO对象的状态。然后，它会阻塞等待，直到其中至少一个IO对象就绪或达到超时时间。然后，它返回就绪的IO对象，应用程序可以对其进行相应的操作。**<code>select</code>在每次调用时都需要重新构建文件描述符集合，效率较低。**</li>
<li><code>poll</code>：<code>poll</code>是相对于<code>select</code>更现代和高效的IO多路复用机制。类似于<code>select</code>，<code>poll</code>使用一个文件描述符数组来检查多个IO对象的状态。<strong>与<code>select</code>不同的是，<code>poll</code>不需要重新构建文件描述符集合，可以直接使用数组，从而提高了效率</strong>。它也能够处理更大的文件描述符数量。</li>
<li><code>epoll</code>：<code>epoll</code>是在Linux系统中提供的高效的IO多路复用机制。它引入了三个主要的概念：<code>epoll_create</code>、<code>epoll_ctl</code>和<code>epoll_wait</code>。<code>epoll_create</code>用于创建一个epoll对象，<code>epoll_ctl</code>用于向epoll对象注册或删除IO对象，<code>epoll_wait</code>用于等待IO对象就绪。与<code>select</code>和<code>poll</code>不同，<code>epoll</code>使用了事件驱动的方式，只通知就绪的IO对象，从而避免了遍历整个IO对象集合的开销，提高了性能和扩展性。它还支持边缘触发（edge-triggered）和水平触发（level-triggered）两种模式。</li>
</ol>
<p>需要注意的是，这些IO多路复用机制的具体使用和细节可能因操作系统而异。在选择使用哪个机制时，需要考虑操作系统的支持、应用程序的需求以及性能等因素。对于大多数情况，<code>epoll</code>在Linux系统中通常是最佳选择，因为它提供了更高的性能和扩展性。</p>
</blockquote>
<p>简单概括：</p>
<p>select 函数监听的文件描述符分为三类，分别是 writefds、readfds 和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有 except）或者超时（timeout 指定等待的时间，如果立即返回设置为 null 即可），函数返回。当 select 函数返回后，可以 通过遍历 fdset，来找到就绪的描述符。</p>
<p><strong>select 目前几乎在所有平台上都支持，其良好的跨平台支持也是它的一个优点。select 的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</strong></p>
<p>epool 是在 2.6 内核中提出的，是之前的 select 和 poll 的增强版本。相对于 select 和 poll 而言，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符对象来管理多个描述符，将用户关系的文件描述符的事件存放于内核的一个事件表中，这样在用户空间和内核空间的 copy 只需要一次。</p>
<p>epoll 的查询效率非常高，其背后的数据结构是因为其存储结构是一个红黑树实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># epoll 并不一定比 select 好</span><br><span class="line"># 在高并发的情况下，连接活跃数不是很高，epoll 比 select 好</span><br><span class="line"># 并发性不高，同时连接很活跃，select 比 epoll 好</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络 IO 模型</category>
      </categories>
      <tags>
        <tag>网络 IO 模型</tag>
      </tags>
  </entry>
  <entry>
    <title>TPC &amp;&amp; PPC &amp;&amp; Reactor &amp;&amp; proactor</title>
    <url>/posts/dfc2376a/</url>
    <content><![CDATA[<h1 id="TPC-amp-amp-PPC-amp-amp-Reactor-amp-amp-proactor"><a href="#TPC-amp-amp-PPC-amp-amp-Reactor-amp-amp-proactor" class="headerlink" title="TPC &amp;&amp; PPC &amp;&amp; Reactor &amp;&amp; proactor"></a>TPC &amp;&amp; PPC &amp;&amp; Reactor &amp;&amp; proactor</h1><p>[TOC]</p>
<p>高性能架构设计主要集中在两点：</p>
<ul>
<li>尽量提升单服务器的性能，将单服务器的性能发挥到极致</li>
<li>如果单服务器无法支撑性能，设计服务器集群方案</li>
</ul>
<p>架构设计决定了系统性能的上限，实现细节决定了系统性能的下限</p>
<p><strong>单服务器高性能的关键之一就是服务器采取的并发模型，并发模型设计的两个关键点：</strong></p>
<ul>
<li><strong>服务器如何管理连接</strong></li>
<li><strong>服务器如何处理请求</strong></li>
</ul>
<p>以上两个设计点最终都和操作系统的 I/O 模型及进程模型相关</p>
<ul>
<li>I/O 模型：阻塞、非阻塞、同步、异步</li>
<li>进程模型：单进程、多进程、多线程</li>
</ul>
<h2 id="PPC"><a href="#PPC" class="headerlink" title="PPC"></a>PPC</h2><p><strong>Process Per Connection -&gt; 每次有新的连接就新建一个进程去专门处理这个连接的请求</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/53/ba/53b17d63a31c6b551d3a039a2568daba.jpg?wh=3249*2950" alt="img"></p>
<ul>
<li>父进程接受连接（accept）</li>
<li>父进程 fork 子进程（fork）</li>
<li>子进程处理连接的读写请求（read\业务处理\write）</li>
<li>子进程关闭连接（close）</li>
</ul>
<blockquote>
<p>在当父进程 fork 子进程后，直接调用了 close，实际上只是将连接的文件描述符引用计数减一，真正的关闭连接是等子进程也调用 close 后，连接对应的文件描述符的引用计数变为 0 后，操作系统才会真正关闭连接。</p>
</blockquote>
<p><strong>PPC 模式实现简单，比较适合服务器的连接数没那么多的情况，例如数据库服务器。</strong>当服务器的访问量增加后，这种模式的弊端主要体现在：</p>
<ul>
<li><strong>fork 代价高</strong>：在操作系统的角度，fork 一个进程的代价较高，需要分配很多内核资源，需要将内存映像从父进程复制到子进程。<strong>即使现在的操作系统在复制内存映像时用到了 Copy on Write 技术</strong>，但是创建一个进程的代价还是很大的</li>
<li><strong>父子进程通信复杂</strong>：父子之间需要通过 IPC （Interprocess Communication）之类的进程通信方案。</li>
<li><strong>支持的并发连接数量有限</strong>：如果每个连接存活时间比较长，而且新的连接又源源不断的进来，则进程数量会越来越多，操作系统进程调度和切换的频率也会越来越高，系统的压力也会越来越大。</li>
</ul>
<h3 id="prefork"><a href="#prefork" class="headerlink" title="prefork"></a>prefork</h3><p>由于 fork 进程代价较高，用户访问时可能会感觉比较慢，prefork 模式的出现就是为了解决这个问题。</p>
<p>prefork 就是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。</p>
<h2 id="TPC"><a href="#TPC" class="headerlink" title="TPC"></a>TPC</h2><p><strong>TPC 是 Thread Per Connection 的缩写，其含义是指每次有新的连接就新建一个线程就专门处理这个连接的请求</strong>。优点如下：</p>
<ul>
<li>线程相较于进程而言，更加轻量级；</li>
<li><strong>多线程是共享内存空间的，线程通信比进程更加简单</strong>；</li>
</ul>
<p><strong>TPC 实际上是解决或者弱化了 PPC fork 代价高的问题和父子进程通信复杂的问题；</strong></p>
<p>TPC 虽然解决了 fork 代价高和进程通信复杂的问题，但是也引入了新的问题：</p>
<ul>
<li>当遇到高并发问题时（每秒上万连接），还是有性能问题；</li>
<li>无须进程间通信，但是线程间的互斥和共享引入了复杂度，会造成<strong>死锁问题</strong>；</li>
<li>多线程会出现互相影响的情况，当某个线程出现异常时，可能导致整个进程退出（内存越界）</li>
</ul>
<p><strong>TPC 还存在 CPU 线程调度和切换代价的问题。因此 TPC 方案本质上和 PPC 方案基本类似，在并发几百的连接下，反而更多的是采用 PPC 的方案，因为 PPC 方案不会有死锁的风险，也不会多进程互相影响，稳定性更高。</strong></p>
<h3 id="prethread"><a href="#prethread" class="headerlink" title="prethread"></a>prethread</h3><p>TPC 模式中，当连接进来时才创建新的线程来处理连接请求，虽然创建线程比创建进程要更加轻量级，但还是有一定的代价，而 prethread 模式就是为了解决这个问题。</p>
<p>和 prefork 类似，prethread 模式就会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。</p>
<p><strong>Apache 服务器的 MPM worker 本质上就是一种 prethread 方案。Apache 服务器会首先创建多个进程，每个进程里面再创建多个线程，这样做主要是为了考虑稳定性，即：即使某个子进程里面的某个线程异常导致整个子进程退出，还会有其他子进程继续提供服务，不会导致整个服务器全部挂掉。</strong></p>
<h2 id="PPC-amp-amp-TPC-应用场景分析"><a href="#PPC-amp-amp-TPC-应用场景分析" class="headerlink" title="PPC &amp;&amp; TPC 应用场景分析"></a>PPC &amp;&amp; TPC 应用场景分析</h2><p>什么样的系统适用于上述的模式呢？</p>
<p><strong>首先 PPC 和 TPC 能够支持的最大连接数差不多，都是几百个</strong></p>
<ol>
<li>海量连接海量请求：秒杀、双十一，上述的模式都不适合；</li>
<li><strong>常量连接（几十上百）海量请求：中间件、数据库，redis 等，适合；</strong></li>
<li>海量连接常量请求：门户网站；不适合</li>
<li><strong>常量连接常量请求：内部管理系统，上述的模式比较适合</strong></li>
</ol>
<p><strong>更多的情况时采用二者结合的系统，例如上述介绍的 MPM worker，采用多进程下的多线程，保持服务的高可用。</strong></p>
<h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p>reactor 的由来：</p>
<blockquote>
<p>对于 PPC &amp;&amp; TPC 而言，其高并发场景是不适用的</p>
<p>PPC 模式最主要的问题就是每个连接都要创建进程（或者线程），连接结束后进程就销毁了，这样其实造成了巨大的浪费。为了解决这个问题，使用进程池，将连接分配给进程，一个进程可以处理多个连接的业务。</p>
<p>引入资源池的处理方式后，会引出一个新的问题：进程如何才能高效地处理多个连接的业务？</p>
<p>当一个连接一个进程时，进程采用 “read -&gt; 业务处理 -&gt; write”的处理流程，此时会导致大量进程会阻塞在 read 上，这样是无法做到高性能的。</p>
<p><strong>解决这个问题的最简单的方式是将 read 操作改为非阻塞，然后进程不断地轮询多个连接。</strong></p>
<p>这种方式能够解决阻塞的问题，但是在遇到一个进程处理几千上万的连接时，轮询的效率是非常低的。</p>
<p>为了能够更好地解决上述问题，只有当连接上有数据的时候，进程才会去处理，这就是 I/O 多路复用技术的来源</p>
</blockquote>
<p>IO 多路复用技术有两个关键实现点：</p>
<ul>
<li>当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须轮询所有连接，常见的方式有：select、epoll、kqueue 等</li>
<li>当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理</li>
</ul>
<p><strong>IO 多路复用结合线程池，完美地解决了 PPC 和 TPC 的问题。这也就是 Reactor模式，可以通俗的理解为来了一个事件我就有相应的反应。</strong></p>
<p>Reactor 模式也叫 Dispatcher 模式，更加贴近模式本身的含义，即 I/O 多路复用统一监听，收到事件后分配给某个进程。</p>
<p><strong>Reactor 模式的核心组成部分包括 Reactor 和处理资源池，其中 Reactor 负责监听和分配事件，处理资源池负责处理事件。</strong></p>
<p>结合不同的业务场景，Reactor 模式的具体实现方案灵活多变，主要体现在：</p>
<ul>
<li>Reactor 的数量可以变化：可以时一个 Reactor, 也可以是多个 Reactor。</li>
<li>资源池的数量可以变化，可以是单个进程，也可以是多个进程。</li>
</ul>
<p>最终 Reactor 模式有三种典型的实现方案：</p>
<ul>
<li>单 Reactor 单进程 / 线程。</li>
<li>单 Reactor 多线程。</li>
<li>多 Reactor 多进程 / 线程。</li>
</ul>
<h3 id="单-Reactor-单进程-线程"><a href="#单-Reactor-单进程-线程" class="headerlink" title="单 Reactor 单进程 / 线程"></a>单 Reactor 单进程 / 线程</h3><img src="https://static001.geekbang.org/resource/image/c2/c0/c2fafab3yybd83e97027b3e3f987f9c0.jpg?wh=3789*2184" alt="img" style="zoom:24%;" />

<p>流程：</p>
<ul>
<li>Reactor 通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。</li>
<li>如果是建立连接的事件，则由 Acceptor 处理， Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。</li>
<li>若不是连接事件，则 Reactor 会调用连接对应的 Handler 来进行响应。</li>
<li>Handler 会完成 read -&gt; 业务处理 -&gt; send 的完整业务流程。</li>
</ul>
<p>单 Reactor 单进程的模式优点如下：</p>
<ul>
<li>无进程间通信，没有竞争，全部都在一个进程中完成</li>
</ul>
<p>缺点也非常明显，具体表现有：</p>
<ul>
<li>只有一个进程，无法发挥多核 CPU 的性能；</li>
<li>Handler 在处理某个连接上的业务时，整个进程无法处理其他连接的事件，很容易导致性能瓶颈。</li>
</ul>
<p>因此，单 Reactor 单进程的方案在实践中应用的场景不多，<strong>只适用于业务处理非常快速的场景，目前比较著名的开源软件中使用单 Reactor 单进程的是 Redis。</strong></p>
<h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h3><p>针对 Handler 的性能瓶颈，引入多进程 / 多线程是显而易见的，这就产生了第二个方案：单 Reactor 多线程。</p>
<img src="https://static001.geekbang.org/resource/image/73/da/73a2d97c63c143a01b2e671942024fda.jpg?wh=4946*1993" alt="img" style="zoom:24%;" />

<p>流程为：</p>
<ul>
<li>主进程中，Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发；</li>
<li>如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件；</li>
<li>Handler 只负责响应事件，不进行业务处理；Handler 通过 read 读取到数据后，会发给 Processor 进行业务处理；</li>
<li>Processor 会在独立的子线程中完成真正的业务处理， 然后将响应结果发送给主进程的 Handler 处理；Handler 收到响应后通过 send 将响应结果返回给 client;</li>
</ul>
<p>单 Reactor 多线程的方案能够充分利用多核多 CPU 的处理能力，但同时也存在下面的问题：</p>
<ul>
<li>多线程数据共享和访问比较复杂。</li>
<li>Reactor 承担所有事件的监听和响应，只在主线程中运行，瞬间高并发会成为性能瓶颈。</li>
</ul>
<h3 id="多-Reactor-多进程-线程"><a href="#多-Reactor-多进程-线程" class="headerlink" title="多 Reactor 多进程 / 线程"></a>多 Reactor 多进程 / 线程</h3><p>为了解决单 Reactor 多线程中 单 Reactor 瞬间高并发的性能瓶颈，最直接的方式就是采用多 Reactor 多进程监听；</p>
<img src="https://static001.geekbang.org/resource/image/6c/ba/6cfe3c8785623f93da18ce3390e524ba.jpg?wh=4434*1860" alt="img" style="zoom:24%;" />

<ul>
<li>父进程中 mainReactor 对象通过 select 监听连接建立事件，收到事件后通过 Acceptor 接收，将新的连接分配给某个子进程。</li>
<li>子进程的 subReator 将 mainReator 分配的连接加入连接队列进行监听，并创建一个 Handler 用于处理连接的各种事件。</li>
<li>当有新的事件发生时，subReactor 会调用连接对应的 Handler 来进行响应。</li>
<li>Handler 完成 read -&gt; 业务处理 -&gt; send 的完整业务流程。</li>
</ul>
<p>上述方案在实现时相较于 单 Reactor 要简单：</p>
<ul>
<li>父子进程的职责非常明确，父进程只负责接收新连接，子进程负责完成后续的业务处理</li>
<li>父进程和子进程的交互很简单，父进程只需要把新连接传给子进程，子进程无须返回数据。</li>
<li>子进程之间是互相独立的，无须同步共享之类的处理（仅限于网络模型的 select\read\send）</li>
</ul>
<p>Nginx 采用的是多 Reactor 多进程的模式；但是方案与标准的多 Reactor 多进程有差异。</p>
<h2 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h2><p>Reactor 是非阻塞同步网络模型，因为真正的 read 和 send 操作都需要用户进程同步操作。</p>
<p>若将 I/O 操作改为异步就能够进一步提升性能，这就是异步网络模型 Proactor。</p>
<p>Reactor 可以理解为<strong>来了事件，我通知你，你来处理</strong>，而 proactor 可以理解为<strong>来了事件我来处理，处理完了我通知你</strong></p>
<p>这里的我就是操作系统内核，事件就是有新连接、有数据可读、有数据可写这些 I/O 事件，你就是我们的程序代码。</p>
<img src="https://static001.geekbang.org/resource/image/f4/fe/f431b2674eb0881df6a1d1f77a3729fe.jpg?wh=4374*1853" alt="img" style="zoom:24%;" />



<p>流程：</p>
<ul>
<li><p>Proactor Initiator 负责创建 Proactor 和 Handler，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核。</p>
</li>
<li><p>Asynchronous Operation Processor 负责处理注册请求，并完成 I/O 操作。</p>
</li>
<li><p>Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor。</p>
</li>
<li><p>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理。</p>
</li>
<li><p>Handler 完成业务处理，Handler 也可以注册新的 Handler 到内核进程。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 IO 操作一般分为两个阶段：</p>
<ul>
<li><ol>
<li>数据准备（读到内核缓存）</li>
</ol>
</li>
<li><ol start="2">
<li>将数据从内核读到用户空间</li>
</ol>
</li>
</ul>
<p>一般而言 1 花费的时间远远大于 2。1 上阻塞 2 上也阻塞的称为同步阻塞。</p>
<p>1 上非阻塞 2 上也阻塞的称为同步非阻塞 IO，这讲的就是 Reactor 这种模型</p>
<p>1 上非阻塞 2 上非阻塞的称为异步非阻塞，这就是 Proactor</p>
<p>Reactor与Proactor能不能这样打个比方： 1、假如我们去饭店点餐，饭店人很多，如果我们付了钱后站在收银台等着饭端上来我们才离开，这就成了同步阻塞了。 2、如果我们付了钱后给你一个号就可以离开，饭好了老板会叫号，你过来取。这就是Reactor模型。 3、如果我们付了钱后给我一个号就可以坐到坐位上该干啥干啥，饭好了老板会把饭端上来送给你。这就是Proactor模型了。</p>
]]></content>
      <categories>
        <category>网络 IO 模型</category>
      </categories>
      <tags>
        <tag>网络 IO 模型</tag>
      </tags>
  </entry>
  <entry>
    <title>技术人如何做到高效沟通</title>
    <url>/posts/64aac8ff/</url>
    <content><![CDATA[<h1 id="技术人如何做到高效沟通？"><a href="#技术人如何做到高效沟通？" class="headerlink" title="技术人如何做到高效沟通？"></a>技术人如何做到高效沟通？</h1><p><code>talk is cheap, show me the code</code> 这是技术人经常说的一句话。意思是光说不练是简单的，但是代码实现确实很复杂的。</p>
<p>这句话是 linus 的语录，表明代码才是实现逻辑的关键。</p>
<p>但是随着我们这一行的慢慢发展，我在工作中逐渐发现，对于一些需求而言，需要返回和产品以及技术沟通，才能真正弄清楚我们到底要实现什么？</p>
<p>常见的一个需求沟通场景是：</p>
<ul>
<li>产品：这周我们要实现一个 A 功能</li>
<li>技术：为什么要实现 A 功能？</li>
<li>产品：背景是这样的：….</li>
<li>技术：好的，我要做一下技术调研，明确一下技术复杂度</li>
<li>技术：这个功能是否需要或者是否有其他的替代方式，感觉这个需求比较鸡肋</li>
<li>产品：这是用户反馈的</li>
<li>技术：我们是否可以有别的实现的方式？</li>
<li>…..</li>
</ul>
<p>通过上面的例子，在一个产品功能落地的时候，往往是需要不断进行沟通的，从这个功能的背景，需求来源，是否合理，技术难度，优化迭代等等很多方面去进行考虑，这就需要我们不断进行沟通考量。</p>
<p><strong>今天这篇文章就是讨论技术人员的职场软技能——如何做好沟通？也借此篇文章不断优化自己的沟通能力</strong></p>
<h2 id="沟通的原理"><a href="#沟通的原理" class="headerlink" title="沟通的原理"></a>沟通的原理</h2><p>当我们与人进行沟通的时候，首先要明确一点，沟通建立的原理。</p>
<p>就拿 TCP 协议来说，当 C/S 双方进行沟通的时候，首先要建立起沟通的桥梁，然后是使用双方都能编解码的信息进行通信。<strong>对于人与人之间的沟通也是，也是需要建立起沟通的桥梁，例如直接对话，电话，聊天软件，然后就是使用双方都能理解的语言。</strong>这里我举几个例子，让你明白我这句话的含义：</p>
<ul>
<li>中国人和中国人之间的对话</li>
<li>中国人和英国人之间的对话</li>
<li>技术和小白之间的对话</li>
</ul>
<p>对于如何建立起沟通的桥梁而言，如果沟通双方都不能理解对方的语言，那么就形成了对牛弹琴，例如一个不会英文的中国人和一个不会中文的英国人之间是信息不通的。这也是沟通的前提，为什么很多外企都需要在招聘上写道：擅长英语口语交流。这是前提。</p>
<p>对于一个技术和一个小白而言，可能也会存在很多沟通障碍，例如我说：<strong>这个系统可能需要用到分布式部署的方式，要解决高并发的问题，QPS 要到 1000 左右，部署的话采用云的方式是最好的。</strong>如果我是一个职场小白，对于分布式/QPS/云部署 这些概念我是一窍不通的，那么我可能要改变我说话的方式：<strong>对于我们这个系统的设计，要解决多用户使用的问题，例如同时支持上千个用户的任务请求，秒级别的在线人数要到 1000 的处理量，部署的方式最好购买云服务器，例如阿里云。</strong></p>
<p>在上面的两个对话中，我们可以清晰的知道，<strong>对于沟通而言，需要因人而异的。也就是要学会换位思考，站在别人的角度上思考沟通的方式，沟通的话术</strong></p>
<p><strong>当然，有人可能要说了，我怎么能比较清晰的知道这个人到底什么知道，什么不知道呢？</strong></p>
<p>是的，对于每个人而言，我们不可能 100% 知道这个人的知识储备，于是，<strong>反馈机制就很重要</strong>，就类似 TCP 协议中的重传机制（这个例子可能不好）,对于我说的每一句话，对方是否知道，是否知道我的意思了。</p>
<p>这里还是借上面的机制来说明：</p>
<ul>
<li>我：这个系统需要分布式的方式来进行部署，要解决高并发的问题。</li>
<li>other: 什么是分布式部署啊</li>
<li>我：可以理解为多台机器协同的方式，这样比较稳定</li>
<li>other：什么是高并发呢？</li>
<li>我：可一理解为，同一时刻可以满足多人的任务请求，例如 1000 人同时在线且在提交请求。</li>
</ul>
<p><strong>这个时候通过一问一答的方式，就建立起了反馈机制。这样可以解决信息的偏差问题</strong></p>
<p>最后一点就是<strong>信息的完整性</strong></p>
<p>对于领导或者同事的任务要求，最好是保证其原来的面貌。对于一个公司而言，信息往往是从上到下的，从一个理念到具体的实现，往往情况就是通过一层层的传导，信息的原貌会逐渐破坏。</p>
<p>例如下面这个经典的图：</p>
<img src="https://static001.geekbang.org/resource/image/cc/41/ccbd8bba1fd6c2de2f9ec25dd7a99d41.png?wh=939*704" alt="img" style="zoom:50%;" />



<p>所以在传导信息时，最好加上信息的源头，现在的聊天软件，例如微信的引用功能，就能让我们知道每句话的理解来自哪里。</p>
<h2 id="沟通中的阻碍"><a href="#沟通中的阻碍" class="headerlink" title="沟通中的阻碍"></a>沟通中的阻碍</h2><p>在日常工作中，你可能经常会听到某人说，这个人挺好沟通的。<strong>对于沟通的一方而言，其实比较关注的是我如何能在最小代价的情况下，获取到信息</strong>，那么导致这些阻碍主要是哪些方面</p>
<p>那么如何提升准确性呢？我将从以下几个方面来阐述：</p>
<ul>
<li>信息的不准确</li>
<li>信息太多</li>
<li>表达方式</li>
<li>二手信息</li>
</ul>
<h3 id="信息的复杂度"><a href="#信息的复杂度" class="headerlink" title="信息的复杂度"></a>信息的复杂度</h3><p>对于首次发起沟通的人来说，你可能在沟通之前需要思考一下，如何构建自己的语料。如果你自己都不能明确知道你将要说的话，那么我建议你在说话之前先整理一下将要进行沟通的语料。</p>
<p><strong>常见的方式就是用文本化的方式整理出来，这也就是为什么很多公司在进行产品设计的时候，需要产品故事（pstory）、用户故事（user story）,需求详设等等，</strong>这些文本化的东西都是针对不同的受众而言的。</p>
<p>对于一个复杂的需求而言，如何去文本化，如何拆解，是很重要的，也很考验我们的语言组织能力。当然，如果你认为个人的对话能力有限，就采用文本的方式进行沟通，如何提升自己这方面的能力呢？其实就是多练，多沟通。</p>
<p>当然，对于你的领导同事而言，你可能有一些个人的想法需要包装，害怕太直接导致沟通受阻，于是就提升了信息的复杂度。</p>
<p><strong>在我以前的工作中，当一个需求来的时候，我很多时候其实是不太了解其中需求的难度的，于是我通常会直接说明，需要时间去调研分析，而不是支支吾吾害怕暴露自己的技术水平，因为对于技术人员来说，技术是永远学不完的，没有谁能什么都懂。有话直说，这是最高效的沟通方式，也是对对方的一种尊重和信任，这样下来，事情往往更好解决。</strong></p>
<h3 id="信息的交互"><a href="#信息的交互" class="headerlink" title="信息的交互"></a>信息的交互</h3><p>相信很多技术人都会遇到一个情况，那就是开会的时候，你的领导在介绍完一个技术或者说明一些部门情况时，往往会说一句：大家还有甚么问题吗？这个时候很多人都会沉默不语。</p>
<p>这个时候信息的交流就变成了单向沟通，时间一长，对于部门的问题是很大的。</p>
<p><strong>所以，对于这种情况，要能站在对方的角度上思考问题，降低表达自己真实想法的门槛，培养让大家畅所欲言的自由环境，引出一个问题，然后让大家思考表达，这样也许会更能了解大家的想法。</strong></p>
<h3 id="信息的来源"><a href="#信息的来源" class="headerlink" title="信息的来源"></a>信息的来源</h3><p>由于信息在传递过程中会有一定的损耗，导致信息即使在没有主观意识上的修改之外，也会存在变化，故到信息的源头去，<strong>向当事人求证，会让这个世界更加和谐，也会让你变得更加有智慧。</strong></p>
<h3 id="信息的透明"><a href="#信息的透明" class="headerlink" title="信息的透明"></a>信息的透明</h3><p>我们知道，在网络通信中，信息是有被篡改的风险的，如果当你想要向别人传达信息时，一定要保证信息的公开透明，而不是让其他人帮你传递信息</p>
<h2 id="沟通的方式和技巧"><a href="#沟通的方式和技巧" class="headerlink" title="沟通的方式和技巧"></a>沟通的方式和技巧</h2><p><strong>好的沟通有多种表现形式，最常用的组合是：尊重，倾听和情绪控制</strong></p>
<h3 id="尊重"><a href="#尊重" class="headerlink" title="尊重"></a>尊重</h3><p>尊重是沟通的前提，在你和对方进行沟通时，一定要尊重对方的观点：</p>
<ul>
<li><strong>我可以不同意你的观点，但是我会捍卫你说话的权利</strong>：即便对方的观点你暂时是不同意的，也要尊重对方想要表达的欲望，这也是一个沟通的过程，当沟通多次后，你会发现，可能一开始你不同意的观点也是有可取之处的。</li>
<li><strong>赢得对方的尊重首先要尊重对方</strong>：在你表现出对他人的尊重后，你也能赢得对方的尊重。</li>
</ul>
<p><strong>沟通的目的不是去为了反驳或者附和对方，而是思维的碰撞，沟通是为了获得更完整更全面的认知。</strong></p>
<h3 id="倾听"><a href="#倾听" class="headerlink" title="倾听"></a>倾听</h3><p>在 《沟通的艺术》这本书中将倾听定位为沟通的第一要则，足见其重要性。</p>
<p><strong>我们之所以要倾听，是因为倾听可以让我们获得更多的信息，对对方有更多的了解。</strong>倾听能让对方感觉到自己被尊重，才会和你分享更多的信息。</p>
<h3 id="情绪控制"><a href="#情绪控制" class="headerlink" title="情绪控制"></a>情绪控制</h3><p>能否控制好自己的情绪至关重要。如果不能控制自己的情绪，那么将让沟通难以进行。具体应该怎么做呢？</p>
<ul>
<li><p><strong>不要过早或者过度打岔和反驳</strong>：对于有些观点，知道事情的来龙去脉是很重要的，所以要听完别人的话后在进行分析理解，给予反馈</p>
</li>
<li><p><strong>求同存异，冷静客观：</strong>每个人的知识储备，生长背景，经历和性格不同，所以在看待问题时，自然会有很大的差异，所以要懂得尊重差异，客观公正地思考问题，并给出建议和方法。</p>
<p><strong>切勿冲动给出一些观点或者说出过激的话，因为言语的杀伤力是很大的，难以估计</strong></p>
</li>
</ul>
<p>当然，人是情感动物，有时候在你和别人对话时，你不知道当时这个人所处什么样的情绪之下，有时候你不经意的一句话可能会让对方难以接受，所以要<strong>慎言慎行，察言观色</strong>，当发现沟通难以进行时，应及时反馈领导或者终止沟通，待环境变好时再进行。本人就是个急性子，所以也还在修行当中。</p>
<h3 id="引起对方的兴趣"><a href="#引起对方的兴趣" class="headerlink" title="引起对方的兴趣"></a>引起对方的兴趣</h3><p>当你想让别人能够对于你的话题或者观点重视时，你就要引出一些让对方感兴趣的话题。例如我在一次团队分享时，我为了引起大家对 CodeReview 的重视，我的分享标题是：《Codereview 是如何降低我们的开发效率的》，文章一开始阐述了 CodeReview 需要我们关注的点，如何难以进行导致我们开发效率变低，引出 CR。然后再阐述 CodeReview 的优点，最后表明了 CodeReview 在长期发展下，反而提高了我们的开发效率和代码的稳定性。</p>
<h3 id="直达主题，强化观点"><a href="#直达主题，强化观点" class="headerlink" title="直达主题，强化观点"></a>直达主题，强化观点</h3><p>当你想表达一个观点事，最好是强调重点，而不是一开始从细节上谈实现。但很多时候产品需求都是很模糊的。而且很多时候，整个世界都是模糊的、有歧义的。有的人这么说，有的人那么说。你都不知道自己该信谁。所以亚马逊要求员工有一个能力就是，你一定要有把模糊的理解变成准确理解的能力，因为如果不这样，你是写不出代码来的。</p>
<p><strong>确定自己的目标，学会抓重点，知道自己要什么和不要什么，这样你要的才会更鲜明。当一些事情变得简明和鲜明起来时，你才会表现出有力量的观点和话语。而这些被强化过的观点和话语，只需要一句，就会在对方脑子里形成一个小爆点，要么击中了对方的软处（扎心），要么会让对方产生深度思考。</strong></p>
<h3 id="基于数据和事实"><a href="#基于数据和事实" class="headerlink" title="基于数据和事实"></a>基于数据和事实</h3><p>第三是<strong>用数据和事实说话。</strong>你跟别人沟通，要尽量少说“可能、也许、我觉得就这样”等字眼，你最好通过数据和证据，通过权威的引用和证词，通过相关的实例和亲身的事例来让你的观点有不可被辩驳不可被质疑的特性。当你的信息出现了这样的特性时，接收信息的人，基本上来说，就会无条件地相信。别人会无条件地相信你说的话，你想想这是一种多么牛的沟能方式！</p>
<h2 id="沟通的技术"><a href="#沟通的技术" class="headerlink" title="沟通的技术"></a>沟通的技术</h2><ul>
<li>逻辑学</li>
<li>信息 X/Y 的问题</li>
<li>纬度</li>
<li>共同点</li>
</ul>
<p>待补充</p>
]]></content>
      <categories>
        <category>软技能</category>
      </categories>
      <tags>
        <tag>软技能</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊传输层协议- TCP 协议</title>
    <url>/posts/ac41cac4/</url>
    <content><![CDATA[<h1 id="什么是-TCP-协议？"><a href="#什么是-TCP-协议？" class="headerlink" title="什么是 TCP 协议？"></a>什么是 TCP 协议？</h1><blockquote>
<p>首先，TCP 协议是位于 <code>传输层</code>的协议，是<code>面向连接的</code>、<code>可靠的</code>流协议<br>TCP 为了提高可靠性传输，实行<code>顺序控制</code>或<code>重发控制</code>。此外还有<code>流量控制</code>、<code>拥塞控制</code>、<code>提高网络利用率</code>等众多功能</p>
</blockquote>
<p>下面，就从 TCP 协议的这些特点说开去：</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><blockquote>
<p>TCP 协议是如何实现传输过程中的可靠性，又是怎么实现的？<br>一句话概括：<strong>TCP 通过 校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输</strong>。<br>接下来，将引入包的传递过程，来带入这些概念：</p>
</blockquote>
<p>ack - 校验和</p>
<blockquote>
<p>客户端和服务端之间通过校验随机数+1，来确认连接</p>
</blockquote>
<p>ACK - 确认应答</p>
<blockquote>
<p>客户端和服务端使用确认应答 ACK 来知道二者的连接请求。</p>
</blockquote>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote>
<p>TCP 是提供面向连接的通信传输。面向连接指的就是在数据通信开始之前先建立连接，确保传输通道的连通性。<br>而所谓三次握手就是建立一个 TCP 连接时需要 客户端和服务端总共发送三个包以确认连接的建立</p>
</blockquote>
<p>这里引入三次握手来解释相关概念：<strong>校验和（ack）&amp;&amp; 确认应答（ACK）</strong></p>
<p>流程图：<br><img src="/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="direct"></p>
<p>第一次握手：客户端将标志位 <code>SYN = 1</code>，随机生成一个值 <code>seq = j</code>，并将该数据包发送给服务端，客户端进入 <code>SUN_SENT</code> 状态，等待客户端的确认。<br>第二次握手：服务端接收到 <code>SYN = 1</code>的数据包后，明确客户端请求建立连接，服务端将标志位<code>SYN = 1、ACK=1</code>，随机生成一个随机数 <code>seq=k</code>，<strong>校验和 ack=j+1</strong>，并将该数据包发送给客户端以确认连接请求，服务器进入<code>SYN_RCVD</code>状态。<br>第三次握手：客户端收到确认后，检查<code>检验和 ack = j+1</code>,ACK=1。如果正确将标志位 ACK = 1 。<strong>校验和 ack = k+1</strong>,并将该数据包发送给服务器端，服务器端检查 <strong>检验和 ack = k+1,ACK=1</strong>,如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后便可以开始通信了。</p>
<h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><blockquote>
<p>在数据的传输中，可能存在<code>数据包丢失</code>或者<code>未收到确认应答</code>的情况，此时为了实现<code>可靠传输</code>,就会触发<strong>重发机制</strong>。<br>但是，也会有部分原因导致确认应答延迟到达，数据包实际上已经到达来服务端，那么服务端就会反复的接收到相同的数据包，为了避免这种情况，就会有<strong>重复控制</strong>功能。</p>
</blockquote>
<p>上述<strong>确认应答机制</strong>、<strong>重发控制</strong>以及<strong>重复控制</strong>等功能都可以借助<strong>序列号</strong>来实现。</p>
<blockquote>
<p>序列号是按顺序给发送数据的每一个字节（8位字节）都标上号码的编号。将自己下一步应该接收的序列号作为确认应答返送回去。<br><img src="/images/%E5%BA%8F%E5%88%97%E5%8F%B7.png" alt="direct"></p>
</blockquote>
<p>通过序列号和确认应答号，TCP 就可以实现顺序传输和可靠传输</p>
<h2 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h2><blockquote>
<p>当发送端发送数据后，会有一个等待确认应答到来的<strong>特定时间间隔</strong>。若超过了这个时间仍未收到确认应答，发送端将数据进行数据重发。</p>
</blockquote>
<p>然而这个重发超时时间的确定是根据当前的网络环境确认的，随着网络环境的不同而有所变化。</p>
<p>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。<br>它在每次发包时都会计算<code>往返时间</code>及其<code>偏差</code>。</p>
<p>重发超时的值就是比<code>往返时间</code>和<code>偏差</code>相加大一点的值，由于数据包的分段是经过不同路线到达的，所以网络环境的往返时间可能会产生大幅度的摇摆。</p>
<p>TCP/IP 的目的就是即使在这种环境下也要进行控制，避免流量的浪费。</p>
<p><img src="/images/%E9%87%8D%E5%8F%91%E8%B6%85%E6%97%B6.png" alt="direct"></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><blockquote>
<p>TCP 提供面向有连接的通信传输。面向有连接的是指在数据通信开始之前先做好通信两端之间的准备工作。<br>这里通常是指<code>三次握手和四次挥手</code><br><img src="/images/%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.png" alt="direct"></p>
</blockquote>
<h2 id="TCP-发送数据的单位：段"><a href="#TCP-发送数据的单位：段" class="headerlink" title="TCP 发送数据的单位：段"></a>TCP 发送数据的单位：段</h2><blockquote>
<p>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们称为<strong>最大消息长度</strong>（MSS: Maximum Segment Size）。<br>最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</p>
</blockquote>
<h4 id="MSS-的计算方式"><a href="#MSS-的计算方式" class="headerlink" title="MSS 的计算方式"></a>MSS 的计算方式</h4><p>MSS 是在三次握手的时候，在两端主机之间被计算出。两端主机在建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 大小。<br>MSS 的大小就会在两者之间选择一个较小的值。</p>
<p><img src="/images/MSS%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F.png" alt="direct"></p>
<h2 id="窗口控制提高速度"><a href="#窗口控制提高速度" class="headerlink" title="窗口控制提高速度"></a>窗口控制提高速度</h2><blockquote>
<p>TCP 以 1 个段为单位，每发送一个段就进行一次确认应答的处理。但是这样传输的话，包的往返时间越长性能也就越低。<br>为了解决这个问题，TCP 就引入了窗口这个概念。即使在往返时间较长的情况下，它也能控制网络性能的下降。</p>
</blockquote>
<p><strong>确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅度的缩短</strong><br><img src="/images/%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6.png" alt="direct"></p>
<h2 id="重发控制"><a href="#重发控制" class="headerlink" title="重发控制"></a>重发控制</h2><blockquote>
<p>窗口控制中的重发控制，是以序列号进行管理的，当数据包丢失后，发送端会根据接收端序列号来进行重发<br><img src="/images/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E5%8F%91.png" alt="direct"></p>
</blockquote>
<h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><blockquote>
<p>为了防止网络流量的无端浪费（接收端数据的处理）,TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。</p>
</blockquote>
<p>接收端告诉发送端自己接收的数据大小，实际上就是该窗口大小。<br><img src="/images/%E6%B5%81%E6%8E%A7%E5%88%B6.png" alt="direct"></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote>
<p>一般来说，计算机网络都处在一个共享的环境，因此也有坑因为其他主机之间的通信使得网络拥堵。<br>所以，如果一开始发送端就发送一个特大的数据包，可能会导致整个网络的瘫痪。<br>为了防止这个问题，TCP 在通信一开始时，就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。</p>
</blockquote>
<p>首先，为了在发送端调节所要发送的数据的量，定义了一个叫做<code>拥塞窗口</code>的概念。在慢启动的时候，将这个拥塞窗口的大小设置为一个数据段（1 MSS）发送数据，<br>之后每收到一次确认应答（ACK）,拥塞窗口的值就加一。<br>不过，随着包的每次往返，拥塞窗口也会以 1、2、4 等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生。为了防止这些，又引入了慢启动阈值的概念。<br>只允许按照特定比例放大拥塞窗口：</p>
<p>1 个数据段的字节数/拥塞窗口（字节）* 1 个数据段字节数</p>
<p><img src="/images/%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3.png" alt="direct"></p>
<p>于是，当 TCP 通信开始以后，网络的吞吐量会 逐步上升，但是随着网络拥堵的发生吞吐量也会极速下降。<br>接着，会再次进入吞吐量慢慢上升的过程。因此所谓 TCP 的吞吐量的特点就像是在逐步占领网络带宽的感觉。</p>
<p>参考：1.「 图解 TCP/IP 」2. 「 TCP/IP 卷一 」</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
</search>
